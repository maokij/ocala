package core_test

import (
	"ocala/core"
	"ocala/internal/ttarch"
	tt "ocala/testutil"
	"os"
	"slices"
	"strings"
	"testing"
)

func expectCompileOk(t *testing.T, src string) []byte {
	t.Helper()
	return ttarch.ExpectCompileOk(t, "ttarch", src)
}

func expectCompileError(t *testing.T, src string) string {
	t.Helper()
	return ttarch.ExpectCompileError(t, "ttarch", src)
}

func expectGenListOk(t *testing.T, src string) string {
	t.Helper()
	return ttarch.ExpectGenListOk(t, "ttarch", src)
}

func TestCompileAndGenerate(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", `
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: arch", func(t *testing.T) {
		g := ttarch.NewGenerator(`
			arch ttarch
			db 0 1 2 3 (__ARCH__ == "ttarch")
		`)
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0, 1, 2, 3, 1}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: variant", func(t *testing.T) {
		g := ttarch.NewGenerator(`
			arch ttarch +ext; flat!
			A -ext 1
			db (__ARCH__ == "ttarch+ext")
		`)
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0x70, 0x01, 1}, tt.Flush(g.OutWriter), g.ErrorMessage())
	})

	t.Run("ok: auto generate output path and list path", func(t *testing.T) {
		g := ttarch.NewGenerator("")
		g.OutPath = ""
		g.GenList = true
		g.ListPath = ""
		g.CompileAndGenerate("testdata/test.oc")
		b := tt.Must(os.ReadFile("testdata/test.bin"))
		s := tt.Must(os.ReadFile("testdata/test.lst"))
		tt.EqSlice(t, []byte{0, 1, 2, 3}, b, g.ErrorMessage())
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			000000 0000[4] 00 01 02 03                  .byte 0, 1, 2, 3
		`)[1:], string(s))
	})

	t.Run("ok: defs", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", `
			db USERDEF
		`)
		g.Defs = []string{"USERDEF"}
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{1}, tt.Flush(g.OutWriter))
	})

	t.Run("error: arch required", func(t *testing.T) {
		g := ttarch.NewGenerator(`
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: the first statement must be an `arch` directive "+
			"unless the `-t` option is specified", g.ErrorMessage())
	})

	t.Run("error: error message", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", "")
		tt.Eq(t, "", g.ErrorMessage())
		func() {
			defer g.HandlePanic()
			g.ErrorAt().With("<error>")
		}()
		tt.Eq(t, "generate error: <error>", g.ErrorMessage())
	})

	t.Run("error: invalid arch form", func(t *testing.T) {
		g := ttarch.NewGenerator(`
			arch
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: the first statement must be an `arch` directive "+
			"unless the `-t` option is specified", g.ErrorMessage())
	})

	t.Run("error: unknown arch", func(t *testing.T) {
		g := ttarch.NewGenerator(`
			arch unknown
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: unknown arch: unknown", g.ErrorMessage())
	})

	t.Run("error: full error message", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			// comment
			data byte [this-error]
		`))
		g.CompileAndGenerate("-")
		g.FlushMessages()
		tt.EqText(t, tt.Unindent(`
			-:2:11: compile error: undefined name this-error
			[error #0]
			  at -:2:11
			   |data byte [this-error]
			   |           ^-- ??
		`), tt.FlushString(g.ErrWriter))
	})

	t.Run("error: full error message 2", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			macro m(a) { A <- %=a }
			flat!; m ""
		`))
		g.CompileAndGenerate("-")
		g.FlushMessages()
		tt.EqText(t, tt.Unindent(`
			-:2:9: compile error: operand must be integer
			[error #0]
			  at -:2:9
			   |flat!; m ""
			   |         ^-- ??
			[error #1]
			  at internal identifier LD
			  from -:1:15
			   |macro m(a) { A <- %=a }
			   |               ^-- ??
			  from -:2:7
			   |flat!; m ""
			   |       ^-- ??
		`), tt.FlushString(g.ErrWriter))
	})

	t.Run("error: full messages", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`flat!
			warn "<warn01>"
			warn "<warn02>"
			compile-error "<error>"
		`))
		g.CompileAndGenerate("-")
		g.FlushMessages()
		tt.EqText(t, tt.Unindent(`
			-:1:0: warning: <warn01>
			[warning #0]
			  at -:1:0
			   |warn "<warn01>"
			   |^-- ??
			-:2:0: warning: <warn02>
			[warning #0]
			  at -:2:0
			   |warn "<warn02>"
			   |^-- ??
			-:3:0: compile error: <error>
			[error #0]
			  at -:3:0
			   |compile-error "<error>"
			   |^-- ??
		`), tt.FlushString(g.ErrWriter))
	})

	t.Run("error: nested full messages", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`flat!
			include "./testdata/include3/inc01.oc"
		`))
		g.CompileAndGenerate("-")
		g.FlushMessages()
		s := tt.FlushString(g.ErrWriter)
		s = strings.ReplaceAll(s, "\\", "/")
		s = strings.ReplaceAll(s, "\r\n", "\n")
		tt.EqText(t, tt.Unindent(`
			testdata/include3/inc03.oc:1:0: compile error: !
			[error #0]
			  at testdata/include3/inc03.oc:1:0
			   |compile-error "!"
			   |^-- ??
			[error #1]
			  at testdata/include3/inc02.oc:1:0
			   |include "./inc03.oc"
			   |^-- ??
			[error #2]
			  at testdata/include3/inc01.oc:1:0
			   |include "./inc02.oc"
			   |^-- ??
			[error #3]
			  at -:1:0
			   |include "./testdata/include3/inc01.oc"
			   |^-- ??
		`), s)
	})

	t.Run("error: debug mode", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			compile-error "!"
		`))
		core.Debug.Enabled = true
		defer func() { core.Debug.Enabled = false }()

		g.CompileAndGenerate("-")
		tt.Prefix(t, "compile error: !\n-- ", g.ErrorMessage())
	})

	t.Run("error: open failed", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			db 0 1 2 3
		`))
		g.CompileAndGenerate("./testdata/nothing.oc")
		tt.Prefix(t, "generate error: open ", g.ErrorMessage())
	})

	t.Run("error: write", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			db 0 1 2 3
		`))
		g.OutPath = "./testdata"
		g.CompileAndGenerate("-")
		tt.Prefix(t, "generate error: open ", g.ErrorMessage())
	})

	t.Run("error: output file name required", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			db 0 1 2 3
		`))
		g.OutPath = ""
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: output file name required", g.ErrorMessage())
	})

	t.Run("error: list file name required", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			db 0 1 2 3
		`))
		g.GenList = true
		g.ListPath = ""
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: list file name required", g.ErrorMessage())
	})

	t.Run("error: invalid defs", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			db 0 1 2 3
		`))
		g.Defs = []string{"loop"}
		g.CompileAndGenerate("-")
		tt.Eq(t, "compile error: loop is a builtin name", g.ErrorMessage())
	})
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list := expectGenListOk(t, `
			link { org 0 0 1; merge text _; org 0xc000 0 0; merge bss _ }
			section text
			const c001 = 1

			module ModA {
				const c002 = 2
				proc f002(!) { RET }
			}

			pragma list-constants 0 "omit c003, c004"
			const c003 = 3
			module ModB {
				const c004 = 4
				proc f004(!) { RET }
			}
			pragma list-constants 1
			const c005 = 5
			pragma comment "comment"
			pragma comment "comment" 1 c003 "test" __ORG__

			proc f001(!) {
				const c006 = -(6)
				A <- c001
				A <- ModA:c002
				A <- c003
				A <- ModB:c004
				A <- c005
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				f001(!)
				ModA:f002(!)
				ModB:f004(!)
				RET
			}

			align 8
			data byte [0 1 2 3 4 5 6 7]
			data byte [1 2 "string" 0xABCD]
			data word [0 1 2 3]
			data word [1 2 's' 't' 'r' 'i' 'n' 'g' 0xABCD]
			data byte [0 1 2 3] * 4

			align 8
			data byte ["long long string byte\n"]

			L0: data byte load-file("./testdata/embed01.dat")

			section bss
			data byte * 16
			data word * 16
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"
			                                            c001 = 1
			                                            ModA:c002 = 2
			                                            ; omit c003, c004
			                                            c005 = 5

			     - 0000                                 .org 0
			                                            ; comment
			                                            ; comment 1 3 "test" 0

			     - 0000                             f001:
			                                            \.c006\.#\d+ = -\(6\) ~
			000000 0000[2] 23 01                        LD     A, 0+ c001
			000002 0002[2] 23 02                        LD     A, 0+ ModA:c002
			000004 0004[2] 23 03                        LD     A, 0+ c003
			000006 0006[2] 23 04                        LD     A, 0+ ModB:c004
			000008 0008[2] 23 05                        LD     A, 0+ c005
			00000a 000a[2] 23 04                        LD     A, 0+ (3 + 2) - 1
			00000c 000c[2] 23 01                        LD     A, 0+ lobyte(1)
			00000e 000e[2] 23 05                        LD     A, 0+ ((3 + 2) - 1) + lobyte(1)
			000010 0010[3] 05 00 00                     JSR    0+ f001
			000013 0013[3] 05 86 00                     JSR    0+ ModA:f002
			000016 0016[3] 05 87 00                     JSR    0+ ModB:f004
			000019 0019[1] 04                           RET

			00001a 001a[6] ..                           .align 8 ; (.defb 6)
			000020 0020[8] 00 01 02 03 04 05 06 07      .byte 0, 1, 2, 3, 4, 5, 6, 7
			000028 0028[2] 01 02                        .byte 1, 2
			00002a 002a[6] 73 74 72 69 6e 67            .byte "string"
			000030 0030[1] cd                           .byte 43981
			000031 0031[8] 00 00 01 00 02 00 03 00      .word 0, 1, 2, 3
			000039 0039[8] 01 00 02 00 73 00 74 00      .word 1, 2, 115, 116
			000041 0041[8] 72 00 69 00 6e 00 67 00      .word 114, 105, 110, 103
			000049 0049[2] cd ab                        .word 43981
			00004b 004b[4] 00 01 02 03                  .byte 0, 1, 2, 3
			00004f 004f[4] 00 01 02 03                  ; ... repeat 2/4
			000053 0053[4] 00 01 02 03                  ; ... repeat 3/4
			000057 0057[4] 00 01 02 03                  ; ... repeat 4/4
			00005b 005b[5] ..                           .align 8 ; (.defb 5)
			000060 0060[8] 6c 6f 6e 67 20 6c 6f 6e      .byte "long long string byte\n"
			          :[8] 67 20 73 74 72 69 6e 67
			          :[6] 20 62 79 74 65 0a
			     - 0076                             L0:
			000076 0076[16] ..                          .incbin "./testdata/embed01.dat"

			     - 0086                             ModA:f002:
			000086 0086[1] 04                           RET

			     - 0087                             ModB:f004:
			000087 0087[1] 04                           RET

			     - c000                                 .org 49152
			     - c000[16] ..                          .defb 16
			     - c010[32] ..                          .defw 16
		`)[1:], list)
	})

	t.Run("ok: pack-mode", func(t *testing.T) {
		list := expectGenListOk(t, `
			link { org 0 0x4000 2; merge text ModA; org 0x4000 0 4; merge text ModB }
			module ModA { data byte [0x00 0x01] }
			module ModB { data byte [0x02 0x03] }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			000000 0000[2] 00 01                        .byte 0, 1

			     - 4000                                 .org 16384
			000002 4000[2] 02 03                        .byte 2, 3
		`)[1:], list)
	})

	t.Run("ok: trim asm operand", func(t *testing.T) {
		cc := ttarch.BuildCompiler()
		cc.TrimAsmOperand = true
		g := ttarch.NewGenerator(`flat!
			A <- 123
		`)
		g.SetCompiler(cc)
		g.GenList = true
		_, list, mes := ttarch.DoCompile(g, "-")
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			000000 0000[2] 23 7b                        LD     A, 123
		`)[1:], string(list), mes)
	})

	t.Run("ok: comment", func(t *testing.T) {
		list := expectGenListOk(t, `optimize flow; proc f001() {
			L0: $(L1) -jump
			N1: NOP
			L1: $(L2) -jump
			N2: NOP
			L2: $(L3) -jump
			L3: NOP ; PC -return
		}`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0

			     - 0000                             f001:
			     - 0000                             \.L0\.\S+: ~
			000000 0000\[3\] 01 08 00                 +JMP    0\+ \.L3\.\S+ ; // \.L1\.\S+ ~
			     - 0003                             \.N1\.\S+: ~
			000003 0003[1] 00                           NOP
			     - 0004                             \.L1\.\S+: ~
			000004 0004\[3\] 01 08 00                 +JMP    0\+ \.L3\.\S+ ; // \.L2\.\S+ ~
			     - 0007                             \.N2\.\S+: ~
			000007 0007[1] 00                           NOP
			     - 0008                             \.L2.\S+: ~
			                                            ; // #\.jump 0\+ \.L3\.\S+ ~
			     - 0008                             \.L3\.\S+: ~
			000008 0008[1] 00                           NOP
			000009 0009[1] 04                           RET
		`)[1:], string(list))
	})
}

func TestCompileCommentAndBlank(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			// comment
			/*
			 * comment
			 */

			db 1 /* comment */ 2

			db 1,
				2


			db 1 /* comment
			*/
			db (1 + /* comment
					 */ 2)
			db (1 /* comment
				   */ + /* comment
						 */ 2)
		`)
		tt.EqSlice(t, []byte{1, 2, 1, 2, 1, 3, 3}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the block comment is not terminated", `
				/* ...
			`,
			"the comma followed by blank lines is not allowed", `
				db 1,

				   2
			`,
			"the block comment must be followed by new line", `
				db 1 /* comment
				      */ 2
			`,
			"invalid comma", `
				db 1,,
			`,
			"invalid comma", `
				db 1 /*
				     */, 2
			`,
			"invalid comma", `
				db $(1 + 1
					 , + 2
			`,
			"invalid comma", `
				db $(1 + 1,, + 2
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "scan error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileArch(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			arch ttarch
			data byte * 8
		`)
		tt.Eq(t, 8, len(dat))
	})

	t.Run("ok: variant", func(t *testing.T) {
		dat := expectCompileOk(t, `
			arch ttarch +ext; arch ttarch
			data byte * 8
		`)
		tt.Eq(t, 8, len(dat))
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the current target arch is ttarch", `
				arch ttarch
				arch mos6502
			`,
			"the current target arch is ttarch", `
				arch ttarch
				arch ttarch +ext
			`,
			"the current target arch is ttarch+ext", `
				arch ttarch +ext
				arch ttarch +invalid
			`,
			"arch must be in toplevel", `flat!
				proc f(!) { arch ttarch }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileOrg(t *testing.T) {
	t.Run("ok: simple mode", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link { org 0 256 1; merge text { data byte * 64 } }
		`)
		tt.Eq(t, 64, len(dat), dat)
	})

	t.Run("ok: padding mode", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link { org 0 256 2; merge text { data byte * 64 } }
		`)
		tt.Eq(t, 256, len(dat), dat)
	})

	t.Run("ok: pack mode", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link {
				org 0 256 2; merge text { data byte * 64 }
				org 0 256 4; merge text { data byte * 64 }
			}
		`)
		tt.Eq(t, 256, len(dat), dat)
	})

	t.Run("ok: skip mode", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link { org 0 256 0; merge text { data byte * 256 } }
		`)
		tt.Eq(t, 0, len(dat), dat)
	})

	t.Run("ok: __ORG__", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link {
				org 0x4000 256 1; merge text { dw __ORG__ }
				org 0x8000 256 1; merge text { dw __ORG__ }
			}
		`)
		tt.EqSlice(t, []byte{0x00, 0x40, 0x00, 0x80}, dat)
	})

	t.Run("ok: continuation address", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link {
				org 0x4000 256 1; merge text { dw eof }
				org -1 -1 1; merge text ={ eof: }
			}
		`)
		tt.EqSlice(t, []byte{0x02, 0x40}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid org mode", `
				link { org 0 256 5 }
			`,
			"a pack mode must follow a fill/pack mode", `
				link { org 0 256 0; org 0 256 3 }
			`,
			"the orgin address required", `
				link { org 0 256 2; org -1 0 1 }
			`,
			"size limit exceeded(257/256)", `
				link { org 0 256 0; merge text { data byte * 257 } }
			`,
			"size limit exceeded(512/256)", `
				link {
					org 0 256 2; merge text { data byte * 256 }
					org 0 256 4; merge text { data byte * 256 }
				}
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileNamed(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"undefined name test", `flat!
				db test
			`,
			"undefined name test", `flat!
				module ModA { const test = 1 }
				db test
			`,
			"undefined name ModA:test", `flat!
				db ModA:test
			`,
			"undefined name ModA:test", `flat!
				module ModA { }
				db ModA:test
			`,
			"undefined name ModA:test", `flat!
				const test = 1
				module ModA { }
				db ModA:test
			`,
			"invalid placeholder", `flat!
				db (1 + %=a)
			`,
			"LD is not a namespace", `flat!
				db LD:test
			`,
			"L1 is not a namespace", `flat!
				L1: db L1:test
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileAlias(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro m001() { db 0 1 }
			alias am001 m001; am001
			proc i001(-*) { db 2 3; RET }
			alias ai001 i001; ai001(-*)
			proc l001(A => !) { RET }
			alias al001 l001; al001(A => !)
			l002:
			alias al002 l002; db al002
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3, 4, 5, 4, 0, 8}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown name unknown", `flat!
				alias a001 unknown
			`,
			"m001 is already defined", `flat!
				macro m001() { }
				alias m001 m001
			`,
			"aliases are not allowed for this type(module)", `flat!
				module m001 {}
				alias a001 m001
			`,
			"aliases are not allowed for this type(syntax)", `flat!
				alias a001 do
			`,
			"aliases are not allowed for this type(func)", `flat!
				alias a001 hibyte
			`,
			"aliases are not allowed for this type(inst)", `flat!
				alias a001 ADD
			`,
			"aliases are not allowed for this type(const)", `flat!
				const c001 = 1
				alias a001 c001
			`,
			"aliases are not allowed for this type(special)", `flat!
				alias a001 __PC__
			`,
			"aliases are not allowed for this type(invalid)", `flat!
				proc i001(-*) { alias a001 __PROC__ }
				i001(-*)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileProc(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RET }
			proc f003(!) { JMP __PROC__ }
			f001(!)
			f002(!)
			f003(!)

			proc f004(A B => A X ! B Y) { RET }
			f004(A B => A X ! B Y)
			f004(B A => X A ! Y B)

			proc f101(!) @ 0x0005
			proc f102(!) @ f001 + 3
			f101(!)
			f102(!)
		`)
		tt.True(t, len(dat) > 0)
	})

	t.Run("ok: inline", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			proc f001(-* !) { db 0 1 2; RET }
			f001(-* !)

			f002(-* !)
			proc f002(-* !) {
				g(-*); RET
				proc g(-*) { db 0 1 2; RET }
			}
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 0, 1, 2}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"ModA:p001 is not a plain name", `
				proc ModA:p001(!) {}
			`,
			"test is already defined", `
				proc test(!) {}; proc test(!) {}
			`,
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [B] ! [],\n" +
				"  given    [Y] => [A] ! [Y]", `flat!
				proc f001(X => B) { RET }
				f001(Y => A ! Y)
			`,
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [] ! [_],\n" +
				"  given    [X] => [] ! [Y]", `flat!
				proc f001(X => !) { RET }
				f001(X => ! Y)
			`,
			"unsupported instruction for ttarch", `flat!
				proc f001(!) { RET }
				CC?.f001(!)
			`,
			"LD is a builtin name", `
				proc LD(!) {}
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { A@1 }
			`,
			"the last instruction must be placed before inner procs", `flat!
				proc f001() {
					proc f002() { RET }
					RET
				}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { fallthrough }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
			"undefined proc f001", `flat!
				f001(-* !)
			`,
			"f001 is not a proc", `flat!
				data f001 = byte [0]
				f001(!)
			`,
			"f001 is not a inline proc", `flat!
				data f001 = byte [0]
				f001(-* !)
			`,
			"inline proc expansion too deep", `flat!
				proc f001(-*) { f001(-*); RET}
				f001(-*)
			`,
			"cannot use the invalid `__PROC__` within this context", `flat!
				proc f001(-* !) { JMP __PROC__ }
				f001(-* !)
			`,
			"cannot bind inline proc", `flat!
				proc f001(-* !) @ 0x0005
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileConstexpr(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			const c001 = 1
			make-counter enum001 0
			L1: db $$(1 + 2) $("ok") $$(c001) L1 __PC__ enum001 enum001
		`)
		tt.EqSlice(t, []byte{3, 'o', 'k', 1, 0, 5, 0, 1}, dat)
	})

	t.Run("ok: escape sequenses", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			db '\0' '\a' '\b' '\e' '\f' '\n' '\r' '\t' '\v' '\\' '\'' '\"' '\x10'
			db "\0\a\b\e\f\n\r\t\v\\\'\"\x10"
		`)
		tt.EqSlice(t, []byte{
			0, '\a', '\b', 0x1b, '\f', '\n', '\r', '\t', '\v', '\\', '\'', '"', '\x10',
			0, '\a', '\b', 0x1b, '\f', '\n', '\r', '\t', '\v', '\\', '\'', '"', '\x10',
		}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"undefined name f", `flat!
				db $$(f)
			`,
			"unknown operator f", `flat!
				db $$(f())
			`,
			"L1 is not callable", `flat!
				L1: db $$(L1())
			`,
			"LD is not callable", `flat!
				db $$(LD())
			`,
			"cannot use label address in compile phase", `flat!
				L1: db $$(L1)
			`,
			"cannot use __PC__ in compile phase", `flat!
				db $$(__PC__)
			`,
			"cannot use __ORG__ in compile phase", `flat!
				db $$(__ORG__)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileConst(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			const c001 = 1
			module ModA {
				const c002 = 2
			}
			module ModB {
				const c003 = 3
			}
			data byte [ c001 ModA:c002 ModB:c003 ]
			const f001(a) = a + 1
			proc p001(!) {
				const c004 = 4
				data byte [ c001 ModA:c002 ModB:c003 c004 f001(1) ]
				RET
			}
		`)
		tt.EqSlice(t, []byte{1, 2, 3, 1, 2, 3, 4, 2}, dat[:len(dat)-1])
	})

	t.Run("ok: function", func(t *testing.T) {
		dat := expectCompileOk(t, `
			const c001 = 5
			const f001(a) = a + 1
			const f002(a b) = a * b + 1
			const f003(a b:3 c: c001) = a * b + c
			data byte [ f001(1) f002(2 3) f003(2) f003(2 4) f003(2 4 6)]
		`)
		tt.EqSlice(t, []byte{2, 7, 11, 13, 14}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"ModA:c001 is not a plain name", `
				const ModA:c001 = 1
			`,
			"test is already defined", `
				const test = 1; const test = 1
			`,
			"undefined name c001", `flat!
				db $$(c001)
				const c001 = 1
			`,
			"invalid const(circular reference)", `flat!
				const c001 = c002
				const c002 = c001
				db $$(c001)
			`,
			"f001 is not callable", `flat!
				const f001 = 1
				db f001()
			`,
			"constant c001 used before declaration", `flat!
				do {
					db c001
					const c001 = 1
				}
			`,
			"label f001 used before declaration", `flat!
				do {
					db f001
					proc f001() @ 0x0005
				}
			`,
			"LD is a builtin name", `flat!
				const LD = 1
			`,
			"constant value must be constexpr", `flat!
				macro mac(a) ={ const a = %=a }
				mac EQ?
			`,
			"qualified name is not allowed in this context", `flat!
				const f001(invalid:a) = a + 1
			`,
			"f001: 1 argument(s) required, but given 0", `flat!
				const f001(a) = a + 1
				db f001()
			`,
			"f001: 1 argument(s) required, but given 2", `flat!
				const f001(a) = a + 1
				db f001(1 2)
			`,
			"f001: 1..2 argument(s) required, but given 3", `flat!
				const f001(a b: 1) = a + b
				db f001(1 2 3)
			`,
			"default value required", `flat!
				const f001(a: 1 b) = a + 1
			`,
			"undefined name b", `flat!
				const f001(a: b) = a + 1
				db f001()
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileData(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link { org 0 0 1; merge text _; merge rodata _; org 0 0 0; merge bss _ }
			section text
			data b000 = byte [] : rodata
			data w000 = word [] : rodata
			data b001 = byte [0x01]
			data b002 = byte [0x23 0x45]
			data b003 = byte ["test" $(1) $$(2 + 3)]
			data r001 = byte [0x10] : rodata
			data w001 = word [0x6789]
			data w002 = word [0xABCD 0xEF01]
			data w003 = word [0x1234 't', 'e', 's', 't']
			data b004 = byte [0 1 2 3 4 5 6 7 8] : rodata
			data b005 = byte [0 1 2 3] * 1 : rodata
			data b006 = byte [4 5 6 7] * 3 : rodata
			data w005 = word [0xa 0xb] * 1 : rodata
			data w006 = word [0xc 0xd] * 2 : rodata
			data p001 = word @ b001

			section bss
			data b100 = byte * 10
			data w100 = word * 10
		`)
		tt.EqSlice(t, []byte{
			0x01, 0x23, 0x45, 't', 'e', 's', 't', 1, 5,
			0x89, 0x67, 0xCD, 0xAB, 0x01, 0xEF,
			0x34, 0x12, 't', 0, 'e', 0, 's', 0, 't', 0,
			0x10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3,
			4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7,
			0xa, 0, 0xb, 0, 0xc, 0, 0xd, 0, 0xc, 0, 0xd, 0,
		}, dat)
	})

	t.Run("ok: struct", func(t *testing.T) {
		dat := expectCompileOk(t, `
			struct s { a byte; b word }
			data s {}
			data s {3}
			data s {3 2}
			data s {"a"}

			data s []
			data s [{}]
			data s [{3}]
			data s [{3 2}]
			data s [{3 2} {5}]
			data s [{3 2} {5 4}]

			struct t { c byte; d s }
			data t {}
			data t {8}
			data t {8 {}}
			data t {8 {3}}
			data t {8 {3 2}}

			data t []
			data t [{}]
			data t [{8}]
			data t [{8 {}}]
			data t [{8 {3}}]
			data t [{8 {3 2}}]
		`)
		tt.EqSlice(t, []byte{
			0, 0, 0,
			3, 0, 0,
			3, 2, 0,
			'a', 0, 0,

			0, 0, 0,
			3, 0, 0,
			3, 2, 0,
			3, 2, 0, 5, 0, 0,
			3, 2, 0, 5, 4, 0,

			0, 0, 0, 0,
			8, 0, 0, 0,
			8, 0, 0, 0,
			8, 3, 0, 0,
			8, 3, 2, 0,

			0, 0, 0, 0,
			8, 0, 0, 0,
			8, 0, 0, 0,
			8, 3, 0, 0,
			8, 3, 2, 0,
		}, dat)
	})

	t.Run("ok: sized", func(t *testing.T) {
		dat := expectCompileOk(t, `
			data [4]byte []
			data [4]byte [5]
			data [4]byte [5 4]
			data [4]byte [5 4 3]
			data [4]byte [5 4 3 2]

			data [4]word []
			data [4]word [5]
			data [4]word [5 4]
			data [4]word [5 4 3]
			data [4]word [5 4 3 2]

			struct s { a byte; b word }
			data [4]s []
			data [4]s [{}]
			data [4]s [{5}]
			data [4]s [{5 4}]
			data [4]s [{5 4} {3}]
			data [4]s [{5 4} {3 2}]

			data [4]byte ["a"]
			data [4]byte ["ab"]
			data [4]byte ["abc"]
			data [4]byte ["abcd"]

			data [4]byte ["a", 4, 3, 2]
			data [4]byte ["ab", 3, 2]
			data [4]byte ["abc", 2]
		`)
		tt.EqSlice(t, []byte{
			0, 0, 0, 0,
			5, 0, 0, 0,
			5, 4, 0, 0,
			5, 4, 3, 0,
			5, 4, 3, 2,

			0, 0, 0, 0, 0, 0, 0, 0,
			5, 0, 0, 0, 0, 0, 0, 0,
			5, 0, 4, 0, 0, 0, 0, 0,
			5, 0, 4, 0, 3, 0, 0, 0,
			5, 0, 4, 0, 3, 0, 2, 0,

			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0,

			'a', 0, 0, 0,
			'a', 'b', 0, 0,
			'a', 'b', 'c', 0,
			'a', 'b', 'c', 'd',

			'a', 4, 3, 2,
			'a', 'b', 3, 2,
			'a', 'b', 'c', 2,
		}, dat)
	})

	t.Run("ok: sized field", func(t *testing.T) {
		dat := expectCompileOk(t, `
			struct s { a [3]byte; b [2]word }
			data s []
			data s [{[5]}]
			data s [{[5 4]}]
			data s [{[5 4 3]}]
			data s [{[5 4 3] [2]}]
			data s [{[5 4 3] [2 1]}]
			data s [{[5] [2]}]
			data s [{[5 4] [2 1]}]

			data s [{["a"]}]
			data s [{["ab"] [2]}]
			data s [{["abc"] [2 1]}]

		`)
		tt.EqSlice(t, []byte{
			5, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 0, 0, 0, 0,
			5, 4, 3, 0, 0, 0, 0,
			5, 4, 3, 2, 0, 0, 0,
			5, 4, 3, 2, 0, 1, 0,
			5, 0, 0, 2, 0, 0, 0,
			5, 4, 0, 2, 0, 1, 0,

			'a', 0, 0, 0, 0, 0, 0,
			'a', 'b', 0, 2, 0, 0, 0,
			'a', 'b', 'c', 2, 0, 1, 0,
		}, dat)
	})

	t.Run("ok: array", func(t *testing.T) {
		dat := expectCompileOk(t, `
			data [][4]byte []
			data [][4]byte [["a"]]
			data [][4]byte [["ab"]]
			data [][4]byte [["abc"]]
			data [][4]byte [["abcd"]]
			data [][4]byte [["a"] ["a"]]
			data [][4]byte [["ab"] ["ab"]]
			data [][4]byte [["abc"] ["abc"]]
			data [][4]byte [["abcd"] ["abcd"]]

			data [2][4]byte
			data [2][4]byte []
			data [2][4]byte [[]]
			data [2][4]byte [["a"]]
		`)
		tt.EqSlice(t, []byte{
			'a', 0, 0, 0,
			'a', 'b', 0, 0,
			'a', 'b', 'c', 0,
			'a', 'b', 'c', 'd',
			'a', 0, 0, 0, 'a', 0, 0, 0,
			'a', 'b', 0, 0, 'a', 'b', 0, 0,
			'a', 'b', 'c', 0, 'a', 'b', 'c', 0,
			'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd',

			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			'a', 0, 0, 0, 0, 0, 0, 0,
		}, dat)
	})
	t.Run("ok: ds", func(t *testing.T) {
		es := []struct {
			a int
			b string
		}{
			{1, "data byte"},
			{2, "data byte * 2"},
			{1, "data [1]byte"},
			{2, "data [1]byte * 2"},
			{1, "data [1][1]byte"},
			{2, "data [1][1]byte * 2"},
			{2, "data [2]byte"},
			{4, "data [2]byte * 2"},
			{4, "data [2][2]byte"},
			{8, "data [2][2]byte * 2"},

			{2, "data word"},
			{4, "data word * 2"},
			{2, "data [1]word"},
			{4, "data [1]word * 2"},
			{2, "data [1][1]word"},
			{4, "data [1][1]word * 2"},
			{4, "data [2]word"},
			{8, "data [2]word * 2"},
			{8, "data [2][2]word"},
			{16, "data [2][2]word * 2"},

			{2, "struct s { a [2]byte }; data s"},
			{4, "struct s { a [2]byte }; data s * 2"},
			{2, "struct s { a [2]byte }; data [1]s"},
			{4, "struct s { a [2]byte }; data [1]s * 2"},
			{4, "struct s { a [2]byte }; data [2]s"},
			{8, "struct s { a [2]byte }; data [2]s * 2"},

			{2, "data struct { a [2]byte }"},
			{4, "data struct { a [2]byte } * 2"},
			{2, "data [1]struct { a [2]byte }"},
			{4, "data [1]struct { a [2]byte } * 2"},
			{4, "data [2]struct { a [2]byte }"},
			{8, "data [2]struct { a [2]byte } * 2"},
		}
		for _, i := range es {
			dat := expectCompileOk(t, i.b)
			tt.Eq(t, i.a, len(dat), i.a, i.b)
		}
	})

	t.Run("ok: generate list", func(t *testing.T) {
		list := expectGenListOk(t, `
			struct s { a byte; b word}
			data d = [4]s [{} {5} {6 7}]
			data word [s.a s.b d.a d.b]
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			     - 0000                             d:
			000000 0000[3] ..                           .defb 3
			000003 0003[1] 05                           .byte 5
			000004 0004[2] ..                           .defb 2
			000006 0006[1] 06                           .byte 6
			000007 0007[2] 07 00                        .word 7
			000009 0009[3] ..                           .defb 3
			00000c 000c[8] 00 00 01 00 00 00 01 00      .word s.a, s.b, d.a, d.b
		`)[1:], list)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid data type invalid:byte", `
				data b001 = invalid:byte
			`,
			"qualified name is not allowed in this context", `
				data b001 = byte : invalid:bss
			`,
			"ModA:b001 is not a plain name", `
				data ModA:b001 = byte
			`,
			"test is already defined", `
				data test = byte; data test = byte
			`,
			"LD is a builtin name", `
				data LD = byte
			`,
			"invalid data type qword", `flat!
				data qword
			`,
			"invalid data value", `flat!
				data b001 = byte [quote(test)]
			`,
			"invalid blob type", `flat!
				data b001 = word load-file("./testdata/embed01.dat")
			`,
			"invalid blob type", `flat!
				data b001 = [4]byte load-file("./testdata/embed01.dat")
			`,
			"repeat operator must be `*`", `flat!
				data byte / 2
			`,
			"invalid repeat count 0", `flat!
				data byte * 0
			`,
			"too many elements", `flat!
				data [2]byte [0, 1, 2]
			`,
			"the addressed data must be named", `flat!
				data byte @ 0x0005
			`,
			"the addressed data cannot contain any elements", `flat!
				data b001 = byte [1] @ 0x0005
			`,
			"strings are only allowed as byte data", `flat!
				data b001 = word ["string"]
			`,
			"the string too long", `flat!
				data b001 = [4]byte ["string"]
			`,
			"invalid data length", `flat!
				data [-1]byte [1]
			`,
			"invalid data length", `flat!
				data [0]byte [1]
			`,
			"invalid data length", `flat!
				data [-1][2]byte [1]
			`,
			"invalid data length", `flat!
				data [0][2]byte [1]
			`,
			"struct data required", `flat!
				data struct { a byte } [1]
			`,
			"too many elements in struct data", `flat!
				data struct { a byte } {1 2}
			`,
			"data list required", `flat!
				data struct { a [2]byte } {1}
			`,
			"the string too long", `flat!
				data struct { a byte } {"ab"}
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileStruct(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			link-as-tests
			struct s0 {
				z byte
			}
			struct s1 {
				a byte
				b word
				c struct { x word; y byte }
				d s0
			}
			struct s2 {
				s [4]s1
				t [4]s0
			}
			data v0 = s0 @ 1000
			data v1 = s1 @ 1000
			data v2 = s2 @ 2000

			expect 0  s0.z
			expect 0  s1.a
			expect 1  s1.b
			expect 3  s1.c
			expect 3  s1.c.x
			expect 5  s1.c.y
			expect 6  s1.d
			expect 6  s1.d.z
			expect 0  s2.s
			expect 0  s2.s.a
			expect 1  s2.s.b
			expect 3  s2.s.c
			expect 3  s2.s.c.x
			expect 5  s2.s.c.y
			expect 6  s2.s.d
			expect 6  s2.s.d.z
			expect 28 s2.t
			expect 28 s2.t.z

			expect 1000 v0
			expect 1000 v0.z
			expect 1000 v1
			expect 1000 v1.a
			expect 1001 v1.b
			expect 1003 v1.c
			expect 1003 v1.c.x
			expect 1005 v1.c.y
			expect 1006 v1.d
			expect 1006 v1.d.z

			expect 2000 v2
			expect 2000 v2.s
			expect 2000 v2.s.a
			expect 2001 v2.s.b
			expect 2003 v2.s.c
			expect 2003 v2.s.c.x
			expect 2005 v2.s.c.y
			expect 2006 v2.s.d
			expect 2006 v2.s.d.z
			expect 2028 v2.t
			expect 2028 v2.t.z
		`)
		tt.Eq(t, "ok", string(dat))
	})

	t.Run("ok: size 1", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			struct s { a [1]byte }
			struct t { b [1]s }
			struct u { a [1][1]byte }
			data s {}
			data t {}
			data u {}
		`)
		tt.Eq(t, 3, len(dat), dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"named inner struct is not allowed", `flat!
				struct s { a struct t {} }
			`,
			"the field a is already defined", `flat!
				struct s { a byte; a byte }
			`,
			"data length required", `flat!
				struct s { a []byte }
			`,
			"invalid data length", `flat!
				struct s { a [0]byte }
			`,
			"invalid data length", `flat!
				struct s { a [1][0]byte }
			`,
			"invalid data length", `flat!
				struct s { a [0][1]byte }
			`,
			"invalid data length", `flat!
				struct s { a byte }
				struct t { b [0]s }
			`,
			"only builtin types can be used as array element types", `flat!
				struct s { a byte }
				struct t { b [2][4]s }
			`,
			"element type must be constexpr", `flat!
				struct s { a [2][4][8]byte }
			`,
			"f is not a struct type", `flat!
				proc f() { RET }
				struct s { a byte }
				db f.a
			`,
			"s is not a struct type", `flat!
				struct s {}
				db s.a
			`,
			"unknown name d001", `flat!
				db d001.a
			`,
			"unknown field b", `flat!
				struct s { a byte }
				db s.b
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileInclude(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", `
			include "inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		g.AppendIncPath("./testdata/include")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: relative path", func(t *testing.T) {
		dat := expectCompileOk(t, `
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat)
	})

	t.Run("ok: twice", func(t *testing.T) {
		dat := expectCompileOk(t, `
			include "./testdata/include/inc01.oc"
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat)
	})

	t.Run("ok: self", func(t *testing.T) {
		dat := expectCompileOk(t, `
			include "./testdata/include/inc04.oc"
		`)
		tt.EqSlice(t, []byte{0x01}, dat)
	})

	t.Run("ok: in module", func(t *testing.T) {
		dat := expectCompileOk(t, `
			module ModA { include "./testdata/include/inc01.oc" }
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat)
	})

	t.Run("ok: flat!", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat)
	})

	t.Run("ok: keep original section", func(t *testing.T) {
		dat := expectCompileOk(t, `
			section text
			include "./testdata/include/inc02.oc"
			data b001 = byte [0xFA 0xFB]
		`)
		tt.EqSlice(t, []byte{0xFA, 0xFB, 0xFC}, dat)
	})

	t.Run("ok: loaded as main", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", "")
		g.CompileAndGenerate("./testdata/include/inc03.oc")
		tt.EqSlice(t, []byte{0x01}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: not loaded as main", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", `
			include "inc03.oc"
		`)
		g.AppendIncPath("./testdata/include")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0x00}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid path `/nothing.oc`", `
				include "/nothing.oc"
			`,
			"the file `nothing.oc` not found", `
				include "nothing.oc"
			`,
			"the file `./testdata/nothing.oc` not found", `
				include "./testdata/nothing.oc"
			`,
			"include must be in toplevel", `
				proc fn() { include "./testdata/include/inc01.oc"; RET }
			`,
			"undefined name ModA:Tc", `
				module ModA { include "./testdata/include/inc01.oc" }
				data b001 = byte [ModA:Tc]
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileLoadFile(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			data byte load-file("./testdata/embed01.dat")
		`)
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat)
	})

	t.Run("ok: []byte", func(t *testing.T) {
		dat := expectCompileOk(t, `
			data []byte load-file("./testdata/embed01.dat")
		`)
		tt.Eq(t, 16, len(dat), dat)
	})

	t.Run("ok: from include path", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", `
			data byte load-file("embed01.dat")
		`)
		g.AppendIncPath("./testdata")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat, mes)
	})

	t.Run("ok: const", func(t *testing.T) {
		dat := expectCompileOk(t, `
			const blob = $$(load-file("./testdata/embed01.dat"))
			data byte blob
		`)
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat)
	})

	t.Run("ok: generate list", func(t *testing.T) {
		list := expectGenListOk(t, `
			data byte load-file("./testdata/embed01.dat")
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			000000 0000[16] ..                          .incbin "./testdata/embed01.dat"
		`)[1:], list)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the file `./testdata/nothing.dat` not found", `flat!
				data byte compile-file("./testdata/nothing.dat")
			`,
			"cannot use compile-file in link phase", `flat!
				const blob = compile-file("./testdata/test.dat")
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileCompileFile(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			data byte compile-file("./testdata/test.oc")
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat)
	})

	t.Run("ok: from include path", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", `
			data byte compile-file("test.oc")
		`)
		g.AppendIncPath("./testdata")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: const", func(t *testing.T) {
		dat := expectCompileOk(t, `
			const blob = $$(compile-file("./testdata/test.oc"))
			data byte blob
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat)
	})

	t.Run("ok: include", func(t *testing.T) {
		dat := expectCompileOk(t, `
			include "./testdata/include/inc05.oc"
			data byte blob
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat)
	})

	t.Run("ok: arch 1", func(t *testing.T) {
		dat := expectCompileOk(t, `
			data byte compile-file("./testdata/include/inc06.oc")
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat)
	})

	t.Run("ok: arch 2", func(t *testing.T) {
		dat := expectCompileOk(t, `
			arch ttarch
			data byte compile-file("./testdata/include/inc06.oc")
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat)
	})

	t.Run("ok: arch 3", func(t *testing.T) {
		dat := expectCompileOk(t, `
			arch ttarch +ext
			data byte compile-file("./testdata/include/inc06.oc")
			data byte compile-file("./testdata/include/inc07.oc")
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3, 0, 1, 2, 3}, dat)
	})

	t.Run("ok: generate list", func(t *testing.T) {
		list := expectGenListOk(t, `
			data byte compile-file("./testdata/test.oc")
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			000000 0000[4] ..                           .incbin "(compiled):./testdata/test.oc"

			                                            ; ----------------
			                                            __ARCH__ = "ttarch"

			     - 0000                                 .org 0
			     - 0000[4] 00 01 02 03                  .byte 0, 1, 2, 3
		`)[1:], list)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the file `./testdata/nothing.oc` not found", `flat!
				data byte compile-file("./testdata/nothing.oc")
			`,
			"the current target arch is ttarch", `
				arch ttarch
				data byte compile-file("./testdata/include/inc07.oc")
			`,
			"cannot use compile-file in link phase", `flat!
				const blob = compile-file("./testdata/test.oc")
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileAlign(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			data b001 = byte [0xFA]
			align 8
			data b002 = byte [0xFB]
		`)
		tt.EqSlice(t, []byte{0xFA, 0, 0, 0, 0, 0, 0, 0, 0xFB}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"size must be constexpr", `flat!
				align A
			`,
			"the alignment size must be power of 2", `flat!
				align 0
			`,
			"the alignment size must be power of 2", `flat!
				align 5
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileFill(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			data byte [0xFA]
			fill 0
			data byte [0xFB]
			fill 3
			data byte [0xFC]
			fill (8 - __PC__)
			data b002 = byte [0xFD]
		`)
		tt.EqSlice(t, []byte{0xFA, 0xFB, 0, 0, 0, 0xFC, 0, 0, 0xFD}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"size must be constexpr", `flat!
				fill A
			`,
			"invalid fill size", `flat!
				fill ""
			`,
			"invalid fill size", `flat!
				fill -1
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileSection(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link {
				org 0 32 1
				merge text _
				merge rodata _
			}
			module Mod {
				section text
				db 0x00 0x01 0x02 0x03
				section rodata
				db 0xf0 0xf1 0xf2 0xf3
				section text ={ db 0x04 0x05 0x06 0x07 }
				db 0xf4 0xf5 0xf6 0xf7
				section text
				db 0x08 0x09 0x0a 0x0b
				section text ={ db 0x0c 0x0d 0x0e 0x0f }
				section rodata ={
					section text ={
						section rodata
						db 0xf8 0xf9 0xfa 0xfb
						section text
					}
					db 0xfc 0xfd 0xfe 0xff
				}
			}
		`)
		tt.EqSlice(t, []byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
			0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
		}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"body must be block-form", `
				section text 1
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileModule(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `
			link {
				org 0 8 2
				merge text _
				merge rodata _

				org 8 8 0
				merge bss _

				org 0 0 1
				merge dat _
			}
			module Mod {
				section text;   db 0xF0 0xF1 0xF2
				section rodata; db 0xF3 0xF4
				section bss;    data byte * 4
				section dat;    db 0xF5 0xF6 0xF7
			}
		`)
		tt.EqSlice(t, []byte{0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0, 0, 0,
			0xF5, 0xF6, 0xF7}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"ModA:ModA is not a plain name", `
				module ModA:ModA {}
			`,
			"test is already defined", `
				module test {}; module test {}
			`,
			"#.module must be in toplevel", `
				module ModA { module ModB {} }
			`,
			"LD is a builtin name", `
				module LD {}
			`,
			"link must be in toplevel", `
				module ModA { link {} }
			`,
			"link is already registered", `
				link {}; link {}
			`,
			"the section `invalid@ModA` is not linked", `
				module ModA { section invalid; db 1 }
			`,
			"unknown module unknown", `
				link { org 0 0 0; merge text unknown _ }
			`,
			"unknown module c001", `
				const c001 = 1
				link { org 0 0 0; merge text c001 _ }
			`,
			"invalid link form", `
				link { org 0 0 0; unknown }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileMacro(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac() { db 0 }
			mac
		`)
		tt.EqSlice(t, []byte{0}, dat)
	})

	t.Run("ok: req=1", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a) { db %=a }
			mac 1
		`)
		tt.EqSlice(t, []byte{1}, dat)
	})

	t.Run("ok: req=2", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a b) { db %=a %=b }
			mac 1 2
		`)
		tt.EqSlice(t, []byte{1, 2}, dat)
	})

	t.Run("ok: opt=1", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a: 10) { db %=a }
			mac 1
			mac
		`)
		tt.EqSlice(t, []byte{1, 10}, dat)
	})

	t.Run("ok: req=1 opt=1", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a b: 5) { db %=a %=b }
			mac 1 2
			mac 3
		`)
		tt.EqSlice(t, []byte{1, 2, 3, 5}, dat)
	})

	t.Run("ok: rest", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a ...) { db %#a (2 + %#a) %*a }
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{3, 5, 1, 2, 3}, dat)
	})

	t.Run("ok: req=1 rest", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a b ...) { db %=a %*b }
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{1, 2, 3}, dat)
	})

	t.Run("ok: req=1 opt=1 rest", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro mac(a b: 10 c ...) { db %=a %=b %*c }
			mac 1
			mac 1 2
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{1, 10, 1, 2, 1, 2, 3}, dat)
	})

	t.Run("ok: macro variable", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			L0: JMP L0
		`)
		dat := expectCompileOk(t, `flat!
			macro mac() [l] ={ %=l: JMP %=l }
			mac
		`)
		tt.EqSlice(t, expected, dat)
	})

	t.Run("ok: macro variable make-id", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			const N = "N"
			macro mac(a b c) [id = %{"X" a b c N "Z"}] { db nameof(%=id) }
			mac ABC Y "STR"
		`)
		tt.EqSlice(t, []byte("XABCYSTRNZ"), dat)
	})

	t.Run("ok: placeholder operation", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			macro m001(a ...) { db %>*a }
			macro m002(a ...) { db %>>*a }
			macro m003(a ...) { db %>>>*a }
			macro m004(a ...) { db %><a }
			macro m005(a ...) { db %>><a }
			macro m006(a ...) { db %>>><a }
			m001 _ 0 1 2
			m002 _ 0 1 2
			m003 _ 0 1 2
			m004 _ 0 1 2
			m005 _ 0 1 2
			m006 _ 0 1 2
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 1, 2, 2, 0, 1, 2}, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"ModA:m001 is not a plain name", `
				macro ModA:m001() {}
			`,
			"test is already defined", `
				macro test() {}; macro test() {}
			`,
			"invalid expansion", `flat!
				macro m001(a ...) { db %<a }
				m001
			`,
			"invalid expansion", `flat!
				macro m001(a ...) { db %>a }
				m001
			`,
			"macro expansion too deep", `flat!
				macro m001() { m001 }
				m001
			`,
			"rest parameter name required", `flat!
				macro mac(...) {}
			`,
			"qualified name is not allowed in this context", `flat!
				macro mac(invalid:a) {}
			`,
			"the rest parameter cannot have default value", `flat!
				macro mac(a: _ ...) {}
			`,
			"default value required", `flat!
				macro mac(a: _ b) {}
			`,
			"parameter a is already defined", `flat!
				macro mac(a a) {}
			`,
			"unknown placeholder %=a in macro body", `flat!
				macro mac() { %=a }
				mac
			`,
			"vector operations only allowed on the rest parameter", `flat!
				macro mac(a) { %*a }
				mac 1
			`,
			"the expression itself required. use the %& placeholder", `flat!
				macro mac(a) { db $$(use?(%=a)) }
				mac (1 + 2)
			`,
			"the placeholder only accepts constant expressions", `flat!
				macro mac(a) { db $$(use?(%=a)) }
				mac A
			`,
			"the non-constant value cannot be expanded in the constant expression", `flat!
				macro mac(a ...) { db $$(use?(%>a)) }
				mac A A A
			`,
			"the %& placeholder is only allowed within constant expressions", `flat!
				macro mac(a) { db %&a }
				mac (1 + 2)
			`,
			"cannot use the macro `mac` within this context", `flat!
				macro mac() {}
				db $$(mac)
			`,
			"mac is not callable", `flat!
				macro mac() {}
				db $$(mac())
			`,
			"qualified name is not allowed in this context", `flat!
				macro mac(a) [invalid:b] {}
				mac (1 + 2)
			`,
			"variable a is already defined", `flat!
				macro mac(a) [a] {}
			`,
			"variable a is already defined", `flat!
				macro mac() [a a] {}
			`,
			"invalid fragment", `flat!
				macro mac(a) [b = %{a}] {}
				mac (1 + 2)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})

}

func TestCompileWith(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			LD A 1
			LD A 1
			LD A B
			LD B 1
			LD A B
			LD B 1
			LD A B
		`)
		dat := expectCompileOk(t, `flat!
			@1
			A <- 1
			A <- B
			A <- B@1
			A <- B@{ B <- 1 }
		`)
		tt.EqSlice(t, expected, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"cannot use [X] as first operand for '<-'", `flat!
				[X] <- A
			`,
			"unknown operator: *", `flat!
				A * X
			`,
			"cannot use A as second operand for '-rep'", `flat!
				$(1) -rep A
			`,
			"cannot use X as operand#2 for LD", `flat!
				A <- X
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileOptimizeFlow(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		es := []string{
			`flat!; do {
			  L0: JMP L4
			  N1: NOP
			  L1: JMP L4
			  N2: NOP
			  L2: JMP L4
			  N3: NOP
			  L3: JMP L4
			  N4: NOP
			  L4: NOP ; RET
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: NOP ; PC -return
			}`,

			`flat!; do {
			  L0: JMP L2
			  N1: NOP
			  L1: JMP L2
			  N2: NOP
			  L2: JMP L4 EQ?
			  N3: NOP
			  L3: JMP L4
			  N4: NOP
			  L4: NOP ; RET
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump-if EQ?
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: NOP ; PC -return
			}`,

			`flat!; do {
			  L0: RET
			  N1: NOP
			  L1: RET
			  N2: NOP
			  L2: RET
			  N3: NOP
			  L3: RET
			  N4: NOP
			  L4: RET
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: PC -return
			}`,

			`flat!; do {
			  L0: JMP L2
			  N1: NOP
			  L1: JMP L2
			  N2: NOP
			  L2: RET EQ?
			  N3: NOP
			  L3: RET
			  N4: NOP
			  L4: RET
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump-if EQ?
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: PC -return
			}`,

			//
			`flat!; do {
			    RET
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: PC -return ; RRA
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RET EQ? ; RRA
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: PC -return-if EQ? ; RRA
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RET
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: PC -return
			    L1: PC -return
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RET EQ?
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: PC -return-if EQ?
			    L1: PC -return-if EQ?
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RET
			    RET EQ?
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: PC -return
			    L1: PC -return-if EQ?
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RET
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: PC -return-if EQ?
			    L1: PC -return
			    L9: $(0x00) -jump
			}`,

			//
			`flat!; do {
			    L0: JMP L9
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump ; RRA
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: JMP L9 EQ? ; RRA
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump-if EQ? ; RRA
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: JMP L9
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump
			    L1: $(L9) -jump
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: JMP L9 EQ?
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump-if EQ?
			    L1: $(L9) -jump-if EQ?
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: JMP L9
			    L1: JMP L9 EQ?
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump
			    L1: $(L9) -jump-if EQ?
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L1: JMP L9
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump-if EQ?
			    L1: $(L9) -jump
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(N9) -jump
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    N9: NOP
			    L9: JMP 0
			}`, `optimize flow; proc f001() {
			    L0: $(N9) -jump-if EQ?
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			//
			`flat!; do {
			  RET
			  data byte [0 1 2 3]
			  L1: RET
			}`, `optimize flow; proc f001() {
			  $(L1) -jump
			  data byte [0 1 2 3]
			  L1: PC -return
			}`,

			`flat!; do {
			  L0: JMP L2
			  N1: NOP
			  L1: JMP L2
			  N2: NOP
			  L2: JMP L3
			  N3: NOP
			  L3: NOP ; RET
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: align 2; $(L3) -jump ;
			  N3: NOP
			  L3: NOP ; RET
			}`,
		}
		for x := 0; x < len(es); x += 2 {
			expected := expectCompileOk(t, es[x])
			dat := expectCompileOk(t, es[x+1])
			tt.EqSlice(t, expected, dat, x/2, es[x+1])
		}
	})

	t.Run("warn: jump cycle", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			NOP
			L0: JMP L1 ; N0: NOP
			L1: JMP L2 ; N1: NOP
			L2: JMP L3 ; N2: NOP
			L3: JMP L1 ; N3: NOP
			L4: NOP; RET
		`)
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`flat!
			optimize flow 1
			proc f001() {
			  NOP
			  L0: $(L1) -jump ; NOP ; N0: NOP
			  L1: $(L2) -jump ; NOP ; N1: NOP
			  L2: $(L3) -jump ; NOP ; N2: NOP
			  L3: $(L1) -jump ; NOP ; N3: NOP
			  L4: NOP; RET
			}
		`))
		dat, _, mes := ttarch.DoCompile(g, "-")
		warns := slices.Sorted(slices.Values(ttarch.WarningMessages(g)))

		tt.EqSlice(t, expected, dat, mes)
		tt.EqSlice(t, []string{
			"warning: jump cycle detected: L0 -> L1",
			"warning: jump cycle detected: L1 -> L2",
			"warning: jump cycle detected: L2 -> L3",
			"warning: jump cycle detected: L3 -> L1",
		}, warns)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the patch address `a` is unreachable", `optimize flow; proc f() {
				data a = byte @ <reserved>
				$(L1) -jump
				A <- 0; *patch* a byte
				L1: PC -return
			}`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileOptimizeLink(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		es := []string{
			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			`,

			`// noopt
			  proc f001() { db 1; fallthrough }
			  proc f002() { db 2; RET }
			`, `optimize link f001
			  proc f001() { db 1; fallthrough }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			`,

			`// noopt
			  proc f001() { f002(); RET }
			  proc f002() { db 2; RET }
			`, `optimize link f001
			  proc f001() { f002(); RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			`,

			`// noopt
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  data word [f002]
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  data word [f002]
			`,

			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  data d004 = word [f002]
			`,

			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  data d002 = byte [2]
			  data d003 = byte [3]
			`,

			`// noopt
			  proc f001() { db d002; RET }
			  data d002 = byte [2]
			`, `optimize link f001
			  proc f001() { db d002; RET }
			  data d002 = byte [2]
			  data d003 = byte [3]
			`,

			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  const c = f002
			`,

			`// noopt
			  proc f001() { db c; RET }
			  proc f002() { db 2; RET }
			  const c = f002
			`, `optimize link f001
			  proc f001() { db c; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  const c = f002
			`,

			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  data p001 = byte @ <reserved>
			  proc f001() { db 1; RET }
			  proc f002() { *patch* p001; RET }
			`,

			`// noopt
			  data p001 = byte @ <reserved>
			  proc f001() { A <- [p001]; RET }
			  proc f002() { *patch* p001; RET }
			`, `optimize link f001
			  data p001 = byte @ <reserved>
			  proc f001() { A <- [p001]; RET }
			  proc f002() { *patch* p001; RET }
			`,

			`// noopt
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  assert f002
			`,

			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  link/with f002 { assert 0 }
			`,

			`// noopt
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  proc f004() { db 4; RET }
			  link/with f001 { assert f002 }
			  link/with f002 { assert f003 }
			`,

			`// noopt
			  proc f001() { db 1; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  proc f004() { db 4; RET }
			  link/with f002 f003 { assert f004 }
			`,

			`// noopt
			  proc f001() { db f003; RET }
			  proc f003() { db 3; RET }
			  proc f004() { db 4; RET }
			`, `optimize link f001
			  proc f001() { db f003; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  proc f004() { db 4; RET }
			  link/with f002 f003 { assert f004 }
			`,

			`// noopt
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  link/keep f002
			`,

			`// noopt
			  proc f001() { db 1; RET }
			  proc f003() { db 3; RET }
			  proc f004() { db 3; RET }
			`, `optimize link f001
			  proc f001() { db 1; RET }
			  proc f002() { db 2; RET }
			  proc f003() { db 3; RET }
			  proc f004() { db 3; RET }
			  link/keep f003 f004
			`,
		}
		for x := 0; x < len(es); x += 2 {
			expected := expectCompileOk(t, es[x])
			dat := expectCompileOk(t, es[x+1])
			tt.EqSlice(t, expected, dat, x/2, es[x+1])
		}
	})

	t.Run("warn: dependency", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			RET
		`)
		g := ttarch.BuildGenerator("ttarch", tt.Unindent(`
			optimize link f001
			L1: proc f001() { RET }
			link/with L1 { align 16 }
		`))
		dat, _, mes := ttarch.DoCompile(g, "-")
		warns := slices.Sorted(slices.Values(ttarch.WarningMessages(g)))

		tt.EqSlice(t, expected, dat, mes)
		tt.EqSlice(t, []string{
			"warning: the label cannot be used as a dependency",
		}, warns)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid entry point 'L1'", `flat!
			  optimize link L1
			`,
			"invalid entry point 'L1'", `flat!
			  optimize link L1
			  L1: NOP
			`,
			"invalid dependency 'L1'", `flat!
			  optimize link L1
			  link/with L1 { align 16 }
			`,
			"body must be scoped block", `flat!
			  link/with L1 ={ align 16 }
			`,
			"invalid form", `flat!
			  macro m(a) ={ link/with L1 { %=a } }
			  m 1
			`,
			"unsupported form 'section'", `flat!
			  link/with L1 { section text }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestExpandBcCode(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			BIT 0 A
			BIT 1 A
			BIT 2 A
			BIT 3 A
			BIT 4 A
			BIT 5 A
			BIT 6 A
			BIT 7 A
			BMM 1
			BMM 2
			BMM 3
			L0: ds (0x80 - 2); BRA L0
			BRA L1; ds 0x7f; L1:
			L2: ds (0x8000 - 3); BRL L2
			BRL L3; ds 0x7fff; L3:

		`)
		tt.True(t, len(dat) > 0)
	})

	t.Run("error: invalid BcImp range", func(t *testing.T) {
		lines := []string{
			`flat!; BIT -2 A`,
			`flat!; BIT -1 A`,
			`flat!; BIT 8 A`,
			`flat!; BIT 9 A`,
		}
		for _, i := range lines {
			mes := expectCompileError(t, i)
			tt.Eq(t, "compile error: the operand only accepts 0..7", mes)
		}
	})

	t.Run("error: invalid BcMap range", func(t *testing.T) {
		lines := []string{
			`flat!; BMM -1`,
			`flat!; BMM 0`,
			`flat!; BMM 4`,
			`flat!; BMM 5`,
		}
		for _, i := range lines {
			mes := expectCompileError(t, i)
			tt.Eq(t, "compile error: the operand only accepts 1..3", mes)
		}
	})

	t.Run("error: relative address out of range", func(t *testing.T) {
		lines := []string{
			`flat!; L0: ds (0x80 - 2 + 1); BRA L0`,
			`flat!; BRA L1; ds (0x7f + 1); L1:`,
			`flat!; L2: ds (0x8000 - 3 + 1); BRL L2`,
			`flat!; BRL L3; ds (0x7fff + 1); L3:`,
		}
		for _, i := range lines {
			mes := expectCompileError(t, i)
			tt.Eq(t, "compile error: the relative address is out of range", mes)
		}
	})
}

func TestGenerator(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator("ttarch", "")
		tt.Eq(t, false, g.IsChanged())
		g.Changed()
		tt.Eq(t, true, g.IsChanged())
	})

	t.Run("ok", func(t *testing.T) {
		cc := ttarch.BuildCompiler()
		g := ttarch.NewGenerator("")
		g.SetCompiler(cc)
		insts := g.Compile("-", []byte("flat!; db 1"))
		g.CheckLink(insts)
		tt.Eq(t, true, g.IsChanged())
	})
}

func TestOperandA0ToNamed(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		cc := ttarch.BuildCompiler()
		r := core.OperandA0ToNamed(cc, core.NIL, core.KwUNDER)
		tt.Eq(t, nil, r)

		a := &core.Operand{Kind: core.KwInvalidOperand}
		r = core.OperandA0ToNamed(cc, a, core.KwUNDER)
		tt.Eq(t, nil, r)

		a = &core.Operand{Kind: core.KwUNDER}
		r = core.OperandA0ToNamed(cc, a, core.KwUNDER)
		tt.Eq(t, nil, r)
	})
}

func TestSemanticCheck(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid operands for LD. some operand values may be out of range", `flat!
				LD A, 0xFFFF
			`,
			"cannot use X as operand#2 for LD", `flat!
				LD A, X
			`,
			"cannot use A as operand#3 for LD", `flat!
				LD A 1 A
			`,
			"too few operands for LD", `flat!
				LD A
			`,
			"cannot determine the size of the instruction(3 or 2)", `
				link { org 255 0 1; merge text _ }
				flat!
				L0: DNN (258 - (L1 - L0))
				L1:
			`,
			"invalid form b001(label)", `flat!
				data b001 = byte []
				b001 1
			`,
			"unknown form name unknown?", `flat!
				unknown? 1
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestExprCheck(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid form", `flat!
				macro mac(a ...) { %>*a }
				mac 1 2 3
			`,
			"invalid form", `flat!
				macro mac(a ...) { %*a }
				mac
			`,
			"flat! is not allowed in this context", `
				proc p001(!) { flat! }
			`,
			"section: 1..2 argument(s) required, but given 0", `
				section
			`,
			"section: 1..2 argument(s) required, but given 3", `
				section 1 2 3
			`,
			"apply: 1+ argument(s) required, but given 0", `
				apply
			`,
			"pragma must be identifier", `
				pragma 1
			`,
			"qualified name is not allowed in this context", `
				pragma ns:invalid
			`,
			"unknown pragma: unknown", `
				pragma unknown
			`,
			"pragma: 2..3 argument(s) required, but given 4", `
				pragma list-constants 1 2 3
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestScanError(t *testing.T) {
	es := []string{
		"invalid character '\x01'", "\x01",
		"invalid character literal", `
			db ''
		`,
		"character literal not terminated", `db 'a`,
		"character literal not terminated", `db '\'`,
		"character literal not terminated", `db '\x00`,
		"new line in character literal", `
			db 'a
		`,
		"invalid character escape", `db '\`,
		"invalid character escape", `db '\x`,
		"invalid character escape", `db '\x0`,
		"invalid character escape", `
			db '\z'
		`,
		"invalid character escape", `
			db '\xZZ'
		`,
		"invalid character literal", `
			db 'ab'
		`,
		"invalid placeholder", `
			db %=[]
		`,
		"placeholders cannot contain namespaces", `
			db %=ns:id
		`,
		"the name cannot belong to any namespace", `
			db ns:_END
		`,
		"the name cannot be use as placeholders", `
			db %=_END
		`,
		"leading whitespaces are required before the operator `.`", `
			A. {}
		`,
		"placeholders cannot contain namespaces", `
			%=ModA:a
		`,
		"no whitespace is allowed after the prefix operator", `
			~ 1
		`,
		"whitespaces required after '!='/'!=?'", `!=a`,
		"whitespaces required after '!='/'!=?'", `!=?a`,
		"no whitespace is allowed after the prefix operator", `
			~ 1
		`,
		"leading whitespaces are required before the operator `:`", `
			A <- B: X
		`,
		"string literal not terminated", `db "ab`,
		"string literal not terminated", `db "ab\"`,
		"string literal not terminated", `db "ab\x00`,
		"new line in string literal", `
			db "a
		`,
	}
	for x := 0; x < len(es); x += 2 {
		mes := expectCompileError(t, es[x+1])
		tt.Eq(t, "scan error: "+es[x], mes, es[x+1])
	}
}

func TestParseError(t *testing.T) {
	es := []string{
		`100`,
		`a; 100`,
		`$(1) + (1;`,
		`data byte !`,
		`data byte [A]`,
		`data byte [f001(!)]`,
		`data byte [EQ?]`,
		`data byte [1 !`,
		`data byte [f(!`,
		`const a =;`,
		`const a $`,
		`$(A)`,
		`$$(A)`,
		`[{}]`,
		`[1 !`,
		`A @1`,
		`A@@`,
		`mac { s;`,
		`mac ={ s;`,
		`mac (1 ! 1)`,
		`1`,
		`mac @`,
		`func.A(`,
		`func.A(!)`,
		`func(!!)`,
		`A . { db 1 !`,
		`= 1`,
		`A <- [1;`,
		`db (1 == $$(1))`,
		`macro m;`,
		`macro m(a !`,
		`macro m(a ... !`,
		`macro m(a) !`,
		`macro m(a) [i !`,
		`proc f(!`,
		`proc f(A !)`,
		`proc f(A) !`,
		`module A`,
	}
	for _, i := range es {
		mes := expectCompileError(t, i)
		tt.Prefix(t, "parse error: ", mes, i)
	}
}
