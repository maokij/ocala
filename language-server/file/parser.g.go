// GENERATED BY llpg
//lint:file-ignore U1000 generated code
//lint:file-ignore SA4004 generated code

package file

import "ocala/core"

const (
    tkEOF = iota
    tkSCANERROR
    tkSC
    tkREST
    tkEQ
    tkLS
    tkRS
    tkAT
    tkLP
    tkRP
    tkMACRO
    tkPROC
    tkCONST
    tkDATA
    tkMODULE
    tkLABEL
    tkSTRUCT
    tkLC
    tkRC
    tkBINARY_OPERATOR
    tkCL
    tkPELC
    tkIDENTIFIER
    tkSTRING
    tkMIAS
    tkEQGT
    tkEX
    tkREGISTER
    tkEQLC
    tkCONDDOT
    tkATMI
    tkPOSTFIX_OPERATOR
    tkDOT_OPERATOR
    tkCONDITION
    tkMIAT
    tkDLAT
    tkDLDLAT
    tkDTMI
    tkINTEGER
    tkRESERVED
    tkIDENTIFIERP
    tkPREFIX_OPERATOR
    tkLABEL_NAME
)

var tokenKinds = map[string]int32{
    ";": tkSC,
    "=": tkEQ,
    "[": tkLS,
    "]": tkRS,
    "@": tkAT,
    "(": tkLP,
    ")": tkRP,
    "{": tkLC,
    "}": tkRC,
    ":": tkCL,
    "%{": tkPELC,
    "-*": tkMIAS,
    "=>": tkEQGT,
    "!": tkEX,
    "={": tkEQLC,
    "@-": tkATMI,
    "-@": tkMIAT,
    "$@": tkDLAT,
    "$$@": tkDLDLAT,
    ".-": tkDTMI,
}

var tokenLabels = [...]string{
    "EOF", // tkEOF
    "SCANERROR", // tkSCANERROR
    "';'", // tkSC
    "REST", // tkREST
    "'='", // tkEQ
    "'['", // tkLS
    "']'", // tkRS
    "'@'", // tkAT
    "'('", // tkLP
    "')'", // tkRP
    "MACRO", // tkMACRO
    "PROC", // tkPROC
    "CONST", // tkCONST
    "DATA", // tkDATA
    "MODULE", // tkMODULE
    "LABEL", // tkLABEL
    "STRUCT", // tkSTRUCT
    "'{'", // tkLC
    "'}'", // tkRC
    "BINARY_OPERATOR", // tkBINARY_OPERATOR
    "':'", // tkCL
    "'%{'", // tkPELC
    "IDENTIFIER", // tkIDENTIFIER
    "STRING", // tkSTRING
    "'-*'", // tkMIAS
    "'=>'", // tkEQGT
    "'!'", // tkEX
    "REGISTER", // tkREGISTER
    "'={'", // tkEQLC
    "CONDDOT", // tkCONDDOT
    "'@-'", // tkATMI
    "POSTFIX_OPERATOR", // tkPOSTFIX_OPERATOR
    "DOT_OPERATOR", // tkDOT_OPERATOR
    "CONDITION", // tkCONDITION
    "'-@'", // tkMIAT
    "'$@'", // tkDLAT
    "'$$@'", // tkDLDLAT
    "'.-'", // tkDTMI
    "INTEGER", // tkINTEGER
    "RESERVED", // tkRESERVED
    "IDENTIFIERP", // tkIDENTIFIERP
    "PREFIX_OPERATOR", // tkPREFIX_OPERATOR
    "LABEL_NAME", // tkLABEL_NAME
}

var reservedWords = map[string]int32{
  "macro": tkMACRO,
  "proc": tkPROC,
  "const": tkCONST,
  "data": tkDATA,
  "module": tkMODULE,
  "struct": tkSTRUCT,
  "_": tkRESERVED,
  "_BEG": tkRESERVED,
  "_END": tkRESERVED,
  "_COND": tkRESERVED,
}

const (
    tpEOF = 1 << iota
    tpSCANERROR
    tpSC
    tpREST
    tpEQ
    tpLS
    tpRS
    tpAT
    tpLP
    tpRP
    tpMACRO
    tpPROC
    tpCONST
    tpDATA
    tpMODULE
    tpLABEL
    tpSTRUCT
    tpLC
    tpRC
    tpBINARY_OPERATOR
    tpCL
    tpPELC
    tpIDENTIFIER
    tpSTRING
    tpMIAS
    tpEQGT
    tpEX
    tpREGISTER
    tpEQLC
    tpCONDDOT
    tpATMI
    tpPOSTFIX_OPERATOR
    tpDOT_OPERATOR
    tpCONDITION
    tpMIAT
    tpDLAT
    tpDLDLAT
    tpDTMI
    tpINTEGER
    tpRESERVED
    tpIDENTIFIERP
    tpPREFIX_OPERATOR
    tpLABEL_NAME
)

func (p *File) _parse() core.Value {
    p.Follow(tpEOF)
    res := p._parseProgram()
    if res == SYNTAX_ERROR {
        return SYNTAX_ERROR
    }
    if (p.PeekToken().Kind != tkEOF) {
        p.Follow(tpEOF)
        p.HandleError(SYNTAX_ERROR)
        return SYNTAX_ERROR
    }
    return res
}

/** ** **
  program ->
      statement? (
        ';' statement?
      )*
 ** ** **/
func (p *File) _parseProgram() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: program -> _program_1o _program_4r
        switch p.PeekToken().Kind {
        case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkSC, tkEOF:
            // @ _program_1o _program_4r
            var _1 core.Value; _ = _1
            p.Follow(tpSC) // _program_1o @ _program_4r
            loop1:
            for {
                res := &_1; _ = res
                // RULE: _program_1o -> statement
                // RULE: _program_1o -> 
                switch p.PeekToken().Kind {
                case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                    // @ statement
                    _1 := p._parseStatement(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkEOF:
                    // NOP
                default:
                    p.ErrorUnexpected("statement, ';', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _program_1o @ _program_4r
            var _2 core.Value; _ = _2
            loop2:
            for {
                res := &_2; _ = res
                // RULE: _program_4r -> _program_3g*
                // RULE: _program_3g -> ';' _program_2o
                switch p.PeekToken().Kind {
                case tkSC:
                    // @ ';' _program_2o
                    _1 := p.ConsumeToken(); _ = _1
                    p.Recovered(); p.pending = nil

                    // ';' @ _program_2o
                    var _2 core.Value; _ = _2
                    p.Follow(tpSC) // ';' _program_2o @
                    loop3:
                    for {
                        res := &_2; _ = res
                        // RULE: _program_2o -> statement
                        // RULE: _program_2o -> 
                        switch p.PeekToken().Kind {
                        case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                            // @ statement
                            _1 := p._parseStatement(); _ = _1
                            if _1 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop3
                            }
                            *res = _1 // DEFAULT OPT ACTION
                        case tkSC, tkEOF:
                            // NOP
                        default:
                            p.ErrorUnexpected("statement, etc.")
                            *res = SYNTAX_ERROR
                        }
                        break
                    }
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }

                    continue
                case tkEOF:
                    // NOP
                default:
                    p.ErrorUnexpected("';', etc.")
                    p.Follow(tpSC) // _program_1o @ _program_4r
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                    continue
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("program, etc.")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  statement ->
      MACRO identifierp '(' (
        identifier
      | label_name data_expression
      )* REST? ')' (
        '[' (
          identifier (
            '=' symbol_expression
          )?
        )* ']'
      )? block
    | PROC identifierp '(' signature ')' (
        block
      | '@' data_expression
      )
    | CONST (
        identifier
      | identifierp '(' (
          identifier
        | label_name data_expression
        )* ')'
      ) '=' data_expression
    | DATA data_type (
        '=' data_type
      )? data_body
    | MODULE identifier block
    | LABEL label_name
    | struct
    | identifier (
        operand
      )*
    | proc_call
    | context_expression
 ** ** **/
func (p *File) _parseStatement() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: statement -> MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o block
        // RULE: statement -> PROC identifierp '(' signature ')' _statement_14g
        // RULE: statement -> CONST _statement_17g '=' data_expression
        // RULE: statement -> DATA data_type _statement_19o data_body
        // RULE: statement -> MODULE identifier block
        // RULE: statement -> LABEL label_name
        // RULE: statement -> struct
        // RULE: statement -> identifier _statement_21r
        // RULE: statement -> proc_call
        // RULE: statement -> context_expression
        switch p.PeekToken().Kind {
        case tkMACRO:
            // @ MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o block
            _1 := p.ConsumeToken(); _ = _1

            // MACRO @ identifierp '(' _statement_6r _statement_7o ')' _statement_13o block
            p.Follow(tpLP) // MACRO identifierp @ '(' _statement_6r _statement_7o ')' _statement_13o block
            _2 := p._parseIdentifierp(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }
            r := &MacroNode{}; p.HoldNode(r, _2)

            // MACRO identifierp @ '(' _statement_6r _statement_7o ')' _statement_13o block
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkLP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'('")
                p.Follow(tpRP) // MACRO identifierp '(' @ _statement_6r _statement_7o ')' _statement_13o block
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }

            // MACRO identifierp '(' @ _statement_6r _statement_7o ')' _statement_13o block
            var _4 core.Value; _ = _4
            p.Follow(tpRP) // MACRO identifierp '(' _statement_6r @ _statement_7o ')' _statement_13o block
            loop1:
            for {
                res := &_4; _ = res
                // RULE: _statement_6r -> _statement_5g*
                // RULE: _statement_5g -> identifier
                // RULE: _statement_5g -> label_name data_expression
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                    // @ identifier
                    _1 := p._parseIdentifier(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    r.AddArg(_1)

                    continue
                case tkLABEL_NAME:
                    // @ label_name data_expression
                    p.Follow(tpLP) // label_name @ data_expression
                    _1 := p._parseLabelName(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    // label_name @ data_expression
                    _2 := p._parseDataExpression(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    r.AddArg(_1)

                    continue
                case tkREST, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("identifier, label-name, REST, ')'")
                    p.Follow(tpRP) // MACRO identifierp '(' @ _statement_6r _statement_7o ')' _statement_13o block
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_4) {
                *res = SYNTAX_ERROR
                break loop
            }

            // MACRO identifierp '(' _statement_6r @ _statement_7o ')' _statement_13o block
            var _5 *core.Token; _ = _5
            p.Follow(tpRP) // MACRO identifierp '(' _statement_6r _statement_7o @ ')' _statement_13o block
            // loop2:
            for {
                res := &_5; _ = res
                // RULE: _statement_7o -> REST
                // RULE: _statement_7o -> 
                switch p.PeekToken().Kind {
                case tkREST:
                    // @ REST
                    _1 := p.ConsumeToken(); _ = _1
                    *res = _1 // DEFAULT OPT ACTION
                case tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("REST, ')'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_5) {
                *res = SYNTAX_ERROR
                break loop
            }

            // MACRO identifierp '(' _statement_6r _statement_7o @ ')' _statement_13o block
            _6 := p.PeekToken(); _ = _6
            if _6.Kind == tkRP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("')'")
                p.Follow(tpLS|tpLC|tpEQLC) // MACRO identifierp '(' _statement_6r _statement_7o ')' @ _statement_13o block
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }
            if _4 != nil { r.AddArg(_4) }

            // MACRO identifierp '(' _statement_6r _statement_7o ')' @ _statement_13o block
            var _7 core.Value; _ = _7
            p.Follow(tpLC|tpEQLC) // MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o @ block
            loop3:
            for {
                res := &_7; _ = res
                // RULE: _statement_13o -> _statement_12g?
                // RULE: _statement_12g -> '[' _statement_11r ']'
                switch p.PeekToken().Kind {
                case tkLS:
                    // @ '[' _statement_11r ']'
                    _1 := p.ConsumeToken(); _ = _1

                    // '[' @ _statement_11r ']'
                    var _2 core.Value; _ = _2
                    p.Follow(tpRS) // '[' _statement_11r @ ']'
                    loop4:
                    for {
                        res := &_2; _ = res
                        // RULE: _statement_11r -> _statement_10g*
                        // RULE: _statement_10g -> identifier _statement_9o
                        switch p.PeekToken().Kind {
                        case tkIDENTIFIER:
                            // @ identifier _statement_9o
                            p.Follow(tpEQ) // identifier @ _statement_9o
                            _1 := p._parseIdentifier(); _ = _1
                            if !p.HandleError(_1) {
                                *res = SYNTAX_ERROR
                                break loop4
                            }
                            r.AddVar(_1)

                            // identifier @ _statement_9o
                            var _2 core.Value; _ = _2
                            loop5:
                            for {
                                res := &_2; _ = res
                                // RULE: _statement_9o -> _statement_8g?
                                // RULE: _statement_8g -> '=' symbol_expression
                                switch p.PeekToken().Kind {
                                case tkEQ:
                                    // @ '=' symbol_expression
                                    _1 := p.ConsumeToken(); _ = _1

                                    // '=' @ symbol_expression
                                    _2 := p._parseSymbolExpression(); _ = _2
                                    if _2 == SYNTAX_ERROR {
                                        *res = SYNTAX_ERROR
                                        break loop5
                                    }
                                case tkIDENTIFIER, tkRS:
                                    // NOP
                                default:
                                    p.ErrorUnexpected("'=', etc.")
                                    *res = SYNTAX_ERROR
                                }
                                break
                            }
                            if _2 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop4
                            }

                            continue
                        case tkRS:
                            // NOP
                        default:
                            p.ErrorUnexpected("identifier, ']'")
                            p.Follow(tpRS) // '[' @ _statement_11r ']'
                            if !p.HandleError(SYNTAX_ERROR) {
                                *res = SYNTAX_ERROR
                                break loop4
                            }
                            continue
                        }
                        break
                    }
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }

                    // '[' _statement_11r @ ']'
                    _3 := p.PeekToken(); _ = _3
                    if _3.Kind == tkRS {
                        p.ConsumeToken()
                    } else {
                        p.ErrorUnexpected("']'")
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                case tkLC, tkEQLC:
                    // NOP
                default:
                    p.ErrorUnexpected("'[', block")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_7) {
                *res = SYNTAX_ERROR
                break loop
            }

            // MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o @ block
            _8 := p._parseBlock(); _ = _8
            if _8 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkPROC:
            // @ PROC identifierp '(' signature ')' _statement_14g
            _1 := p.ConsumeToken(); _ = _1

            // PROC @ identifierp '(' signature ')' _statement_14g
            p.Follow(tpLP) // PROC identifierp @ '(' signature ')' _statement_14g
            _2 := p._parseIdentifierp(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }
            r := &ProcNode{}; p.HoldNode(r, _2)

            // PROC identifierp @ '(' signature ')' _statement_14g
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkLP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'('")
                p.Follow(tpRP) // PROC identifierp '(' @ signature ')' _statement_14g
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }

            // PROC identifierp '(' @ signature ')' _statement_14g
            p.Follow(tpRP) // PROC identifierp '(' signature @ ')' _statement_14g
            _4 := p._parseSignature(); _ = _4
            if !p.HandleError(_4) {
                *res = SYNTAX_ERROR
                break loop
            }

            // PROC identifierp '(' signature @ ')' _statement_14g
            _5 := p.PeekToken(); _ = _5
            if _5.Kind == tkRP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("')'")
                p.Follow(tpLC|tpEQLC) // PROC identifierp '(' signature ')' @ _statement_14g
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }
            r.SetSignature(_4)

            // PROC identifierp '(' signature ')' @ _statement_14g
            var _6 core.Value; _ = _6
            loop6:
            for {
                res := &_6; _ = res
                // RULE: _statement_14g -> block
                // RULE: _statement_14g -> '@' data_expression
                switch p.PeekToken().Kind {
                case tkLC, tkEQLC:
                    // @ block
                    _1 := p._parseBlock(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop6
                    }
                case tkAT:
                    // @ '@' data_expression
                    _1 := p.ConsumeToken(); _ = _1

                    // '@' @ data_expression
                    _2 := p._parseDataExpression(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop6
                    }
                default:
                    p.ErrorUnexpected("block, '@'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _6 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkCONST:
            // @ CONST _statement_17g '=' data_expression
            _1 := p.ConsumeToken(); _ = _1

            // CONST @ _statement_17g '=' data_expression
            var _2 core.Value; _ = _2
            p.Follow(tpEQ) // CONST _statement_17g @ '=' data_expression
            loop7:
            for {
                res := &_2; _ = res
                // RULE: _statement_17g -> identifier
                // RULE: _statement_17g -> identifierp '(' _statement_16r ')'
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                    // @ identifier
                    _1 := p._parseIdentifier(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop7
                    }
                    p.AddNode(&ConstNode{}, _1)
                case tkIDENTIFIERP:
                    // @ identifierp '(' _statement_16r ')'
                    p.Follow(tpLP) // identifierp @ '(' _statement_16r ')'
                    _1 := p._parseIdentifierp(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop7
                    }

                    // identifierp @ '(' _statement_16r ')'
                    _2 := p.PeekToken(); _ = _2
                    if _2.Kind == tkLP {
                        p.ConsumeToken()
                    } else {
                        p.ErrorUnexpected("'('")
                        p.Follow(tpRP) // identifierp '(' @ _statement_16r ')'
                        if !p.HandleError(SYNTAX_ERROR) {
                            *res = SYNTAX_ERROR
                            break loop7
                        }
                    }
                    r := &ConstFnNode{}; p.AddNode(r, _1)

                    // identifierp '(' @ _statement_16r ')'
                    var _3 core.Value; _ = _3
                    p.Follow(tpRP) // identifierp '(' _statement_16r @ ')'
                    loop8:
                    for {
                        res := &_3; _ = res
                        // RULE: _statement_16r -> _statement_15g*
                        // RULE: _statement_15g -> identifier
                        // RULE: _statement_15g -> label_name data_expression
                        switch p.PeekToken().Kind {
                        case tkIDENTIFIER:
                            // @ identifier
                            _1 := p._parseIdentifier(); _ = _1
                            if _1 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop8
                            }
                            r.AddArg(_1)

                            continue
                        case tkLABEL_NAME:
                            // @ label_name data_expression
                            p.Follow(tpLP) // label_name @ data_expression
                            _1 := p._parseLabelName(); _ = _1
                            if !p.HandleError(_1) {
                                *res = SYNTAX_ERROR
                                break loop8
                            }

                            // label_name @ data_expression
                            _2 := p._parseDataExpression(); _ = _2
                            if _2 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop8
                            }
                            r.AddArg(_1)

                            continue
                        case tkRP:
                            // NOP
                        default:
                            p.ErrorUnexpected("identifier, label-name, ')'")
                            p.Follow(tpRP) // identifierp '(' @ _statement_16r ')'
                            if !p.HandleError(SYNTAX_ERROR) {
                                *res = SYNTAX_ERROR
                                break loop8
                            }
                            continue
                        }
                        break
                    }
                    if !p.HandleError(_3) {
                        *res = SYNTAX_ERROR
                        break loop7
                    }

                    // identifierp '(' _statement_16r @ ')'
                    _4 := p.PeekToken(); _ = _4
                    if _4.Kind == tkRP {
                        p.ConsumeToken()
                    } else {
                        p.ErrorUnexpected("')'")
                        *res = SYNTAX_ERROR
                        break loop7
                    }
                default:
                    p.ErrorUnexpected("identifier")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // CONST _statement_17g @ '=' data_expression
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkEQ {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'='")
                p.Follow(tpLP) // CONST _statement_17g '=' @ data_expression
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }

            // CONST _statement_17g '=' @ data_expression
            _4 := p._parseDataExpression(); _ = _4
            if _4 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkDATA:
            // @ DATA data_type _statement_19o data_body
            _1 := p.ConsumeToken(); _ = _1

            // DATA @ data_type _statement_19o data_body
            p.Follow(tpEQ|tpBINARY_OPERATOR|tpLS|tpLC|tpLP) // DATA data_type @ _statement_19o data_body
            _2 := p._parseDataType(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }
            r := &DataNode{}; t := _2

            // DATA data_type @ _statement_19o data_body
            var _3 core.Value; _ = _3
            p.Follow(tpBINARY_OPERATOR|tpLS|tpLC|tpLP) // DATA data_type _statement_19o @ data_body
            loop9:
            for {
                res := &_3; _ = res
                // RULE: _statement_19o -> _statement_18g?
                // RULE: _statement_18g -> '=' data_type
                switch p.PeekToken().Kind {
                case tkEQ:
                    // @ '=' data_type
                    _1 := p.ConsumeToken(); _ = _1

                    // '=' @ data_type
                    _2 := p._parseDataType(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop9
                    }
                    p.AddNode(r, t); t = _2
                case tkBINARY_OPERATOR, tkCL, tkAT, tkLS, tkLC, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("'=', data-body, etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_3) {
                *res = SYNTAX_ERROR
                break loop
            }
            r.Type = _expectid(t)

            // DATA data_type _statement_19o @ data_body
            _4 := p._parseDataBody(); _ = _4
            if _4 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkMODULE:
            // @ MODULE identifier block
            _1 := p.ConsumeToken(); _ = _1

            // MODULE @ identifier block
            p.Follow(tpLC|tpEQLC) // MODULE identifier @ block
            _2 := p._parseIdentifier(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }
            p.HoldNode(&ModuleNode{}, _2)

            // MODULE identifier @ block
            _3 := p._parseBlock(); _ = _3
            if _3 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkLABEL:
            // @ LABEL label_name
            _1 := p.ConsumeToken(); _ = _1

            // LABEL @ label_name
            _2 := p._parseLabelName(); _ = _2
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            p.AddNode(&LabelNode{}, _2)
        case tkSTRUCT:
            // @ struct
            _1 := p._parseStruct(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkIDENTIFIER:
            // @ identifier _statement_21r
            p.Follow(tpLC|tpEQLC|tpLS|tpLP) // identifier @ _statement_21r
            _1 := p._parseIdentifier(); _ = _1
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }
            v := _1

            // identifier @ _statement_21r
            var _2 core.Value; _ = _2
            loop10:
            for {
                res := &_2; _ = res
                // RULE: _statement_21r -> _statement_20g*
                // RULE: _statement_20g -> operand
                switch p.PeekToken().Kind {
                case tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ operand
                    p.Follow(tpLC|tpEQLC|tpLS|tpLP) // operand @
                    _1 := p._parseOperand(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop10
                    }
                    _checkinclude(p, v, _1)

                    continue
                case tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("operand, etc.")
                    p.Follow(tpLC|tpEQLC|tpLS|tpLP) // identifier @ _statement_21r
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop10
                    }
                    continue
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkCONDDOT, tkIDENTIFIERP:
            // @ proc_call
            _1 := p._parseProcCall(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
            // @ context_expression
            _1 := p._parseContextExpression(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("statement")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  struct ->
      STRUCT identifier? '{' struct_field? (
        ';' struct_field?
      )* '}'
 ** ** **/
func (p *File) _parseStruct() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: struct -> STRUCT _struct_22o '{' _struct_23o _struct_26r '}'
        switch p.PeekToken().Kind {
        case tkSTRUCT:
            // @ STRUCT _struct_22o '{' _struct_23o _struct_26r '}'
            _1 := p.ConsumeToken(); _ = _1

            // STRUCT @ _struct_22o '{' _struct_23o _struct_26r '}'
            var _2 core.Value; _ = _2
            p.Follow(tpLC) // STRUCT _struct_22o @ '{' _struct_23o _struct_26r '}'
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _struct_22o -> identifier
                // RULE: _struct_22o -> 
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                    // @ identifier
                    _1 := p._parseIdentifier(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    *res = _1 // DEFAULT OPT ACTION
                case tkLC:
                    // NOP
                default:
                    p.ErrorUnexpected("identifier, '{'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }
            name := _ensureid(_2); p.HoldNode(&StructNode{}, name)

            // STRUCT _struct_22o @ '{' _struct_23o _struct_26r '}'
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkLC {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'{'")
                p.Follow(tpSC|tpRC) // STRUCT _struct_22o '{' @ _struct_23o _struct_26r '}'
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }
            p.EnterNode(_3)

            // STRUCT _struct_22o '{' @ _struct_23o _struct_26r '}'
            var _4 core.Value; _ = _4
            p.Follow(tpSC|tpRC) // STRUCT _struct_22o '{' _struct_23o @ _struct_26r '}'
            loop2:
            for {
                res := &_4; _ = res
                // RULE: _struct_23o -> struct_field
                // RULE: _struct_23o -> 
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                    // @ struct_field
                    _1 := p._parseStructField(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                    *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("struct-field, ';', '}'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_4) {
                *res = SYNTAX_ERROR
                break loop
            }

            // STRUCT _struct_22o '{' _struct_23o @ _struct_26r '}'
            var _5 core.Value; _ = _5
            p.Follow(tpRC) // STRUCT _struct_22o '{' _struct_23o _struct_26r @ '}'
            loop3:
            for {
                res := &_5; _ = res
                // RULE: _struct_26r -> _struct_25g*
                // RULE: _struct_25g -> ';' _struct_24o
                switch p.PeekToken().Kind {
                case tkSC:
                    // @ ';' _struct_24o
                    _1 := p.ConsumeToken(); _ = _1

                    // ';' @ _struct_24o
                    var _2 core.Value; _ = _2
                    p.Follow(tpSC) // ';' _struct_24o @
                    loop4:
                    for {
                        res := &_2; _ = res
                        // RULE: _struct_24o -> struct_field
                        // RULE: _struct_24o -> 
                        switch p.PeekToken().Kind {
                        case tkIDENTIFIER:
                            // @ struct_field
                            _1 := p._parseStructField(); _ = _1
                            if _1 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop4
                            }
                            *res = _1 // DEFAULT OPT ACTION
                        case tkSC, tkRC:
                            // NOP
                        default:
                            p.ErrorUnexpected("struct-field, etc.")
                            *res = SYNTAX_ERROR
                        }
                        break
                    }
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }

                    continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("';', '}'")
                    p.Follow(tpSC|tpRC) // STRUCT _struct_22o '{' _struct_23o @ _struct_26r '}'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_5) {
                *res = SYNTAX_ERROR
                break loop
            }

            // STRUCT _struct_22o '{' _struct_23o _struct_26r @ '}'
            _6 := p.PeekToken(); _ = _6
            if _6.Kind == tkRC {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'}'")
                *res = SYNTAX_ERROR
                break loop
            }
            p.LeaveNode(); *res = name
        default:
            p.ErrorUnexpected("struct")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  struct_field ->
      identifier data_type
 ** ** **/
func (p *File) _parseStructField() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: struct_field -> identifier data_type
        switch p.PeekToken().Kind {
        case tkIDENTIFIER:
            // @ identifier data_type
            p.Follow(tpLS) // identifier @ data_type
            _1 := p._parseIdentifier(); _ = _1
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }

            // identifier @ data_type
            _2 := p._parseDataType(); _ = _2
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            r := &StructFieldNode{}; p.AddNode(r, _1); r.Type = _expectid(_2)
        default:
            p.ErrorUnexpected("struct-field")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  data_type ->
      '[' (
        constexpr
      )? ']' data_type
    | identifier
    | struct
 ** ** **/
func (p *File) _parseDataType() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: data_type -> '[' _data_type_28o ']' data_type
        // RULE: data_type -> identifier
        // RULE: data_type -> struct
        switch p.PeekToken().Kind {
        case tkLS:
            // @ '[' _data_type_28o ']' data_type
            _1 := p.ConsumeToken(); _ = _1

            // '[' @ _data_type_28o ']' data_type
            var _2 core.Value; _ = _2
            p.Follow(tpRS) // '[' _data_type_28o @ ']' data_type
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _data_type_28o -> _data_type_27g?
                // RULE: _data_type_27g -> constexpr
                switch p.PeekToken().Kind {
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ constexpr
                    _1 := p._parseConstexpr(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("constexpr, ']'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '[' _data_type_28o @ ']' data_type
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkRS {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("']'")
                p.Follow(tpLS) // '[' _data_type_28o ']' @ data_type
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }

            // '[' _data_type_28o ']' @ data_type
            _4 := p._parseDataType(); _ = _4
            if _4 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _4
        case tkIDENTIFIER:
            // @ identifier
            _1 := p._parseIdentifier(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        case tkSTRUCT:
            // @ struct
            _1 := p._parseStruct(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        default:
            p.ErrorUnexpected("data-type")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  data_body ->
      (
        data_list
      | constval
      )? (
        BINARY_OPERATOR data_value
      )? (
        ':' identifier
      | '@' data_expression
      )?
 ** ** **/
func (p *File) _parseDataBody() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: data_body -> _data_body_30o _data_body_32o _data_body_34o
        switch p.PeekToken().Kind {
        case tkLS, tkLC, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkBINARY_OPERATOR, tkCL, tkAT, tkSC, tkEOF, tkRC:
            // @ _data_body_30o _data_body_32o _data_body_34o
            var _1 core.Value; _ = _1
            p.Follow(tpBINARY_OPERATOR) // _data_body_30o @ _data_body_32o _data_body_34o
            loop1:
            for {
                res := &_1; _ = res
                // RULE: _data_body_30o -> _data_body_29g?
                // RULE: _data_body_29g -> data_list
                // RULE: _data_body_29g -> constval
                switch p.PeekToken().Kind {
                case tkLS, tkLC:
                    // @ data_list
                    _1 := p._parseDataList(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ constval
                    _1 := p._parseConstval(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkBINARY_OPERATOR, tkCL, tkAT, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("data-list, constval, BINARY-OPERATOR, ':', '@', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _data_body_30o @ _data_body_32o _data_body_34o
            var _2 core.Value; _ = _2
            loop2:
            for {
                res := &_2; _ = res
                // RULE: _data_body_32o -> _data_body_31g?
                // RULE: _data_body_31g -> BINARY_OPERATOR data_value
                switch p.PeekToken().Kind {
                case tkBINARY_OPERATOR:
                    // @ BINARY_OPERATOR data_value
                    _1 := p.ConsumeToken(); _ = _1

                    // BINARY_OPERATOR @ data_value
                    _2 := p._parseDataValue(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                case tkCL, tkAT, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("BINARY-OPERATOR, ':', '@', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }

            // _data_body_30o _data_body_32o @ _data_body_34o
            var _3 core.Value; _ = _3
            loop3:
            for {
                res := &_3; _ = res
                // RULE: _data_body_34o -> _data_body_33g?
                // RULE: _data_body_33g -> ':' identifier
                // RULE: _data_body_33g -> '@' data_expression
                switch p.PeekToken().Kind {
                case tkCL:
                    // @ ':' identifier
                    _1 := p.ConsumeToken(); _ = _1

                    // ':' @ identifier
                    _2 := p._parseIdentifier(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                case tkAT:
                    // @ '@' data_expression
                    _1 := p.ConsumeToken(); _ = _1

                    // '@' @ data_expression
                    _2 := p._parseDataExpression(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                case tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("':', '@', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _3 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("data-body, etc.")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  data_list ->
      '[' (
        data_expression
      | data_list
      )* ']'
    | '{' (
        data_expression
      | data_list
      )* '}'
 ** ** **/
func (p *File) _parseDataList() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: data_list -> '[' _data_list_36r ']'
        // RULE: data_list -> '{' _data_list_38r '}'
        switch p.PeekToken().Kind {
        case tkLS:
            // @ '[' _data_list_36r ']'
            _1 := p.ConsumeToken(); _ = _1

            // '[' @ _data_list_36r ']'
            var _2 core.Value; _ = _2
            p.Follow(tpRS) // '[' _data_list_36r @ ']'
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _data_list_36r -> _data_list_35g*
                // RULE: _data_list_35g -> data_expression
                // RULE: _data_list_35g -> data_list
                switch p.PeekToken().Kind {
                case tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ data_expression
                    p.Follow(tpLP) // data_expression @
                    _1 := p._parseDataExpression(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    continue
                case tkLS, tkLC:
                    // @ data_list
                    p.Follow(tpLS|tpLC) // data_list @
                    _1 := p._parseDataList(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    continue
                case tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("data-expression, data-list, ']'")
                    p.Follow(tpLS|tpLC|tpLP|tpRS) // '[' @ _data_list_36r ']'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '[' _data_list_36r @ ']'
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkRS {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("']'")
                *res = SYNTAX_ERROR
                break loop
            }
        case tkLC:
            // @ '{' _data_list_38r '}'
            _1 := p.ConsumeToken(); _ = _1
            p.SetContext('#')

            // '{' @ _data_list_38r '}'
            var _2 core.Value; _ = _2
            p.Follow(tpRC) // '{' _data_list_38r @ '}'
            loop2:
            for {
                res := &_2; _ = res
                // RULE: _data_list_38r -> _data_list_37g*
                // RULE: _data_list_37g -> data_expression
                // RULE: _data_list_37g -> data_list
                switch p.PeekToken().Kind {
                case tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ data_expression
                    p.Follow(tpLP) // data_expression @
                    _1 := p._parseDataExpression(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }

                    continue
                case tkLS, tkLC:
                    // @ data_list
                    p.Follow(tpLS|tpLC) // data_list @
                    _1 := p._parseDataList(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }

                    continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("data-expression, data-list, '}'")
                    p.Follow(tpLS|tpLC|tpLP|tpRC) // '{' @ _data_list_38r '}'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '{' _data_list_38r @ '}'
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkRC {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'}'")
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("data-list")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  data_expression ->
      constexpr
    | explicit_value
 ** ** **/
func (p *File) _parseDataExpression() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: data_expression -> constexpr
        // RULE: data_expression -> explicit_value
        switch p.PeekToken().Kind {
        case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ constexpr
            _1 := p._parseConstexpr(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkDLAT, tkDLDLAT:
            // @ explicit_value
            _1 := p._parseExplicitValue(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("data-expression")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  data_value ->
      constval
    | explicit_value
 ** ** **/
func (p *File) _parseDataValue() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: data_value -> constval
        // RULE: data_value -> explicit_value
        switch p.PeekToken().Kind {
        case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ constval
            _1 := p._parseConstval(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        case tkDLAT, tkDLDLAT:
            // @ explicit_value
            _1 := p._parseExplicitValue(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("data-value")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  symbol_expression ->
      '%{' symbol_expression_value (
        symbol_expression_value
      )* '}'
 ** ** **/
func (p *File) _parseSymbolExpression() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: symbol_expression -> '%{' symbol_expression_value _symbol_expression_40r '}'
        switch p.PeekToken().Kind {
        case tkPELC:
            // @ '%{' symbol_expression_value _symbol_expression_40r '}'
            _1 := p.ConsumeToken(); _ = _1

            // '%{' @ symbol_expression_value _symbol_expression_40r '}'
            p.Follow(tpRC) // '%{' symbol_expression_value @ _symbol_expression_40r '}'
            _2 := p._parseSymbolExpressionValue(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '%{' symbol_expression_value @ _symbol_expression_40r '}'
            var _3 core.Value; _ = _3
            p.Follow(tpRC) // '%{' symbol_expression_value _symbol_expression_40r @ '}'
            loop1:
            for {
                res := &_3; _ = res
                // RULE: _symbol_expression_40r -> _symbol_expression_39g*
                // RULE: _symbol_expression_39g -> symbol_expression_value
                switch p.PeekToken().Kind {
                case tkIDENTIFIER, tkSTRING:
                    // @ symbol_expression_value
                    _1 := p._parseSymbolExpressionValue(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("symbol-expression-value, '}'")
                    p.Follow(tpRC) // '%{' symbol_expression_value @ _symbol_expression_40r '}'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_3) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '%{' symbol_expression_value _symbol_expression_40r @ '}'
            _4 := p.PeekToken(); _ = _4
            if _4.Kind == tkRC {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'}'")
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("symbol-expression")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  symbol_expression_value ->
      IDENTIFIER
    | STRING
 ** ** **/
func (p *File) _parseSymbolExpressionValue() (ret core.Value) {
    // loop:
    for {
        res := &ret; _ = res
        // RULE: symbol_expression_value -> IDENTIFIER
        // RULE: symbol_expression_value -> STRING
        switch p.PeekToken().Kind {
        case tkIDENTIFIER:
            // @ IDENTIFIER
            _1 := p.ConsumeToken(); _ = _1
        case tkSTRING:
            // @ STRING
            _1 := p.ConsumeToken(); _ = _1
        default:
            p.ErrorUnexpected("symbol-expression-value")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  signature ->
      (
        '-*'
      )? registers? (
        '=>' registers?
      )? (
        '!' registers?
      )?
 ** ** **/
func (p *File) _parseSignature() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: signature -> _signature_42o _signature_43o _signature_46o _signature_49o
        var t, u, v, w core.Value
        switch p.PeekToken().Kind {
        case tkMIAS, tkREGISTER, tkEQGT, tkEX, tkRP:
            // @ _signature_42o _signature_43o _signature_46o _signature_49o
            var _1 core.Value; _ = _1
            // loop1:
            for {
                res := &_1; _ = res
                // RULE: _signature_42o -> _signature_41g?
                // RULE: _signature_41g -> '-*'
                switch p.PeekToken().Kind {
                case tkMIAS:
                    // @ '-*'
                    _1 := p.ConsumeToken(); _ = _1
                    t = core.Int(1)
                case tkREGISTER, tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("'-*', registers, '=>', '!', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }

            // _signature_42o @ _signature_43o _signature_46o _signature_49o
            var _2 core.Value; _ = _2
            loop2:
            for {
                res := &_2; _ = res
                // RULE: _signature_43o -> registers
                // RULE: _signature_43o -> 
                switch p.PeekToken().Kind {
                case tkREGISTER:
                    // @ registers
                    _1 := p._parseRegisters(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                    *res = _1 // DEFAULT OPT ACTION
                case tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("registers, '=>', '!', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            u = _2

            // _signature_42o _signature_43o @ _signature_46o _signature_49o
            var _3 core.Value; _ = _3
            loop3:
            for {
                res := &_3; _ = res
                // RULE: _signature_46o -> _signature_45g?
                // RULE: _signature_45g -> '=>' _signature_44o
                switch p.PeekToken().Kind {
                case tkEQGT:
                    // @ '=>' _signature_44o
                    _1 := p.ConsumeToken(); _ = _1

                    // '=>' @ _signature_44o
                    var _2 core.Value; _ = _2
                    loop4:
                    for {
                        res := &_2; _ = res
                        // RULE: _signature_44o -> registers
                        // RULE: _signature_44o -> 
                        switch p.PeekToken().Kind {
                        case tkREGISTER:
                            // @ registers
                            _1 := p._parseRegisters(); _ = _1
                            if _1 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop4
                            }
                            *res = _1 // DEFAULT OPT ACTION
                        case tkEX, tkRP:
                            // NOP
                        default:
                            p.ErrorUnexpected("registers, etc.")
                            *res = SYNTAX_ERROR
                        }
                        break
                    }
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                    v = _2
                case tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("'=>', '!', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _3 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }

            // _signature_42o _signature_43o _signature_46o @ _signature_49o
            var _4 core.Value; _ = _4
            loop5:
            for {
                res := &_4; _ = res
                // RULE: _signature_49o -> _signature_48g?
                // RULE: _signature_48g -> '!' _signature_47o
                switch p.PeekToken().Kind {
                case tkEX:
                    // @ '!' _signature_47o
                    _1 := p.ConsumeToken(); _ = _1

                    // '!' @ _signature_47o
                    var _2 core.Value; _ = _2
                    loop6:
                    for {
                        res := &_2; _ = res
                        // RULE: _signature_47o -> registers
                        // RULE: _signature_47o -> 
                        switch p.PeekToken().Kind {
                        case tkREGISTER:
                            // @ registers
                            _1 := p._parseRegisters(); _ = _1
                            if _1 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop6
                            }
                            *res = _1 // DEFAULT OPT ACTION
                        case tkRP:
                            // NOP
                        default:
                            p.ErrorUnexpected("registers, etc.")
                            *res = SYNTAX_ERROR
                        }
                        break
                    }
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop5
                    }
                    w = _siginvalidated(_2)
                case tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("'!', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _4 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _newsig(t, u, v, w)
        default:
            p.ErrorUnexpected("signature, etc.")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  registers ->
      REGISTER (
        REGISTER
      )*
 ** ** **/
func (p *File) _parseRegisters() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: registers -> REGISTER _registers_51r
        switch p.PeekToken().Kind {
        case tkREGISTER:
            // @ REGISTER _registers_51r
            _1 := p.ConsumeToken(); _ = _1
            v:= &core.Vec{_1.Value}

            // REGISTER @ _registers_51r
            var _2 core.Value; _ = _2
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _registers_51r -> _registers_50g*
                // RULE: _registers_50g -> REGISTER
                switch p.PeekToken().Kind {
                case tkREGISTER:
                    // @ REGISTER
                    _1 := p.ConsumeToken(); _ = _1
                    v.Push(_1.Value)

                    continue
                case tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("register, etc.")
                    *res = SYNTAX_ERROR
                    break loop1 // cannot continue
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = v
        default:
            p.ErrorUnexpected("registers")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  block ->
      (
        '{'
      | '={'
      ) statement? (
        ';' statement?
      )* '}'
 ** ** **/
func (p *File) _parseBlock() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: block -> _block_52g _block_53o _block_56r '}'
        switch p.PeekToken().Kind {
        case tkLC, tkEQLC:
            // @ _block_52g _block_53o _block_56r '}'
            var _1 core.Value; _ = _1
            p.Follow(tpLS|tpSC|tpRC) // _block_52g @ _block_53o _block_56r '}'
            // loop1:
            for {
                res := &_1; _ = res
                // RULE: _block_52g -> '{'
                // RULE: _block_52g -> '={'
                switch p.PeekToken().Kind {
                case tkLC:
                    // @ '{'
                    _1 := p.ConsumeToken(); _ = _1
                    p.EnterNode(_1)
                case tkEQLC:
                    // @ '={'
                    _1 := p.ConsumeToken(); _ = _1
                    p.EnterNode(_1)
                default:
                    p.ErrorUnexpected("'{', '={'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _block_52g @ _block_53o _block_56r '}'
            var _2 core.Value; _ = _2
            p.Follow(tpSC|tpRC) // _block_52g _block_53o @ _block_56r '}'
            loop2:
            for {
                res := &_2; _ = res
                // RULE: _block_53o -> statement
                // RULE: _block_53o -> 
                switch p.PeekToken().Kind {
                case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                    // @ statement
                    _1 := p._parseStatement(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                    *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("statement, ';', '}'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _block_52g _block_53o @ _block_56r '}'
            var _3 core.Value; _ = _3
            p.Follow(tpRC) // _block_52g _block_53o _block_56r @ '}'
            loop3:
            for {
                res := &_3; _ = res
                // RULE: _block_56r -> _block_55g*
                // RULE: _block_55g -> ';' _block_54o
                switch p.PeekToken().Kind {
                case tkSC:
                    // @ ';' _block_54o
                    _1 := p.ConsumeToken(); _ = _1
                    p.Recovered()

                    // ';' @ _block_54o
                    var _2 core.Value; _ = _2
                    p.Follow(tpSC) // ';' _block_54o @
                    loop4:
                    for {
                        res := &_2; _ = res
                        // RULE: _block_54o -> statement
                        // RULE: _block_54o -> 
                        switch p.PeekToken().Kind {
                        case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                            // @ statement
                            _1 := p._parseStatement(); _ = _1
                            if _1 == SYNTAX_ERROR {
                                *res = SYNTAX_ERROR
                                break loop4
                            }
                            *res = _1 // DEFAULT OPT ACTION
                        case tkSC, tkRC:
                            // NOP
                        default:
                            p.ErrorUnexpected("statement, etc.")
                            *res = SYNTAX_ERROR
                        }
                        break
                    }
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }

                    continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("';', '}'")
                    p.Follow(tpSC|tpRC) // _block_52g _block_53o @ _block_56r '}'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_3) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _block_52g _block_53o _block_56r @ '}'
            _4 := p.PeekToken(); _ = _4
            if _4.Kind == tkRC {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'}'")
                *res = SYNTAX_ERROR
                break loop
            }
            p.LeaveNode()
        default:
            p.ErrorUnexpected("block")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  proc_call ->
      CONDDOT? identifierp '(' signature ')'
 ** ** **/
func (p *File) _parseProcCall() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: proc_call -> _proc_call_57o identifierp '(' signature ')'
        switch p.PeekToken().Kind {
        case tkCONDDOT, tkIDENTIFIERP:
            // @ _proc_call_57o identifierp '(' signature ')'
            var _1 *core.Token; _ = _1
            // loop1:
            for {
                res := &_1; _ = res
                // RULE: _proc_call_57o -> CONDDOT
                // RULE: _proc_call_57o -> 
                switch p.PeekToken().Kind {
                case tkCONDDOT:
                    // @ CONDDOT
                    _1 := p.ConsumeToken(); _ = _1
                    *res = _1 // DEFAULT OPT ACTION
                case tkIDENTIFIERP:
                    // NOP
                default:
                    p.ErrorUnexpected("CONDDOT, identifier")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }

            // _proc_call_57o @ identifierp '(' signature ')'
            p.Follow(tpLP) // _proc_call_57o identifierp @ '(' signature ')'
            _2 := p._parseIdentifierp(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _proc_call_57o identifierp @ '(' signature ')'
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkLP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'('")
                p.Follow(tpRP) // _proc_call_57o identifierp '(' @ signature ')'
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }

            // _proc_call_57o identifierp '(' @ signature ')'
            p.Follow(tpRP) // _proc_call_57o identifierp '(' signature @ ')'
            _4 := p._parseSignature(); _ = _4
            if !p.HandleError(_4) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _proc_call_57o identifierp '(' signature @ ')'
            _5 := p.PeekToken(); _ = _5
            if _5.Kind == tkRP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("')'")
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("proc-call")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  context_expression ->
      (
        decorated_register
      | memory_access
      | explicit_value
      | '@-' primitive
      ) (
        POSTFIX_OPERATOR
      | BINARY_OPERATOR operand
      | DOT_OPERATOR dot_operand
      )*
 ** ** **/
func (p *File) _parseContextExpression() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: context_expression -> _context_expression_58g _context_expression_60r
        switch p.PeekToken().Kind {
        case tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
            // @ _context_expression_58g _context_expression_60r
            var _1 core.Value; _ = _1
            p.Follow(tpBINARY_OPERATOR|tpDOT_OPERATOR) // _context_expression_58g @ _context_expression_60r
            loop1:
            for {
                res := &_1; _ = res
                // RULE: _context_expression_58g -> decorated_register
                // RULE: _context_expression_58g -> memory_access
                // RULE: _context_expression_58g -> explicit_value
                // RULE: _context_expression_58g -> '@-' primitive
                switch p.PeekToken().Kind {
                case tkREGISTER:
                    // @ decorated_register
                    _1 := p._parseDecoratedRegister(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkLS:
                    // @ memory_access
                    _1 := p._parseMemoryAccess(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkDLAT, tkDLDLAT:
                    // @ explicit_value
                    _1 := p._parseExplicitValue(); _ = _1
                    if _1 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkATMI:
                    // @ '@-' primitive
                    _1 := p.ConsumeToken(); _ = _1

                    // '@-' @ primitive
                    _2 := p._parsePrimitive(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                default:
                    p.ErrorUnexpected("register, memory-access, explicit-value, '@-'")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }

            // _context_expression_58g @ _context_expression_60r
            var _2 core.Value; _ = _2
            loop2:
            for {
                res := &_2; _ = res
                // RULE: _context_expression_60r -> _context_expression_59g*
                // RULE: _context_expression_59g -> POSTFIX_OPERATOR
                // RULE: _context_expression_59g -> BINARY_OPERATOR operand
                // RULE: _context_expression_59g -> DOT_OPERATOR dot_operand
                switch p.PeekToken().Kind {
                case tkPOSTFIX_OPERATOR:
                    // @ POSTFIX_OPERATOR
                    _1 := p.ConsumeToken(); _ = _1

                    continue
                case tkBINARY_OPERATOR:
                    // @ BINARY_OPERATOR operand
                    _1 := p.ConsumeToken(); _ = _1

                    // BINARY_OPERATOR @ operand
                    p.Follow(tpBINARY_OPERATOR) // BINARY_OPERATOR operand @
                    _2 := p._parseOperand(); _ = _2
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }

                    continue
                case tkDOT_OPERATOR:
                    // @ DOT_OPERATOR dot_operand
                    _1 := p.ConsumeToken(); _ = _1

                    // DOT_OPERATOR @ dot_operand
                    p.Follow(tpDOT_OPERATOR) // DOT_OPERATOR dot_operand @
                    _2 := p._parseDotOperand(); _ = _2
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }

                    continue
                case tkSC, tkEOF, tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkRC, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("POSTFIX-OPERATOR, BINARY-OPERATOR, '.', etc.")
                    p.Follow(tpBINARY_OPERATOR|tpDOT_OPERATOR) // _context_expression_58g @ _context_expression_60r
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop2
                    }
                    continue
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("context-expression")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  operand ->
      primitive (
        ':' primitive
      )?
 ** ** **/
func (p *File) _parseOperand() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: operand -> primitive _operand_62o
        switch p.PeekToken().Kind {
        case tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ primitive _operand_62o
            _1 := p._parsePrimitive(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }

            // primitive @ _operand_62o
            var _2 core.Value; _ = _2
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _operand_62o -> _operand_61g?
                // RULE: _operand_61g -> ':' primitive
                switch p.PeekToken().Kind {
                case tkCL:
                    // @ ':' primitive
                    _1 := p.ConsumeToken(); _ = _1

                    // ':' @ primitive
                    _2 := p._parsePrimitive(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkPOSTFIX_OPERATOR, tkBINARY_OPERATOR, tkDOT_OPERATOR, tkSC, tkEOF, tkRC, tkATMI, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("':', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        default:
            p.ErrorUnexpected("operand")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  primitive ->
      CONDITION
    | decorated_register
    | memory_access
    | data_value
    | block
 ** ** **/
func (p *File) _parsePrimitive() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: primitive -> CONDITION
        // RULE: primitive -> decorated_register
        // RULE: primitive -> memory_access
        // RULE: primitive -> data_value
        // RULE: primitive -> block
        switch p.PeekToken().Kind {
        case tkCONDITION:
            // @ CONDITION
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        case tkREGISTER:
            // @ decorated_register
            _1 := p._parseDecoratedRegister(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        case tkLS:
            // @ memory_access
            _1 := p._parseMemoryAccess(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        case tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ data_value
            _1 := p._parseDataValue(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        case tkLC, tkEQLC:
            // @ block
            _1 := p._parseBlock(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        default:
            p.ErrorUnexpected("primitive")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  decorated_register ->
      REGISTER (
        '-@' primitive
      )?
 ** ** **/
func (p *File) _parseDecoratedRegister() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: decorated_register -> REGISTER _decorated_register_64o
        switch p.PeekToken().Kind {
        case tkREGISTER:
            // @ REGISTER _decorated_register_64o
            _1 := p.ConsumeToken(); _ = _1

            // REGISTER @ _decorated_register_64o
            var _2 core.Value; _ = _2
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _decorated_register_64o -> _decorated_register_63g?
                // RULE: _decorated_register_63g -> '-@' primitive
                switch p.PeekToken().Kind {
                case tkMIAT:
                    // @ '-@' primitive
                    _1 := p.ConsumeToken(); _ = _1

                    // '-@' @ primitive
                    _2 := p._parsePrimitive(); _ = _2
                    if _2 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkCL, tkPOSTFIX_OPERATOR, tkBINARY_OPERATOR, tkDOT_OPERATOR, tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkSC, tkEOF, tkATMI, tkRC, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("'-@', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("register")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  memory_access ->
      '[' (
        context_expression
      | constexpr
      )* ']'
 ** ** **/
func (p *File) _parseMemoryAccess() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: memory_access -> '[' _memory_access_66r ']'
        switch p.PeekToken().Kind {
        case tkLS:
            // @ '[' _memory_access_66r ']'
            _1 := p.ConsumeToken(); _ = _1

            // '[' @ _memory_access_66r ']'
            var _2 core.Value; _ = _2
            p.Follow(tpRS) // '[' _memory_access_66r @ ']'
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _memory_access_66r -> _memory_access_65g*
                // RULE: _memory_access_65g -> context_expression
                // RULE: _memory_access_65g -> constexpr
                switch p.PeekToken().Kind {
                case tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                    // @ context_expression
                    p.Follow(tpLS) // context_expression @
                    _1 := p._parseContextExpression(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    continue
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ constexpr
                    p.Follow(tpLP) // constexpr @
                    _1 := p._parseConstexpr(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    continue
                case tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("context-expression, constexpr, ']'")
                    p.Follow(tpLS|tpLP|tpRS) // '[' @ _memory_access_66r ']'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '[' _memory_access_66r @ ']'
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkRS {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("']'")
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("memory-access")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  dot_operand ->
      proc_call
    | decorated_register
    | block
 ** ** **/
func (p *File) _parseDotOperand() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: dot_operand -> proc_call
        // RULE: dot_operand -> decorated_register
        // RULE: dot_operand -> block
        switch p.PeekToken().Kind {
        case tkCONDDOT, tkIDENTIFIERP:
            // @ proc_call
            _1 := p._parseProcCall(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkREGISTER:
            // @ decorated_register
            _1 := p._parseDecoratedRegister(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkLC, tkEQLC:
            // @ block
            _1 := p._parseBlock(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("operand")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  explicit_value ->
      '$@' constval
    | '$$@' constval
 ** ** **/
func (p *File) _parseExplicitValue() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: explicit_value -> '$@' constval
        // RULE: explicit_value -> '$$@' constval
        switch p.PeekToken().Kind {
        case tkDLAT:
            // @ '$@' constval
            _1 := p.ConsumeToken(); _ = _1

            // '$@' @ constval
            _2 := p._parseConstval(); _ = _2
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkDLDLAT:
            // @ '$$@' constval
            _1 := p.ConsumeToken(); _ = _1

            // '$$@' @ constval
            _2 := p._parseConstval(); _ = _2
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("explicit-value")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  constexpr ->
      iexpr
 ** ** **/
func (p *File) _parseConstexpr() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: constexpr -> iexpr
        switch p.PeekToken().Kind {
        case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ iexpr
            _1 := p._parseIexpr(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("constexpr")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  constval ->
      ival
 ** ** **/
func (p *File) _parseConstval() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: constval -> ival
        switch p.PeekToken().Kind {
        case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ ival
            _1 := p._parseIval(); _ = _1
            if _1 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1
        default:
            p.ErrorUnexpected("constval")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  iexpr ->
      ival (
        BINARY_OPERATOR ival
      )*
 ** ** **/
func (p *File) _parseIexpr() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: iexpr -> ival _iexpr_68r
        switch p.PeekToken().Kind {
        case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
            // @ ival _iexpr_68r
            p.Follow(tpBINARY_OPERATOR) // ival @ _iexpr_68r
            _1 := p._parseIval(); _ = _1
            if !p.HandleError(_1) {
                *res = SYNTAX_ERROR
                break loop
            }

            // ival @ _iexpr_68r
            var _2 core.Value; _ = _2
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _iexpr_68r -> _iexpr_67g*
                // RULE: _iexpr_67g -> BINARY_OPERATOR ival
                switch p.PeekToken().Kind {
                case tkBINARY_OPERATOR:
                    // @ BINARY_OPERATOR ival
                    _1 := p.ConsumeToken(); _ = _1

                    // BINARY_OPERATOR @ ival
                    p.Follow(tpBINARY_OPERATOR) // BINARY_OPERATOR ival @
                    _2 := p._parseIval(); _ = _2
                    if !p.HandleError(_2) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    continue
                case tkRP, tkIDENTIFIER, tkLABEL_NAME, tkSC, tkEOF, tkLS, tkLC, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkATMI, tkREGISTER, tkRS, tkREST, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected("BINARY-OPERATOR, etc.")
                    p.Follow(tpBINARY_OPERATOR) // ival @ _iexpr_68r
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                    continue
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("constexpr")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  ival ->
      INTEGER
    | STRING
    | RESERVED
    | IDENTIFIER (
        '.-' IDENTIFIER (
          '.-' IDENTIFIER
        )*
      )?
    | IDENTIFIERP '(' (
        iexpr
      )* ')'
    | '(' iexpr ')'
    | PREFIX_OPERATOR ival
 ** ** **/
func (p *File) _parseIval() (ret core.Value) {
    loop:
    for {
        res := &ret; _ = res
        // RULE: ival -> INTEGER
        // RULE: ival -> STRING
        // RULE: ival -> RESERVED
        // RULE: ival -> IDENTIFIER _ival_72o
        // RULE: ival -> IDENTIFIERP '(' _ival_74r ')'
        // RULE: ival -> '(' iexpr ')'
        // RULE: ival -> PREFIX_OPERATOR ival
        switch p.PeekToken().Kind {
        case tkINTEGER:
            // @ INTEGER
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        case tkSTRING:
            // @ STRING
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        case tkRESERVED:
            // @ RESERVED
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        case tkIDENTIFIER:
            // @ IDENTIFIER _ival_72o
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value

            // IDENTIFIER @ _ival_72o
            var _2 core.Value; _ = _2
            loop1:
            for {
                res := &_2; _ = res
                // RULE: _ival_72o -> _ival_71g?
                // RULE: _ival_71g -> '.-' IDENTIFIER _ival_70r
                switch p.PeekToken().Kind {
                case tkDTMI:
                    // @ '.-' IDENTIFIER _ival_70r
                    _1 := p.ConsumeToken(); _ = _1

                    // '.-' @ IDENTIFIER _ival_70r
                    _2 := p.PeekToken(); _ = _2
                    if _2.Kind == tkIDENTIFIER {
                        p.ConsumeToken()
                    } else {
                        p.ErrorUnexpected("identifier")
                        *res = SYNTAX_ERROR
                        break loop1
                    }

                    // '.-' IDENTIFIER @ _ival_70r
                    var _3 core.Value; _ = _3
                    loop2:
                    for {
                        res := &_3; _ = res
                        // RULE: _ival_70r -> _ival_69g*
                        // RULE: _ival_69g -> '.-' IDENTIFIER
                        switch p.PeekToken().Kind {
                        case tkDTMI:
                            // @ '.-' IDENTIFIER
                            _1 := p.ConsumeToken(); _ = _1

                            // '.-' @ IDENTIFIER
                            _2 := p.PeekToken(); _ = _2
                            if _2.Kind == tkIDENTIFIER {
                                p.ConsumeToken()
                            } else {
                                p.ErrorUnexpected("identifier")
                                *res = SYNTAX_ERROR
                                break loop2
                            }

                            continue
                        case tkBINARY_OPERATOR, tkCL, tkIDENTIFIER, tkLABEL_NAME, tkSC, tkEOF, tkLS, tkLC, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkPOSTFIX_OPERATOR, tkDOT_OPERATOR, tkRP, tkATMI, tkREGISTER, tkAT, tkCONDITION, tkEQLC, tkREST, tkRC, tkRS:
                            // NOP
                        default:
                            p.ErrorUnexpected("'.-', etc.")
                            *res = SYNTAX_ERROR
                            break loop2 // cannot continue
                        }
                        break
                    }
                    if _3 == SYNTAX_ERROR {
                        *res = SYNTAX_ERROR
                        break loop1
                    }
                case tkBINARY_OPERATOR, tkCL, tkIDENTIFIER, tkLABEL_NAME, tkSC, tkEOF, tkLS, tkLC, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkPOSTFIX_OPERATOR, tkDOT_OPERATOR, tkRP, tkATMI, tkREGISTER, tkAT, tkCONDITION, tkEQLC, tkREST, tkRC, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected("'.-', etc.")
                    *res = SYNTAX_ERROR
                }
                break
            }
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        case tkIDENTIFIERP:
            // @ IDENTIFIERP '(' _ival_74r ')'
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value

            // IDENTIFIERP @ '(' _ival_74r ')'
            _2 := p.PeekToken(); _ = _2
            if _2.Kind == tkLP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("'('")
                p.Follow(tpLP|tpRP) // IDENTIFIERP '(' @ _ival_74r ')'
                if !p.HandleError(SYNTAX_ERROR) {
                    *res = SYNTAX_ERROR
                    break loop
                }
            }

            // IDENTIFIERP '(' @ _ival_74r ')'
            var _3 core.Value; _ = _3
            p.Follow(tpRP) // IDENTIFIERP '(' _ival_74r @ ')'
            loop3:
            for {
                res := &_3; _ = res
                // RULE: _ival_74r -> _ival_73g*
                // RULE: _ival_73g -> iexpr
                switch p.PeekToken().Kind {
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                    // @ iexpr
                    p.Follow(tpLP) // iexpr @
                    _1 := p._parseIexpr(); _ = _1
                    if !p.HandleError(_1) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }

                    continue
                case tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected("constexpr, ')'")
                    p.Follow(tpLP|tpRP) // IDENTIFIERP '(' @ _ival_74r ')'
                    if !p.HandleError(SYNTAX_ERROR) {
                        *res = SYNTAX_ERROR
                        break loop3
                    }
                    continue
                }
                break
            }
            if !p.HandleError(_3) {
                *res = SYNTAX_ERROR
                break loop
            }

            // IDENTIFIERP '(' _ival_74r @ ')'
            _4 := p.PeekToken(); _ = _4
            if _4.Kind == tkRP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("')'")
                *res = SYNTAX_ERROR
                break loop
            }
        case tkLP:
            // @ '(' iexpr ')'
            _1 := p.ConsumeToken(); _ = _1

            // '(' @ iexpr ')'
            p.Follow(tpRP) // '(' iexpr @ ')'
            _2 := p._parseIexpr(); _ = _2
            if !p.HandleError(_2) {
                *res = SYNTAX_ERROR
                break loop
            }

            // '(' iexpr @ ')'
            _3 := p.PeekToken(); _ = _3
            if _3.Kind == tkRP {
                p.ConsumeToken()
            } else {
                p.ErrorUnexpected("')'")
                *res = SYNTAX_ERROR
                break loop
            }
            *res = _1.Value
        case tkPREFIX_OPERATOR:
            // @ PREFIX_OPERATOR ival
            _1 := p.ConsumeToken(); _ = _1

            // PREFIX_OPERATOR @ ival
            _2 := p._parseIval(); _ = _2
            if _2 == SYNTAX_ERROR {
                *res = SYNTAX_ERROR
                break loop
            }
        default:
            p.ErrorUnexpected("constval")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  identifier ->
      IDENTIFIER
 ** ** **/
func (p *File) _parseIdentifier() (ret core.Value) {
    // loop:
    for {
        res := &ret; _ = res
        // RULE: identifier -> IDENTIFIER
        switch p.PeekToken().Kind {
        case tkIDENTIFIER:
            // @ IDENTIFIER
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        default:
            p.ErrorUnexpected("identifier")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  identifierp ->
      IDENTIFIERP
 ** ** **/
func (p *File) _parseIdentifierp() (ret core.Value) {
    // loop:
    for {
        res := &ret; _ = res
        // RULE: identifierp -> IDENTIFIERP
        switch p.PeekToken().Kind {
        case tkIDENTIFIERP:
            // @ IDENTIFIERP
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        default:
            p.ErrorUnexpected("identifier")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}

/** ** **
  label_name ->
      LABEL_NAME
 ** ** **/
func (p *File) _parseLabelName() (ret core.Value) {
    // loop:
    for {
        res := &ret; _ = res
        // RULE: label_name -> LABEL_NAME
        switch p.PeekToken().Kind {
        case tkLABEL_NAME:
            // @ LABEL_NAME
            _1 := p.ConsumeToken(); _ = _1
            *res = _1.Value
        default:
            p.ErrorUnexpected("label-name")
            *res = SYNTAX_ERROR
        }
        break
    }
    return
}
