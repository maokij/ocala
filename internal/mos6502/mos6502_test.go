package mos6502

import (
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"testing"
)

func compile(src string) ([]byte, string) {
	return ttarch.Compile(BuildCompiler(), src)
}

func genlist(src string) (string, string) {
	return ttarch.GenList(BuildCompiler(), src)
}

func TestCompileTestFiles(t *testing.T) {
	tab := []string{
		"./testdata/opcodes",
		"./testdata/operators",
	}
	for _, i := range tab {
		a, b, mes := ttarch.CompileTestFile(BuildCompiler(), i)
		tt.EqSlice(t, a, b, mes)
	}
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list, mes := genlist(`
			section text
			proc f001(!) {
				A <- 1
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				A << 1
				RTS
			}
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0

			     - 0000                             f001:
			000000 0000[2] a9 01                        LDA    #1
			000002 0002[2] a9 04                        LDA    #(3 + 2) - 1
			000004 0004[2] a9 01                        LDA    #lobyte(1)
			000006 0006[2] a9 05                        LDA    #((3 + 2) - 1) + lobyte(1)
			000008 0008[1] 0a                           ASL    A
			000009 0009[1] 60                           RTS
		`)[1:]+"\n\n", list, mes)
	})
}

func TestCompileCall(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { RTS }
			proc f002(!) { JMP [f001] }
			proc f003(-* !) { A <- X; RTS }
			f001(!)
			f002(!)
			f003(-* !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: sig", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(X => Y) { RTS }
			proc f002(Y => !) { RTS }
			proc f003(Y => X !) { RTS }
			f001(X => Y)
			f002(Y => !)
			f003(Y => X !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: fallthrough", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RTS }
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [X] ! [],\n" +
				"  given    [Y] => [Y] ! []", `flat!
				proc f001(X => X) { RTS }
				f001(Y => Y)
			`,
			"conditional call is not supported", `flat!
				proc f001(!) { RTS }
				CC?.f001(!)
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { @1 }
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { @1 }
				f001(-* !)
			`,
			"unsupported instruction in inline code", `flat!
				proc f001(-* !) { RTI }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileJump(t *testing.T) {
	dat, mes := compile(`flat!
		loop { NOP }
	`)
	tt.True(t, len(dat) > 0, mes)
}

func TestCompileError(t *testing.T) {
	es := []string{
		"cannot use invalid-operand as operand#1 for LDA", `flat!
			A <- [1 2 3]
		`,
		"cannot use out-of-range as operand#1 for ORA", `flat!
			A | [[1024 X]]
		`,
		"cannot use out-of-range as operand#1 for ORA", `flat!
			A | [[1024] Y]
		`,
	}
	for x := 0; x < len(es); x += 2 {
		_, mes := compile(es[x+1])
		tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
	}
}
