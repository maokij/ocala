package mos6502

import (
	"ocala/internal/core"
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"testing"
)

func compile(src string) ([]byte, string) {
	return ttarch.Compile(BuildCompiler(), src)
}

func genlist(src string) (string, string) {
	return ttarch.GenList(BuildCompiler(), src)
}

func TestCompileTestFiles(t *testing.T) {
	tab := []string{
		"./testdata/opcodes",
		"./testdata/operators",
	}
	for _, i := range tab {
		a, b, mes := ttarch.CompileTestFile(BuildCompiler(), i)
		tt.EqSlice(t, a, b, mes, i)
	}
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list, mes := genlist(`
			section text
			proc f001(!) {
				A <- 1
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				A << 1
				RTS
			}
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0

			     - 0000                             f001:
			000000 0000[2] a9 01                        LDA    #1
			000002 0002[2] a9 04                        LDA    #(3 + 2) - 1
			000004 0004[2] a9 01                        LDA    #lobyte(1)
			000006 0006[2] a9 05                        LDA    #((3 + 2) - 1) + lobyte(1)
			000008 0008[1] 0a                           ASL    A
			000009 0009[1] 60                           RTS
		`)[1:]+"\n\n", list, mes)
	})

	t.Run("ok: optimize 0", func(t *testing.T) {
		list, mes := genlist(`flat!
			optimize near-jump 0
			L0: $(L0) -jump-if EQ?; $(L1) -jump-if NE?
			L1: $(L0) -jump
			fn()
			proc fn() { RTS }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[5] d0 03 4c 00 00               #.jump #L0, EQ
			000005 0005[5] f0 03 4c 0a 00               #.jump #L1, NE
			     - 000a                             L1:
			00000a 000a[3] 4c 00 00                     JMP    L0
			00000d 000d[3] 20 10 00                     JSR    fn

			     - 0010                             fn:
			000010 0010[1] 60                           RTS
		`)[1:]+"\n\n", list, mes)
	})

	t.Run("ok: optimize 1", func(t *testing.T) {
		list, mes := genlist(`flat!
			optimize near-jump 1
			L0: $(L0) -jump-if EQ?; $(L1) -jump-if NE?
			L1: $(L0) -jump
			fn()
			proc fn() { RTS }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[2] f0 fe                        BEQ    L0
			000002 0002[2] d0 00                        BNE    L1
			     - 0004                             L1:
			000004 0004[3] 4c 00 00                     JMP    L0
			000007 0007[3] 20 0a 00                     JSR    fn

			     - 000a                             fn:
			00000a 000a[1] 60                           RTS
		`)[1:]+"\n\n", list, mes)
	})
}

func TestAdjustOperand(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		id := &core.Identifier{}
		cc := BuildCompiler()
		data := []struct {
			n        int
			from, to *core.Keyword
		}{
			{255, kwImmN, kwImmN},
			{256, kwImmN, kwImmNN},
			{255, kwMemZN, kwMemZN},
			{256, kwMemZN, kwMemAN},
			{255, kwMemZX, kwMemZX},
			{256, kwMemZX, kwMemAX},
			{255, kwMemZY, kwMemZY},
			{256, kwMemZY, kwMemAY},
		}
		for x, i := range data {
			a := &core.Operand{Kind: i.from}
			cc.AdjustOperand(cc, a, i.n, id)
			tt.Eq(t, i.to, a.Kind, x)
		}
	})
}

func TestCompileCall(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { RTS }
			proc f002(!) { JMP [f001] }
			proc f003(-* !) { A <- X; RTS }
			f001(!)
			f002(!)
			f003(-* !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: sig", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(X => Y) { RTS }
			proc f002(Y => !) { RTS }
			proc f003(Y => X !) { RTS }
			f001(X => Y)
			f002(Y => !)
			f003(Y => X !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: fallthrough", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RTS }
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [X] ! [],\n" +
				"  given    [Y] => [Y] ! []", `flat!
				proc f001(X => X) { RTS }
				f001(Y => Y)
			`,
			"unsupported operand(#2)", `flat!
				proc f001(!) { RTS }
				CC?.f001(!)
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { @1 }
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { @1 }
				f001(-* !)
			`,
			"unsupported instruction in inline code", `flat!
				proc f001(-* !) { RTI }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileJump(t *testing.T) {
	dat, mes := compile(`flat!
		loop { NOP }
	`)
	tt.True(t, len(dat) > 0, mes)
}

func TestCompileOptimize(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			optimize near-jump 1
			L0: expand-loop 65 { $(L0) -jump-if CC? }
			expand-loop 65 { $(L1) -jump-if CS? }; L1:
		`)
		tt.EqSlice(t, []byte{
			0x90, 0xfe, 0x90, 0xfc, 0x90, 0xfa, 0x90, 0xf8, 0x90, 0xf6, 0x90, 0xf4, 0x90, 0xf2, 0x90, 0xf0,
			0x90, 0xee, 0x90, 0xec, 0x90, 0xea, 0x90, 0xe8, 0x90, 0xe6, 0x90, 0xe4, 0x90, 0xe2, 0x90, 0xe0,
			0x90, 0xde, 0x90, 0xdc, 0x90, 0xda, 0x90, 0xd8, 0x90, 0xd6, 0x90, 0xd4, 0x90, 0xd2, 0x90, 0xd0,
			0x90, 0xce, 0x90, 0xcc, 0x90, 0xca, 0x90, 0xc8, 0x90, 0xc6, 0x90, 0xc4, 0x90, 0xc2, 0x90, 0xc0,
			0x90, 0xbe, 0x90, 0xbc, 0x90, 0xba, 0x90, 0xb8, 0x90, 0xb6, 0x90, 0xb4, 0x90, 0xb2, 0x90, 0xb0,
			0x90, 0xae, 0x90, 0xac, 0x90, 0xaa, 0x90, 0xa8, 0x90, 0xa6, 0x90, 0xa4, 0x90, 0xa2, 0x90, 0xa0,
			0x90, 0x9e, 0x90, 0x9c, 0x90, 0x9a, 0x90, 0x98, 0x90, 0x96, 0x90, 0x94, 0x90, 0x92, 0x90, 0x90,
			0x90, 0x8e, 0x90, 0x8c, 0x90, 0x8a, 0x90, 0x88, 0x90, 0x86, 0x90, 0x84, 0x90, 0x82, 0x90, 0x80,
			0xb0, 0x03, 0x4c, 0x00, 0x00, 0x90, 0x03, 0x4c, 0x0a, 0x01,
			0xb0, 0x7e, 0xb0, 0x7c, 0xb0, 0x7a, 0xb0, 0x78, 0xb0, 0x76, 0xb0, 0x74, 0xb0, 0x72, 0xb0, 0x70,
			0xb0, 0x6e, 0xb0, 0x6c, 0xb0, 0x6a, 0xb0, 0x68, 0xb0, 0x66, 0xb0, 0x64, 0xb0, 0x62, 0xb0, 0x60,
			0xb0, 0x5e, 0xb0, 0x5c, 0xb0, 0x5a, 0xb0, 0x58, 0xb0, 0x56, 0xb0, 0x54, 0xb0, 0x52, 0xb0, 0x50,
			0xb0, 0x4e, 0xb0, 0x4c, 0xb0, 0x4a, 0xb0, 0x48, 0xb0, 0x46, 0xb0, 0x44, 0xb0, 0x42, 0xb0, 0x40,
			0xb0, 0x3e, 0xb0, 0x3c, 0xb0, 0x3a, 0xb0, 0x38, 0xb0, 0x36, 0xb0, 0x34, 0xb0, 0x32, 0xb0, 0x30,
			0xb0, 0x2e, 0xb0, 0x2c, 0xb0, 0x2a, 0xb0, 0x28, 0xb0, 0x26, 0xb0, 0x24, 0xb0, 0x22, 0xb0, 0x20,
			0xb0, 0x1e, 0xb0, 0x1c, 0xb0, 0x1a, 0xb0, 0x18, 0xb0, 0x16, 0xb0, 0x14, 0xb0, 0x12, 0xb0, 0x10,
			0xb0, 0x0e, 0xb0, 0x0c, 0xb0, 0x0a, 0xb0, 0x08, 0xb0, 0x06, 0xb0, 0x04, 0xb0, 0x02, 0xb0, 0x00,
		}, dat, mes, len(dat))
	})

	t.Run("ok: JMP", func(t *testing.T) {
		dat, mes := compile(`flat!
			optimize near-jump 1
			L0: JMP [L0]; NOP
		`)
		tt.EqSlice(t, []byte{0x4c, 0x00, 0x00, 0xea}, dat, mes)
	})

	t.Run("ok: optimize 0", func(t *testing.T) {
		s, _ := compile(`flat!
			L0: BNE S0; JMP [L0]; S0: BEQ S1; JMP [L1]; S1:
			L1: JMP [L0]
		`)
		dat, mes := compile(`flat!
			optimize near-jump 0
			L0: $(L0) -jump-if EQ?; $(L1) -jump-if NE?
			L1: $(L0) -jump
		`)
		tt.EqSlice(t, s, dat, mes, s, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown optimizer: unknown", `flat!
				optimize unknown
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileError(t *testing.T) {
	es := []string{
		"cannot use invalid-operand as operand#1 for LDA", `flat!
			A <- [1 2 3]
		`,
		"cannot use out-of-range as operand#1 for ORA", `flat!
			A | [[1024 X]]
		`,
		"cannot use out-of-range as operand#1 for ORA", `flat!
			A | [[1024] Y]
		`,
	}
	for x := 0; x < len(es); x += 2 {
		_, mes := compile(es[x+1])
		tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
	}
}
