package mos6502_test

import (
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"slices"
	"testing"
)

func expectCompileOk(t *testing.T, src string) []byte {
	t.Helper()
	return ttarch.ExpectCompileOk(t, "mos6502", src)
}

func expectCompileError(t *testing.T, src string) string {
	t.Helper()
	return ttarch.ExpectCompileError(t, "mos6502", src)
}

func expectGenListOk(t *testing.T, src string) string {
	t.Helper()
	return ttarch.ExpectGenListOk(t, "mos6502", src)
}

func TestCompileTestFiles(t *testing.T) {
	tab := []string{
		"./testdata/opcodes",
		"./testdata/operators",
	}
	for _, i := range tab {
		a, b, mes := ttarch.CompileTestFile("mos6502", i)
		tt.EqSlice(t, a, b, mes, i)
	}
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list := expectGenListOk(t, `
			section text
			proc f001(!) {
				A <- 1
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				A << 1
				PC -return
			}
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "mos6502"

			     - 0000                                 .org 0

			     - 0000                             f001:
			000000 0000[2] a9 01                        LDA    #1
			000002 0002[2] a9 04                        LDA    #(3 + 2) - 1
			000004 0004[2] a9 01                        LDA    #lobyte(1)
			000006 0006[2] a9 05                        LDA    #((3 + 2) - 1) + lobyte(1)
			000008 0008[1] 0a                           ASL    A
			000009 0009[1] 60                           RTS
		`)[1:], list)
	})

	t.Run("ok: optimize 0", func(t *testing.T) {
		list := expectGenListOk(t, `flat!
			optimize near-jump 0
			L0: $(L0) -jump-if EQ?; $(L1) -jump-if NE?
			L1: $(L0) -jump
			fn()
			proc fn() { PC -return }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "mos6502"

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[5] d0 03 4c 00 00               #.jump #L0, EQ
			000005 0005[5] f0 03 4c 0a 00               #.jump #L1, NE
			     - 000a                             L1:
			00000a 000a[3] 4c 00 00                     JMP    L0
			00000d 000d[3] 20 10 00                     JSR    fn

			     - 0010                             fn:
			000010 0010[1] 60                           RTS
		`)[1:], list)
	})

	t.Run("ok: optimize 1", func(t *testing.T) {
		list := expectGenListOk(t, `flat!
			optimize near-jump 1
			L0: $(L0) -jump-if EQ?; $(L1) -jump-if NE?
			L1: $(L0) -jump
			fn()
			proc fn() { PC -return }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "mos6502"

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[2] f0 fe                        BEQ    L0
			000002 0002[2] d0 00                        BNE    L1
			     - 0004                             L1:
			000004 0004[3] 4c 00 00                     JMP    L0
			000007 0007[3] 20 0a 00                     JSR    fn

			     - 000a                             fn:
			00000a 000a[1] 60                           RTS
		`)[1:], list)
	})
}

func TestCompileCall(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			f001: RTS
			f002: JMP [f001]
			JSR [f001]
			JSR [f002]
			ORA 0
		`)
		dat := expectCompileOk(t, `flat!
			proc f001(!) { RTS }
			proc f002(!) { JMP [f001] }
			proc f003(-* !) { A | 0; RTS }
			f001(!)
			f002(!)
			f003(-* !)
		`)
		tt.EqSlice(t, expected, dat)
	})

	t.Run("ok: sig", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			f001: RTS
			f002: RTS
			f003: RTS
			JSR [f001]
			JSR [f002]
			JSR [f003]
		`)
		dat := expectCompileOk(t, `flat!
			proc f001(X => Y) { RTS }
			proc f002(Y => !) { RTS }
			proc f003(Y => X !) { RTS }
			f001(X => Y)
			f002(Y => !)
			f003(Y => X !)
		`)
		tt.EqSlice(t, expected, dat)
	})

	t.Run("ok: fallthrough", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			f001: f002: RTS
		`)
		dat := expectCompileOk(t, `flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RTS }
		`)
		tt.EqSlice(t, expected, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [X] ! [],\n" +
				"  given    [Y] => [Y] ! []", `flat!
				proc f001(X => X) { RTS }
				f001(Y => Y)
			`,
			"unsupported instruction for mos6502", `flat!
				proc f001(!) { RTS }
				CC?.f001(!)
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { @1 }
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { @1 }
				f001(-* !)
			`,
			"unsupported instruction in inline code", `flat!
				proc f001(-* !) { RTI }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileJump(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			L0: NOP; JMP [L0]
		`)
		dat := expectCompileOk(t, `flat!
			loop { NOP }
		`)
		tt.EqSlice(t, expected, dat)
	})
}

func TestCompileOptimize(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			optimize near-jump 1
			L0: expand-loop 65 { $(L0) -jump-if CC? }
			expand-loop 65 { $(L1) -jump-if CS? }; L1:
		`)
		tt.EqSlice(t, []byte{
			0x90, 0xfe, 0x90, 0xfc, 0x90, 0xfa, 0x90, 0xf8, 0x90, 0xf6, 0x90, 0xf4, 0x90, 0xf2, 0x90, 0xf0,
			0x90, 0xee, 0x90, 0xec, 0x90, 0xea, 0x90, 0xe8, 0x90, 0xe6, 0x90, 0xe4, 0x90, 0xe2, 0x90, 0xe0,
			0x90, 0xde, 0x90, 0xdc, 0x90, 0xda, 0x90, 0xd8, 0x90, 0xd6, 0x90, 0xd4, 0x90, 0xd2, 0x90, 0xd0,
			0x90, 0xce, 0x90, 0xcc, 0x90, 0xca, 0x90, 0xc8, 0x90, 0xc6, 0x90, 0xc4, 0x90, 0xc2, 0x90, 0xc0,
			0x90, 0xbe, 0x90, 0xbc, 0x90, 0xba, 0x90, 0xb8, 0x90, 0xb6, 0x90, 0xb4, 0x90, 0xb2, 0x90, 0xb0,
			0x90, 0xae, 0x90, 0xac, 0x90, 0xaa, 0x90, 0xa8, 0x90, 0xa6, 0x90, 0xa4, 0x90, 0xa2, 0x90, 0xa0,
			0x90, 0x9e, 0x90, 0x9c, 0x90, 0x9a, 0x90, 0x98, 0x90, 0x96, 0x90, 0x94, 0x90, 0x92, 0x90, 0x90,
			0x90, 0x8e, 0x90, 0x8c, 0x90, 0x8a, 0x90, 0x88, 0x90, 0x86, 0x90, 0x84, 0x90, 0x82, 0x90, 0x80,
			0xb0, 0x03, 0x4c, 0x00, 0x00, 0x90, 0x03, 0x4c, 0x0a, 0x01,
			0xb0, 0x7e, 0xb0, 0x7c, 0xb0, 0x7a, 0xb0, 0x78, 0xb0, 0x76, 0xb0, 0x74, 0xb0, 0x72, 0xb0, 0x70,
			0xb0, 0x6e, 0xb0, 0x6c, 0xb0, 0x6a, 0xb0, 0x68, 0xb0, 0x66, 0xb0, 0x64, 0xb0, 0x62, 0xb0, 0x60,
			0xb0, 0x5e, 0xb0, 0x5c, 0xb0, 0x5a, 0xb0, 0x58, 0xb0, 0x56, 0xb0, 0x54, 0xb0, 0x52, 0xb0, 0x50,
			0xb0, 0x4e, 0xb0, 0x4c, 0xb0, 0x4a, 0xb0, 0x48, 0xb0, 0x46, 0xb0, 0x44, 0xb0, 0x42, 0xb0, 0x40,
			0xb0, 0x3e, 0xb0, 0x3c, 0xb0, 0x3a, 0xb0, 0x38, 0xb0, 0x36, 0xb0, 0x34, 0xb0, 0x32, 0xb0, 0x30,
			0xb0, 0x2e, 0xb0, 0x2c, 0xb0, 0x2a, 0xb0, 0x28, 0xb0, 0x26, 0xb0, 0x24, 0xb0, 0x22, 0xb0, 0x20,
			0xb0, 0x1e, 0xb0, 0x1c, 0xb0, 0x1a, 0xb0, 0x18, 0xb0, 0x16, 0xb0, 0x14, 0xb0, 0x12, 0xb0, 0x10,
			0xb0, 0x0e, 0xb0, 0x0c, 0xb0, 0x0a, 0xb0, 0x08, 0xb0, 0x06, 0xb0, 0x04, 0xb0, 0x02, 0xb0, 0x00,
		}, dat, len(dat))
	})

	t.Run("ok: JMP", func(t *testing.T) {
		dat := expectCompileOk(t, `flat!
			optimize near-jump 1
			L0: JMP [L0]; NOP
		`)
		tt.EqSlice(t, []byte{0x4c, 0x00, 0x00, 0xea}, dat)
	})

	t.Run("ok: optimize 0", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			L0: BNE L0+; JMP [L0]; L0+: BEQ L1+; JMP [L1]; L1+:
			L1: JMP [L0]
		`)
		dat := expectCompileOk(t, `flat!
			optimize near-jump 0
			L0: $(L0) -jump-if EQ?; $(L1) -jump-if NE?
			L1: $(L0) -jump
		`)
		tt.EqSlice(t, expected, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown optimizer: unknown", `flat!
				optimize unknown
			`,
		}
		for x := 0; x < len(es); x += 2 {
			mes := expectCompileError(t, es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileOptimizeFlow(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		es := []string{
			`flat!; do {
			  L0: JMP [L4]
			  N1: NOP
			  L1: JMP [L4]
			  N2: NOP
			  L2: JMP [L4]
			  N3: NOP
			  L3: JMP [L4]
			  N4: NOP
			  L4: NOP ; RTS
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: NOP ; PC -return
			}`,

			`flat!; do {
			  L0: JMP [L2]
			  N1: NOP
			  L1: JMP [L2]
			  N2: NOP
			  L2: BEQ L4
			  N3: NOP
			  L3: JMP [L4]
			  N4: NOP
			  L4: NOP ; RTS
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump-if EQ?
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: NOP ; PC -return
			}`,

			`flat!; do {
			  L0: RTS
			  N1: NOP
			  L1: RTS
			  N2: NOP
			  L2: RTS
			  N3: NOP
			  L3: RTS
			  N4: NOP
			  L4: RTS
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: PC -return
			}`,

			`flat!; do {
			  L0: JMP [L2]
			  N1: NOP
			  L1: JMP [L2]
			  N2: NOP
			  L2: BNE L2+ ; RTS ; L2+:
			  N3: NOP
			  L3: RTS
			  N4: NOP
			  L4: RTS
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: $(L3) -jump-if EQ?
			  N3: NOP
			  L3: $(L4) -jump
			  N4: NOP
			  L4: PC -return
			}`,

			//
			`flat!; do {
			    RTS
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: PC -return ; CLC
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: BNE L0+; RTS ; L0+: CLC
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: PC -return-if EQ? ; CLC
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RTS
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: PC -return
			    L1: PC -return
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L1: BNE L1+ ; RTS ; L1+:
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: PC -return-if EQ?
			    L1: PC -return-if EQ?
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RTS
			    L1: BNE L1+ ; RTS ; L1+:
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: PC -return
			    L1: PC -return-if EQ?
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    RTS
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: PC -return-if EQ?
			    L1: PC -return
			    L9: $(0x00) -jump
			}`,

			//
			`flat!; do {
			    L0: JMP [L9]
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump ; CLC
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: BEQ L9 ; CLC
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump-if EQ? ; CLC
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: JMP [L9]
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump
			    L1: $(L9) -jump
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: BEQ L9
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump-if EQ?
			    L1: $(L9) -jump-if EQ?
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L0: JMP [L9]
			    L1: BEQ L9
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump
			    L1: $(L9) -jump-if EQ?
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    L1: JMP [L9]
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(L9) -jump-if EQ?
			    L1: $(L9) -jump
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(N9) -jump
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			`flat!; do {
			    N9: NOP
			    L9: JMP [0]
			}`, `optimize flow; proc f001() {
			    L0: $(N9) -jump-if EQ?
			    N9: NOP
			    L9: $(0x00) -jump
			}`,

			//
			`flat!; do {
			  RTS
			  data byte [0 1 2 3]
			  L1: RTS
			}`, `optimize flow; proc f001() {
			  $(L1) -jump
			  data byte [0 1 2 3]
			  L1: PC -return
			}`,

			`flat!; do {
			  L0: JMP [L2]
			  N1: NOP
			  L1: JMP [L2]
			  N2: NOP
			  L2: JMP [L3]
			  N3: NOP
			  L3: NOP ; RTS
			}`, `optimize flow; proc f001() {
			  L0: $(L1) -jump
			  N1: NOP
			  L1: $(L2) -jump
			  N2: NOP
			  L2: align 2; $(L3) -jump ;
			  N3: NOP
			  L3: NOP ; RTS
			}`,
		}
		for x := 0; x < len(es); x += 2 {
			expected := expectCompileOk(t, es[x])
			dat := expectCompileOk(t, es[x+1])
			tt.EqSlice(t, expected, dat, x/2, es[x+1])
		}
	})

	t.Run("ok: jump cycle", func(t *testing.T) {
		expected := expectCompileOk(t, `flat!
			NOP
			L0: JMP [L1] ; N0: NOP
			L1: JMP [L2] ; N1: NOP
			L2: JMP [L3] ; N2: NOP
			L3: JMP [L1] ; N3: NOP
			L4: NOP ; RTS
		`)
		g := ttarch.BuildGenerator("mos6502", tt.Unindent(`flat!
			optimize flow
			proc f001() {
			  NOP
			  L0: $(L1) -jump ; NOP ; N0: NOP
			  L1: $(L2) -jump ; NOP ; N1: NOP
			  L2: $(L3) -jump ; NOP ; N2: NOP
			  L3: $(L1) -jump ; NOP ; N3: NOP
			  L4: NOP ; RTS
			}
		`))
		dat, _, mes := ttarch.DoCompile(g, "-")
		warns := slices.Sorted(slices.Values(ttarch.WarningMessages(g)))

		tt.EqSlice(t, expected, dat, mes)
		tt.EqSlice(t, []string{
			"warning: jump cycle detected: L0 -> L1",
			"warning: jump cycle detected: L1 -> L2",
			"warning: jump cycle detected: L2 -> L3",
			"warning: jump cycle detected: L3 -> L1",
		}, warns)
	})
}

func TestCompileError(t *testing.T) {
	es := []string{
		"cannot use invalid-operand as operand#1 for LDA", `flat!
			A <- [1 2 3]
		`,
		"cannot use out-of-range as operand#1 for ORA", `flat!
			A | [[1024 X]]
		`,
		"cannot use out-of-range as operand#1 for ORA", `flat!
			A | [[1024] Y]
		`,
	}
	for x := 0; x < len(es); x += 2 {
		mes := expectCompileError(t, es[x+1])
		tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
	}
}
