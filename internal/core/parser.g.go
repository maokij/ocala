// GENERATED BY llpg
//lint:file-ignore U1000 generated code
//lint:file-ignore SA4004 generated code

package core

const (
    tkEOF = iota
    tkSCANERROR
    tkSC
    tkREST
    tkEQ
    tkLS
    tkRS
    tkAT
    tkLP
    tkRP
    tkMACRO
    tkPROC
    tkCONST
    tkDATA
    tkMODULE
    tkLABEL
    tkSTRUCT
    tkLC
    tkRC
    tkBINARY_OPERATOR
    tkCL
    tkPELC
    tkIDENTIFIER
    tkSTRING
    tkMIAS
    tkEQGT
    tkEX
    tkREGISTER
    tkEQLC
    tkCONDDOT
    tkATMI
    tkPOSTFIX_OPERATOR
    tkDOT_OPERATOR
    tkCONDITION
    tkMIAT
    tkDLAT
    tkDLDLAT
    tkDTMI
    tkINTEGER
    tkRESERVED
    tkIDENTIFIERP
    tkPREFIX_OPERATOR
    tkLABEL_NAME
)

var tokenKinds = map[string]int32{
    ";": tkSC,
    "=": tkEQ,
    "[": tkLS,
    "]": tkRS,
    "@": tkAT,
    "(": tkLP,
    ")": tkRP,
    "{": tkLC,
    "}": tkRC,
    ":": tkCL,
    "%{": tkPELC,
    "-*": tkMIAS,
    "=>": tkEQGT,
    "!": tkEX,
    "={": tkEQLC,
    "@-": tkATMI,
    "-@": tkMIAT,
    "$@": tkDLAT,
    "$$@": tkDLDLAT,
    ".-": tkDTMI,
}

var tokenLabels = [...]string{
    "EOF", // tkEOF
    "SCANERROR", // tkSCANERROR
    "';'", // tkSC
    "REST", // tkREST
    "'='", // tkEQ
    "'['", // tkLS
    "']'", // tkRS
    "'@'", // tkAT
    "'('", // tkLP
    "')'", // tkRP
    "MACRO", // tkMACRO
    "PROC", // tkPROC
    "CONST", // tkCONST
    "DATA", // tkDATA
    "MODULE", // tkMODULE
    "LABEL", // tkLABEL
    "STRUCT", // tkSTRUCT
    "'{'", // tkLC
    "'}'", // tkRC
    "BINARY_OPERATOR", // tkBINARY_OPERATOR
    "':'", // tkCL
    "'%{'", // tkPELC
    "IDENTIFIER", // tkIDENTIFIER
    "STRING", // tkSTRING
    "'-*'", // tkMIAS
    "'=>'", // tkEQGT
    "'!'", // tkEX
    "REGISTER", // tkREGISTER
    "'={'", // tkEQLC
    "CONDDOT", // tkCONDDOT
    "'@-'", // tkATMI
    "POSTFIX_OPERATOR", // tkPOSTFIX_OPERATOR
    "DOT_OPERATOR", // tkDOT_OPERATOR
    "CONDITION", // tkCONDITION
    "'-@'", // tkMIAT
    "'$@'", // tkDLAT
    "'$$@'", // tkDLDLAT
    "'.-'", // tkDTMI
    "INTEGER", // tkINTEGER
    "RESERVED", // tkRESERVED
    "IDENTIFIERP", // tkIDENTIFIERP
    "PREFIX_OPERATOR", // tkPREFIX_OPERATOR
    "LABEL_NAME", // tkLABEL_NAME
}

var reservedWords = map[string]int32{
  "macro": tkMACRO,
  "proc": tkPROC,
  "const": tkCONST,
  "data": tkDATA,
  "module": tkMODULE,
  "struct": tkSTRUCT,
  "_": tkRESERVED,
  "_BEG": tkRESERVED,
  "_END": tkRESERVED,
  "_COND": tkRESERVED,
}

func (p *Parser) _parse() (res Value, ok bool) {
    res = p._parseProgram()
    if (p.PeekToken().Kind != tkEOF) {
         p.ErrorUnexpected("EOF")
    }
    ok = true
    return
}

/** ** **
  program ->
      statement? (
        ';' statement?
      )*
 ** ** **/
func (p *Parser) _parseProgram() (ret Value) {
    res := &ret; _ = res
    // RULE: program -> _program_1o _program_4r
    v := &Vec{KwBlock.ToId(p.PeekToken())}
    switch p.PeekToken().Kind {
    case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkSC, tkEOF, tkRC:
        // @ _program_1o _program_4r
        var _1 Value; _ = _1
        for {
            res := &_1; _ = res
            // RULE: _program_1o -> statement
            // RULE: _program_1o -> 
            switch p.PeekToken().Kind {
            case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                // @ statement
                _1 := p._parseStatement(); _ = _1
                *res = _1 // DEFAULT OPT ACTION
            case tkSC, tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("statement, ';', etc.")
            }
            break
        }
        if _1 != nil { v.Push(_1) }

        // _program_1o @ _program_4r
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _program_4r -> _program_3g*
            // RULE: _program_3g -> ';' _program_2o
            switch p.PeekToken().Kind {
            case tkSC:
                // @ ';' _program_2o
                _1 := p.ConsumeToken(); _ = _1

                // ';' @ _program_2o
                var _2 Value; _ = _2
                for {
                    res := &_2; _ = res
                    // RULE: _program_2o -> statement
                    // RULE: _program_2o -> 
                    switch p.PeekToken().Kind {
                    case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                        // @ statement
                        _1 := p._parseStatement(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                    case tkSC, tkEOF, tkRC:
                        // NOP
                    default:
                        p.ErrorUnexpected("statement, etc.")
                    }
                    break
                }
                if _2 != nil { v.Push(_2) }

                continue
            case tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("';', etc.")
            }
            break
        }
        *res = v
    default:
        p.ErrorUnexpected("program, etc.")
    }
    return
}

/** ** **
  statement ->
      MACRO identifierp '(' (
        identifier
      | label_name data_expression
      )* REST? ')' (
        '[' (
          identifier (
            '=' symbol_expression
          )?
        )* ']'
      )? block
    | PROC identifierp '(' signature ')' (
        block
      | '@' data_expression
      )
    | CONST (
        identifier
      | identifierp '(' (
          identifier
        | label_name data_expression
        )* ')'
      ) '=' data_expression
    | DATA data_type (
        '=' data_type
      )? data_body
    | MODULE identifier block
    | LABEL label_name
    | struct
    | identifier (
        operand
      )*
    | proc_call
    | context_expression
 ** ** **/
func (p *Parser) _parseStatement() (ret Value) {
    res := &ret; _ = res
    // RULE: statement -> MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o block
    // RULE: statement -> PROC identifierp '(' signature ')' _statement_14g
    // RULE: statement -> CONST _statement_17g '=' data_expression
    // RULE: statement -> DATA data_type _statement_19o data_body
    // RULE: statement -> MODULE identifier block
    // RULE: statement -> LABEL label_name
    // RULE: statement -> struct
    // RULE: statement -> identifier _statement_21r
    // RULE: statement -> proc_call
    // RULE: statement -> context_expression
    switch p.PeekToken().Kind {
    case tkMACRO:
        // @ MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o block
        _1 := p.ConsumeToken(); _ = _1

        // MACRO @ identifierp '(' _statement_6r _statement_7o ')' _statement_13o block
        _2 := p._parseIdentifierp(); _ = _2
        v := &Vec{}; w := &Vec{}

        // MACRO identifierp @ '(' _statement_6r _statement_7o ')' _statement_13o block
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkLP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'('")
        }

        // MACRO identifierp '(' @ _statement_6r _statement_7o ')' _statement_13o block
        var _4 Value; _ = _4
        for {
            res := &_4; _ = res
            // RULE: _statement_6r -> _statement_5g*
            // RULE: _statement_5g -> identifier
            // RULE: _statement_5g -> label_name data_expression
            switch p.PeekToken().Kind {
            case tkIDENTIFIER:
                // @ identifier
                _1 := p._parseIdentifier(); _ = _1
                v.Push(&Vec{_1, NIL})

                continue
            case tkLABEL_NAME:
                // @ label_name data_expression
                _1 := p._parseLabelName(); _ = _1

                // label_name @ data_expression
                _2 := p._parseDataExpression(); _ = _2
                v.Push(&Vec{_1, _2})

                continue
            case tkREST, tkRP:
                // NOP
            default:
                p.ErrorUnexpected("identifier, label-name, REST, ')'")
            }
            break
        }

        // MACRO identifierp '(' _statement_6r @ _statement_7o ')' _statement_13o block
        var _5 *Token; _ = _5
        for {
            res := &_5; _ = res
            // RULE: _statement_7o -> REST
            // RULE: _statement_7o -> 
            switch p.PeekToken().Kind {
            case tkREST:
                // @ REST
                _1 := p.ConsumeToken(); _ = _1
                *res = _1 // DEFAULT OPT ACTION
            case tkRP:
                *res = NILTK
            default:
                p.ErrorUnexpected("REST, ')'")
            }
            break
        }

        // MACRO identifierp '(' _statement_6r _statement_7o @ ')' _statement_13o block
        _6 := p.PeekToken(); _ = _6
        if _6.Kind == tkRP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("')'")
        }

        // MACRO identifierp '(' _statement_6r _statement_7o ')' @ _statement_13o block
        var _7 Value; _ = _7
        for {
            res := &_7; _ = res
            // RULE: _statement_13o -> _statement_12g?
            // RULE: _statement_12g -> '[' _statement_11r ']'
            switch p.PeekToken().Kind {
            case tkLS:
                // @ '[' _statement_11r ']'
                _1 := p.ConsumeToken(); _ = _1

                // '[' @ _statement_11r ']'
                var _2 Value; _ = _2
                for {
                    res := &_2; _ = res
                    // RULE: _statement_11r -> _statement_10g*
                    // RULE: _statement_10g -> identifier _statement_9o
                    switch p.PeekToken().Kind {
                    case tkIDENTIFIER:
                        // @ identifier _statement_9o
                        _1 := p._parseIdentifier(); _ = _1
                        l := _1; r := Value(NIL)

                        // identifier @ _statement_9o
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _statement_9o -> _statement_8g?
                            // RULE: _statement_8g -> '=' symbol_expression
                            switch p.PeekToken().Kind {
                            case tkEQ:
                                // @ '=' symbol_expression
                                _1 := p.ConsumeToken(); _ = _1

                                // '=' @ symbol_expression
                                _2 := p._parseSymbolExpression(); _ = _2
                                r = _2
                            case tkIDENTIFIER, tkRS:
                                // NOP
                            default:
                                p.ErrorUnexpected("'=', etc.")
                            }
                            break
                        }
                        w.Push(l, r)

                        continue
                    case tkRS:
                        // NOP
                    default:
                        p.ErrorUnexpected("identifier, ']'")
                    }
                    break
                }

                // '[' _statement_11r @ ']'
                _3 := p.PeekToken(); _ = _3
                if _3.Kind == tkRS {
                    p.ConsumeToken()
                } else {
                    p.ErrorUnexpected("']'")
                }
            case tkLC, tkEQLC:
                // NOP
            default:
                p.ErrorUnexpected("'[', block")
            }
            break
        }

        // MACRO identifierp '(' _statement_6r _statement_7o ')' _statement_13o @ block
        _8 := p._parseBlock(); _ = _8
        *res = &Vec{KwMacro.ToId(_1), _2, v, w, _5.Value, _8}
    case tkPROC:
        // @ PROC identifierp '(' signature ')' _statement_14g
        _1 := p.ConsumeToken(); _ = _1

        // PROC @ identifierp '(' signature ')' _statement_14g
        _2 := p._parseIdentifierp(); _ = _2

        // PROC identifierp @ '(' signature ')' _statement_14g
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkLP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'('")
        }

        // PROC identifierp '(' @ signature ')' _statement_14g
        _4 := p._parseSignature(); _ = _4

        // PROC identifierp '(' signature @ ')' _statement_14g
        _5 := p.PeekToken(); _ = _5
        if _5.Kind == tkRP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("')'")
        }
        v := &Vec{KwProc.ToId(_1), _2, _4}

        // PROC identifierp '(' signature ')' @ _statement_14g
        var _6 Value; _ = _6
        for {
            res := &_6; _ = res
            // RULE: _statement_14g -> block
            // RULE: _statement_14g -> '@' data_expression
            switch p.PeekToken().Kind {
            case tkLC, tkEQLC:
                // @ block
                _1 := p._parseBlock(); _ = _1
                v.Push(_1)
            case tkAT:
                // @ '@' data_expression
                _1 := p.ConsumeToken(); _ = _1

                // '@' @ data_expression
                _2 := p._parseDataExpression(); _ = _2
                v.Push(_2)
            default:
                p.ErrorUnexpected("block, '@'")
            }
            break
        }
        *res = v
    case tkCONST:
        // @ CONST _statement_17g '=' data_expression
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{}

        // CONST @ _statement_17g '=' data_expression
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _statement_17g -> identifier
            // RULE: _statement_17g -> identifierp '(' _statement_16r ')'
            switch p.PeekToken().Kind {
            case tkIDENTIFIER:
                // @ identifier
                _1 := p._parseIdentifier(); _ = _1
                *res = _1
            case tkIDENTIFIERP:
                // @ identifierp '(' _statement_16r ')'
                _1 := p._parseIdentifierp(); _ = _1

                // identifierp @ '(' _statement_16r ')'
                _2 := p.PeekToken(); _ = _2
                if _2.Kind == tkLP {
                    p.ConsumeToken()
                } else {
                    p.ErrorUnexpected("'('")
                }

                // identifierp '(' @ _statement_16r ')'
                var _3 Value; _ = _3
                for {
                    res := &_3; _ = res
                    // RULE: _statement_16r -> _statement_15g*
                    // RULE: _statement_15g -> identifier
                    // RULE: _statement_15g -> label_name data_expression
                    switch p.PeekToken().Kind {
                    case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        v.Push(&Vec{_1, NIL})

                        continue
                    case tkLABEL_NAME:
                        // @ label_name data_expression
                        _1 := p._parseLabelName(); _ = _1

                        // label_name @ data_expression
                        _2 := p._parseDataExpression(); _ = _2
                        v.Push(&Vec{_1, _2})

                        continue
                    case tkRP:
                        // NOP
                    default:
                        p.ErrorUnexpected("identifier, label-name, ')'")
                    }
                    break
                }

                // identifierp '(' _statement_16r @ ')'
                _4 := p.PeekToken(); _ = _4
                if _4.Kind == tkRP {
                    p.ConsumeToken()
                } else {
                    p.ErrorUnexpected("')'")
                }
                *res = _1
            default:
                p.ErrorUnexpected("identifier")
            }
            break
        }

        // CONST _statement_17g @ '=' data_expression
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkEQ {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'='")
        }

        // CONST _statement_17g '=' @ data_expression
        _4 := p._parseDataExpression(); _ = _4
        *res = &Vec{KwConst.ToId(_1), _2, v, _4}
    case tkDATA:
        // @ DATA data_type _statement_19o data_body
        _1 := p.ConsumeToken(); _ = _1

        // DATA @ data_type _statement_19o data_body
        _2 := p._parseDataType(); _ = _2
        v := Value(NIL); w := _2

        // DATA data_type @ _statement_19o data_body
        var _3 Value; _ = _3
        for {
            res := &_3; _ = res
            // RULE: _statement_19o -> _statement_18g?
            // RULE: _statement_18g -> '=' data_type
            switch p.PeekToken().Kind {
            case tkEQ:
                // @ '=' data_type
                _1 := p.ConsumeToken(); _ = _1

                // '=' @ data_type
                _2 := p._parseDataType(); _ = _2
                v = w; w = _2
            case tkBINARY_OPERATOR, tkCL, tkAT, tkLS, tkLC, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkSC, tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("'=', data-body, etc.")
            }
            break
        }

        // DATA data_type _statement_19o @ data_body
        _4 := p._parseDataBody(); _ = _4
        *res = &Vec{KwData.ToId(_1), v, w, _4}
    case tkMODULE:
        // @ MODULE identifier block
        _1 := p.ConsumeToken(); _ = _1

        // MODULE @ identifier block
        _2 := p._parseIdentifier(); _ = _2

        // MODULE identifier @ block
        _3 := p._parseBlock(); _ = _3
        *res = &Vec{KwModule.ToId(_1), _2, _3}
    case tkLABEL:
        // @ LABEL label_name
        _1 := p.ConsumeToken(); _ = _1

        // LABEL @ label_name
        _2 := p._parseLabelName(); _ = _2
        *res = &Vec{KwLabel.ToId(_1), _2}
    case tkSTRUCT:
        // @ struct
        _1 := p._parseStruct(); _ = _1
        v := _1.(*Vec); v.SetAt(1, NIL); *res = v
    case tkIDENTIFIER:
        // @ identifier _statement_21r
        _1 := p._parseIdentifier(); _ = _1
        v := &Vec{_idfrom(_1)}

        // identifier @ _statement_21r
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _statement_21r -> _statement_20g*
            // RULE: _statement_20g -> operand
            switch p.PeekToken().Kind {
            case tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ operand
                _1 := p._parseOperand(); _ = _1
                v.Push(_1)

                continue
            case tkSC, tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("operand, etc.")
            }
            break
        }
        *res = v
    case tkCONDDOT, tkIDENTIFIERP:
        // @ proc_call
        _1 := p._parseProcCall(); _ = _1
        *res = _1
    case tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
        // @ context_expression
        _1 := p._parseContextExpression(); _ = _1
        *res = _1
    default:
        p.ErrorUnexpected("statement")
    }
    return
}

/** ** **
  struct ->
      STRUCT identifier? '{' struct_field? (
        ';' struct_field?
      )* '}'
 ** ** **/
func (p *Parser) _parseStruct() (ret Value) {
    res := &ret; _ = res
    // RULE: struct -> STRUCT _struct_22o '{' _struct_23o _struct_26r '}'
    switch p.PeekToken().Kind {
    case tkSTRUCT:
        // @ STRUCT _struct_22o '{' _struct_23o _struct_26r '}'
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{KwStruct.ToId(_1), Int(1), NIL}

        // STRUCT @ _struct_22o '{' _struct_23o _struct_26r '}'
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _struct_22o -> identifier
            // RULE: _struct_22o -> 
            switch p.PeekToken().Kind {
            case tkIDENTIFIER:
                // @ identifier
                _1 := p._parseIdentifier(); _ = _1
                *res = _1 // DEFAULT OPT ACTION
            case tkLC:
                // NOP
            default:
                p.ErrorUnexpected("identifier, '{'")
            }
            break
        }
        if _2 != nil { v.SetAt(2, _2) }

        // STRUCT _struct_22o @ '{' _struct_23o _struct_26r '}'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkLC {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'{'")
        }

        // STRUCT _struct_22o '{' @ _struct_23o _struct_26r '}'
        var _4 Value; _ = _4
        for {
            res := &_4; _ = res
            // RULE: _struct_23o -> struct_field
            // RULE: _struct_23o -> 
            switch p.PeekToken().Kind {
            case tkIDENTIFIER:
                // @ struct_field
                _1 := p._parseStructField(); _ = _1
                *res = _1 // DEFAULT OPT ACTION
            case tkSC, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("struct-field, ';', '}'")
            }
            break
        }
        if _4 != nil { v.Push(_4) }

        // STRUCT _struct_22o '{' _struct_23o @ _struct_26r '}'
        var _5 Value; _ = _5
        for {
            res := &_5; _ = res
            // RULE: _struct_26r -> _struct_25g*
            // RULE: _struct_25g -> ';' _struct_24o
            switch p.PeekToken().Kind {
            case tkSC:
                // @ ';' _struct_24o
                _1 := p.ConsumeToken(); _ = _1

                // ';' @ _struct_24o
                var _2 Value; _ = _2
                for {
                    res := &_2; _ = res
                    // RULE: _struct_24o -> struct_field
                    // RULE: _struct_24o -> 
                    switch p.PeekToken().Kind {
                    case tkIDENTIFIER:
                        // @ struct_field
                        _1 := p._parseStructField(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                    case tkSC, tkRC:
                        // NOP
                    default:
                        p.ErrorUnexpected("struct-field, etc.")
                    }
                    break
                }
                if _2 != nil { v.Push(_2) }

                continue
            case tkRC:
                // NOP
            default:
                p.ErrorUnexpected("';', '}'")
            }
            break
        }

        // STRUCT _struct_22o '{' _struct_23o _struct_26r @ '}'
        _6 := p.PeekToken(); _ = _6
        if _6.Kind == tkRC {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'}'")
        }
        *res = v
    default:
        p.ErrorUnexpected("struct")
    }
    return
}

/** ** **
  struct_field ->
      identifier data_type
 ** ** **/
func (p *Parser) _parseStructField() (ret Value) {
    res := &ret; _ = res
    // RULE: struct_field -> identifier data_type
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
        // @ identifier data_type
        _1 := p._parseIdentifier(); _ = _1

        // identifier @ data_type
        _2 := p._parseDataType(); _ = _2
        *res = &Vec{_1, _2}
    default:
        p.ErrorUnexpected("struct-field")
    }
    return
}

/** ** **
  data_type ->
      '[' (
        constexpr
      )? ']' data_type
    | identifier
    | struct
 ** ** **/
func (p *Parser) _parseDataType() (ret Value) {
    res := &ret; _ = res
    // RULE: data_type -> '[' _data_type_28o ']' data_type
    // RULE: data_type -> identifier
    // RULE: data_type -> struct
    switch p.PeekToken().Kind {
    case tkLS:
        // @ '[' _data_type_28o ']' data_type
        _1 := p.ConsumeToken(); _ = _1
        v := Value(NIL)

        // '[' @ _data_type_28o ']' data_type
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _data_type_28o -> _data_type_27g?
            // RULE: _data_type_27g -> constexpr
            switch p.PeekToken().Kind {
            case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ constexpr
                _1 := p._parseConstexpr(); _ = _1
                v = _1
            case tkRS:
                // NOP
            default:
                p.ErrorUnexpected("constexpr, ']'")
            }
            break
        }

        // '[' _data_type_28o @ ']' data_type
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRS {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("']'")
        }

        // '[' _data_type_28o ']' @ data_type
        _4 := p._parseDataType(); _ = _4
        *res = &Vec{KwArray.ToId(_1), _4, v}
    case tkIDENTIFIER:
        // @ identifier
        _1 := p._parseIdentifier(); _ = _1
        *res = _1
    case tkSTRUCT:
        // @ struct
        _1 := p._parseStruct(); _ = _1
        *res = _1
    default:
        p.ErrorUnexpected("data-type")
    }
    return
}

/** ** **
  data_body ->
      (
        data_list
      | constval
      )? (
        BINARY_OPERATOR data_value
      )? (
        ':' identifier
      | '@' data_expression
      )?
 ** ** **/
func (p *Parser) _parseDataBody() (ret Value) {
    res := &ret; _ = res
    // RULE: data_body -> _data_body_30o _data_body_32o _data_body_34o
    values := Value(NIL)
    switch p.PeekToken().Kind {
    case tkLS, tkLC, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkBINARY_OPERATOR, tkCL, tkAT, tkSC, tkEOF, tkRC:
        // @ _data_body_30o _data_body_32o _data_body_34o
        var _1 Value; _ = _1
        for {
            res := &_1; _ = res
            // RULE: _data_body_30o -> _data_body_29g?
            // RULE: _data_body_29g -> data_list
            // RULE: _data_body_29g -> constval
            switch p.PeekToken().Kind {
            case tkLS, tkLC:
                // @ data_list
                _1 := p._parseDataList(); _ = _1
                values = _1
            case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ constval
                _1 := p._parseConstval(); _ = _1
                values = _1
            case tkBINARY_OPERATOR, tkCL, tkAT, tkSC, tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("data-list, constval, BINARY-OPERATOR, ':', '@', etc.")
            }
            break
        }
        alloc := Value(idMulOp);
                                            size := Value(InternalConstexpr(Int(1)))

        // _data_body_30o @ _data_body_32o _data_body_34o
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _data_body_32o -> _data_body_31g?
            // RULE: _data_body_31g -> BINARY_OPERATOR data_value
            switch p.PeekToken().Kind {
            case tkBINARY_OPERATOR:
                // @ BINARY_OPERATOR data_value
                _1 := p.ConsumeToken(); _ = _1

                // BINARY_OPERATOR @ data_value
                _2 := p._parseDataValue(); _ = _2
                alloc = _1.Value; size = _2
            case tkCL, tkAT, tkSC, tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("BINARY-OPERATOR, ':', '@', etc.")
            }
            break
        }
        section := Value(NIL); addr := Value(NIL)

        // _data_body_30o _data_body_32o @ _data_body_34o
        var _3 Value; _ = _3
        for {
            res := &_3; _ = res
            // RULE: _data_body_34o -> _data_body_33g?
            // RULE: _data_body_33g -> ':' identifier
            // RULE: _data_body_33g -> '@' data_expression
            switch p.PeekToken().Kind {
            case tkCL:
                // @ ':' identifier
                _1 := p.ConsumeToken(); _ = _1

                // ':' @ identifier
                _2 := p._parseIdentifier(); _ = _2
                section = _2
            case tkAT:
                // @ '@' data_expression
                _1 := p.ConsumeToken(); _ = _1

                // '@' @ data_expression
                _2 := p._parseDataExpression(); _ = _2
                addr = _2
            case tkSC, tkEOF, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("':', '@', etc.")
            }
            break
        }
        *res = &Vec{values, alloc, size, section, addr }
    default:
        p.ErrorUnexpected("data-body, etc.")
    }
    return
}

/** ** **
  data_list ->
      '[' (
        data_expression
      | data_list
      )* ']'
    | '{' (
        data_expression
      | data_list
      )* '}'
 ** ** **/
func (p *Parser) _parseDataList() (ret Value) {
    res := &ret; _ = res
    // RULE: data_list -> '[' _data_list_36r ']'
    // RULE: data_list -> '{' _data_list_38r '}'
    switch p.PeekToken().Kind {
    case tkLS:
        // @ '[' _data_list_36r ']'
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{KwDataList.ToId(_1)}

        // '[' @ _data_list_36r ']'
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _data_list_36r -> _data_list_35g*
            // RULE: _data_list_35g -> data_expression
            // RULE: _data_list_35g -> data_list
            switch p.PeekToken().Kind {
            case tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ data_expression
                _1 := p._parseDataExpression(); _ = _1
                v.Push(_1)

                continue
            case tkLS, tkLC:
                // @ data_list
                _1 := p._parseDataList(); _ = _1
                v.Push(_1)

                continue
            case tkRS:
                // NOP
            default:
                p.ErrorUnexpected("data-expression, data-list, ']'")
            }
            break
        }

        // '[' _data_list_36r @ ']'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRS {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("']'")
        }
        *res = v
    case tkLC:
        // @ '{' _data_list_38r '}'
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{KwStructData.ToId(_1)}; p.SetContext('#')

        // '{' @ _data_list_38r '}'
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _data_list_38r -> _data_list_37g*
            // RULE: _data_list_37g -> data_expression
            // RULE: _data_list_37g -> data_list
            switch p.PeekToken().Kind {
            case tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ data_expression
                _1 := p._parseDataExpression(); _ = _1
                v.Push(_1)

                continue
            case tkLS, tkLC:
                // @ data_list
                _1 := p._parseDataList(); _ = _1
                v.Push(_1)

                continue
            case tkRC:
                // NOP
            default:
                p.ErrorUnexpected("data-expression, data-list, '}'")
            }
            break
        }

        // '{' _data_list_38r @ '}'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRC {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'}'")
        }
        *res = v
    default:
        p.ErrorUnexpected("data-list")
    }
    return
}

/** ** **
  data_expression ->
      constexpr
    | explicit_value
 ** ** **/
func (p *Parser) _parseDataExpression() (ret Value) {
    res := &ret; _ = res
    // RULE: data_expression -> constexpr
    // RULE: data_expression -> explicit_value
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ constexpr
        _1 := p._parseConstexpr(); _ = _1
        *res = _1
    case tkDLAT, tkDLDLAT:
        // @ explicit_value
        _1 := p._parseExplicitValue(); _ = _1
        *res = _1
    default:
        p.ErrorUnexpected("data-expression")
    }
    return
}

/** ** **
  data_value ->
      constval
    | explicit_value
 ** ** **/
func (p *Parser) _parseDataValue() (ret Value) {
    res := &ret; _ = res
    // RULE: data_value -> constval
    // RULE: data_value -> explicit_value
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ constval
        _1 := p._parseConstval(); _ = _1
        *res = _1
    case tkDLAT, tkDLDLAT:
        // @ explicit_value
        _1 := p._parseExplicitValue(); _ = _1
        *res = _1
    default:
        p.ErrorUnexpected("data-value")
    }
    return
}

/** ** **
  symbol_expression ->
      '%{' symbol_expression_value (
        symbol_expression_value
      )* '}'
 ** ** **/
func (p *Parser) _parseSymbolExpression() (ret Value) {
    res := &ret; _ = res
    // RULE: symbol_expression -> '%{' symbol_expression_value _symbol_expression_40r '}'
    switch p.PeekToken().Kind {
    case tkPELC:
        // @ '%{' symbol_expression_value _symbol_expression_40r '}'
        _1 := p.ConsumeToken(); _ = _1

        // '%{' @ symbol_expression_value _symbol_expression_40r '}'
        _2 := p._parseSymbolExpressionValue(); _ = _2
        v := &Vec{KwMakeId.ToId(_1), _2}

        // '%{' symbol_expression_value @ _symbol_expression_40r '}'
        var _3 Value; _ = _3
        for {
            res := &_3; _ = res
            // RULE: _symbol_expression_40r -> _symbol_expression_39g*
            // RULE: _symbol_expression_39g -> symbol_expression_value
            switch p.PeekToken().Kind {
            case tkIDENTIFIER, tkSTRING:
                // @ symbol_expression_value
                _1 := p._parseSymbolExpressionValue(); _ = _1
                v.Push(_1)

                continue
            case tkRC:
                // NOP
            default:
                p.ErrorUnexpected("symbol-expression-value, '}'")
            }
            break
        }

        // '%{' symbol_expression_value _symbol_expression_40r @ '}'
        _4 := p.PeekToken(); _ = _4
        if _4.Kind == tkRC {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'}'")
        }
        *res = _constexpr(v, _1)
    default:
        p.ErrorUnexpected("symbol-expression")
    }
    return
}

/** ** **
  symbol_expression_value ->
      IDENTIFIER
    | STRING
 ** ** **/
func (p *Parser) _parseSymbolExpressionValue() (ret Value) {
    res := &ret; _ = res
    // RULE: symbol_expression_value -> IDENTIFIER
    // RULE: symbol_expression_value -> STRING
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
        // @ IDENTIFIER
        _1 := p.ConsumeToken(); _ = _1
        *res = _1.Value
    case tkSTRING:
        // @ STRING
        _1 := p.ConsumeToken(); _ = _1
        *res = _1.Value
    default:
        p.ErrorUnexpected("symbol-expression-value")
    }
    return
}

/** ** **
  signature ->
      (
        '-*'
      )? registers? (
        '=>' registers?
      )? (
        '!' registers?
      )?
 ** ** **/
func (p *Parser) _parseSignature() (ret Value) {
    res := &ret; _ = res
    // RULE: signature -> _signature_42o _signature_43o _signature_46o _signature_49o
    v := &Vec{NIL, NIL, NIL, NIL}
    switch p.PeekToken().Kind {
    case tkMIAS, tkREGISTER, tkEQGT, tkEX, tkRP:
        // @ _signature_42o _signature_43o _signature_46o _signature_49o
        var _1 Value; _ = _1
        for {
            res := &_1; _ = res
            // RULE: _signature_42o -> _signature_41g?
            // RULE: _signature_41g -> '-*'
            switch p.PeekToken().Kind {
            case tkMIAS:
                // @ '-*'
                _1 := p.ConsumeToken(); _ = _1
                v.SetAt(3, Int(1))
            case tkREGISTER, tkEQGT, tkEX, tkRP:
                // NOP
            default:
                p.ErrorUnexpected("'-*', registers, '=>', '!', etc.")
            }
            break
        }

        // _signature_42o @ _signature_43o _signature_46o _signature_49o
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _signature_43o -> registers
            // RULE: _signature_43o -> 
            switch p.PeekToken().Kind {
            case tkREGISTER:
                // @ registers
                _1 := p._parseRegisters(); _ = _1
                *res = _1 // DEFAULT OPT ACTION
            case tkEQGT, tkEX, tkRP:
                // NOP
            default:
                p.ErrorUnexpected("registers, '=>', '!', etc.")
            }
            break
        }
        if _2 != nil { v.SetAt(0, _2) }

        // _signature_42o _signature_43o @ _signature_46o _signature_49o
        var _3 Value; _ = _3
        for {
            res := &_3; _ = res
            // RULE: _signature_46o -> _signature_45g?
            // RULE: _signature_45g -> '=>' _signature_44o
            switch p.PeekToken().Kind {
            case tkEQGT:
                // @ '=>' _signature_44o
                _1 := p.ConsumeToken(); _ = _1

                // '=>' @ _signature_44o
                var _2 Value; _ = _2
                for {
                    res := &_2; _ = res
                    // RULE: _signature_44o -> registers
                    // RULE: _signature_44o -> 
                    switch p.PeekToken().Kind {
                    case tkREGISTER:
                        // @ registers
                        _1 := p._parseRegisters(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                    case tkEX, tkRP:
                        // NOP
                    default:
                        p.ErrorUnexpected("registers, etc.")
                    }
                    break
                }
                if _2 != nil { v.SetAt(1, _2) }
            case tkEX, tkRP:
                // NOP
            default:
                p.ErrorUnexpected("'=>', '!', etc.")
            }
            break
        }

        // _signature_42o _signature_43o _signature_46o @ _signature_49o
        var _4 Value; _ = _4
        for {
            res := &_4; _ = res
            // RULE: _signature_49o -> _signature_48g?
            // RULE: _signature_48g -> '!' _signature_47o
            switch p.PeekToken().Kind {
            case tkEX:
                // @ '!' _signature_47o
                _1 := p.ConsumeToken(); _ = _1

                // '!' @ _signature_47o
                var _2 Value; _ = _2
                for {
                    res := &_2; _ = res
                    // RULE: _signature_47o -> registers
                    // RULE: _signature_47o -> 
                    switch p.PeekToken().Kind {
                    case tkREGISTER:
                        // @ registers
                        _1 := p._parseRegisters(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                    case tkRP:
                        // NOP
                    default:
                        p.ErrorUnexpected("registers, etc.")
                    }
                    break
                }
                if _2 != nil { v.SetAt(2, _2)
                                         } else { v.SetAt(2, &Vec{}) }
            case tkRP:
                // NOP
            default:
                p.ErrorUnexpected("'!', etc.")
            }
            break
        }
        *res = v
    default:
        p.ErrorUnexpected("signature, etc.")
    }
    return
}

/** ** **
  registers ->
      REGISTER (
        REGISTER
      )*
 ** ** **/
func (p *Parser) _parseRegisters() (ret Value) {
    res := &ret; _ = res
    // RULE: registers -> REGISTER _registers_51r
    switch p.PeekToken().Kind {
    case tkREGISTER:
        // @ REGISTER _registers_51r
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{_1.Value}

        // REGISTER @ _registers_51r
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _registers_51r -> _registers_50g*
            // RULE: _registers_50g -> REGISTER
            switch p.PeekToken().Kind {
            case tkREGISTER:
                // @ REGISTER
                _1 := p.ConsumeToken(); _ = _1
                v.Push(_1.Value)

                continue
            case tkEQGT, tkEX, tkRP:
                // NOP
            default:
                p.ErrorUnexpected("register, etc.")
            }
            break
        }
        *res = v
    default:
        p.ErrorUnexpected("registers")
    }
    return
}

/** ** **
  block ->
      '{' program '}'
    | '={' program '}'
 ** ** **/
func (p *Parser) _parseBlock() (ret Value) {
    res := &ret; _ = res
    // RULE: block -> '{' program '}'
    // RULE: block -> '={' program '}'
    switch p.PeekToken().Kind {
    case tkLC:
        // @ '{' program '}'
        _1 := p.ConsumeToken(); _ = _1

        // '{' @ program '}'
        _2 := p._parseProgram(); _ = _2

        // '{' program @ '}'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRC {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'}'")
        }
        v := _2.(*Vec); v.SetAt(0, KwProg.ToId(_1)); *res = v
    case tkEQLC:
        // @ '={' program '}'
        _1 := p.ConsumeToken(); _ = _1

        // '={' @ program '}'
        _2 := p._parseProgram(); _ = _2

        // '={' program @ '}'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRC {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'}'")
        }
        *res = _2
    default:
        p.ErrorUnexpected("block")
    }
    return
}

/** ** **
  proc_call ->
      CONDDOT? identifierp '(' signature ')'
 ** ** **/
func (p *Parser) _parseProcCall() (ret Value) {
    res := &ret; _ = res
    // RULE: proc_call -> _proc_call_52o identifierp '(' signature ')'
    switch p.PeekToken().Kind {
    case tkCONDDOT, tkIDENTIFIERP:
        // @ _proc_call_52o identifierp '(' signature ')'
        var _1 *Token; _ = _1
        for {
            res := &_1; _ = res
            // RULE: _proc_call_52o -> CONDDOT
            // RULE: _proc_call_52o -> 
            switch p.PeekToken().Kind {
            case tkCONDDOT:
                // @ CONDDOT
                _1 := p.ConsumeToken(); _ = _1
                *res = _1 // DEFAULT OPT ACTION
            case tkIDENTIFIERP:
                *res = NILTK
            default:
                p.ErrorUnexpected("CONDDOT, identifier")
            }
            break
        }

        // _proc_call_52o @ identifierp '(' signature ')'
        _2 := p._parseIdentifierp(); _ = _2

        // _proc_call_52o identifierp @ '(' signature ')'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkLP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'('")
        }

        // _proc_call_52o identifierp '(' @ signature ')'
        _4 := p._parseSignature(); _ = _4

        // _proc_call_52o identifierp '(' signature @ ')'
        _5 := p.PeekToken(); _ = _5
        if _5.Kind == tkRP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("')'")
        }
        *res = &Vec{KwCallproc.ToId(_3), _2, _1.Value, _4, KwCall}
    default:
        p.ErrorUnexpected("proc-call")
    }
    return
}

/** ** **
  context_expression ->
      (
        decorated_register
      | memory_access
      | explicit_value
      | '@-' primitive
      ) (
        POSTFIX_OPERATOR
      | BINARY_OPERATOR operand
      | DOT_OPERATOR dot_operand
      )*
 ** ** **/
func (p *Parser) _parseContextExpression() (ret Value) {
    res := &ret; _ = res
    // RULE: context_expression -> _context_expression_53g _context_expression_55r
    v := &Vec{KwWith.ToId(p.PeekToken())}
    switch p.PeekToken().Kind {
    case tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
        // @ _context_expression_53g _context_expression_55r
        var _1 Value; _ = _1
        for {
            res := &_1; _ = res
            // RULE: _context_expression_53g -> decorated_register
            // RULE: _context_expression_53g -> memory_access
            // RULE: _context_expression_53g -> explicit_value
            // RULE: _context_expression_53g -> '@-' primitive
            switch p.PeekToken().Kind {
            case tkREGISTER:
                // @ decorated_register
                _1 := p._parseDecoratedRegister(); _ = _1
                v = _1.(*Vec)
            case tkLS:
                // @ memory_access
                _1 := p._parseMemoryAccess(); _ = _1
                v.Push(_1)
            case tkDLAT, tkDLDLAT:
                // @ explicit_value
                _1 := p._parseExplicitValue(); _ = _1
                v.Push(_1)
            case tkATMI:
                // @ '@-' primitive
                _1 := p.ConsumeToken(); _ = _1

                // '@-' @ primitive
                _2 := p._parsePrimitive(); _ = _2
                v.Push(p.cc.KwRegA.ToId(_1), &Vec{_atopid(_2, _1), _2})
            default:
                p.ErrorUnexpected("register, memory-access, explicit-value, '@-'")
            }
            break
        }

        // _context_expression_53g @ _context_expression_55r
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _context_expression_55r -> _context_expression_54g*
            // RULE: _context_expression_54g -> POSTFIX_OPERATOR
            // RULE: _context_expression_54g -> BINARY_OPERATOR operand
            // RULE: _context_expression_54g -> DOT_OPERATOR dot_operand
            switch p.PeekToken().Kind {
            case tkPOSTFIX_OPERATOR:
                // @ POSTFIX_OPERATOR
                _1 := p.ConsumeToken(); _ = _1
                v.Push(&Vec{_1.Value, NIL})

                continue
            case tkBINARY_OPERATOR:
                // @ BINARY_OPERATOR operand
                _1 := p.ConsumeToken(); _ = _1

                // BINARY_OPERATOR @ operand
                _2 := p._parseOperand(); _ = _2
                v.Push(&Vec{_1.Value, _2})

                continue
            case tkDOT_OPERATOR:
                // @ DOT_OPERATOR dot_operand
                _1 := p.ConsumeToken(); _ = _1

                // DOT_OPERATOR @ dot_operand
                _2 := p._parseDotOperand(); _ = _2
                v.Push(&Vec{_1.Value, _2})

                continue
            case tkSC, tkEOF, tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkRC, tkRS:
                // NOP
            default:
                p.ErrorUnexpected("POSTFIX-OPERATOR, BINARY-OPERATOR, '.', etc.")
            }
            break
        }
        *res = v
    default:
        p.ErrorUnexpected("context-expression")
    }
    return
}

/** ** **
  operand ->
      primitive (
        ':' primitive
      )?
 ** ** **/
func (p *Parser) _parseOperand() (ret Value) {
    res := &ret; _ = res
    // RULE: operand -> primitive _operand_57o
    switch p.PeekToken().Kind {
    case tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ primitive _operand_57o
        _1 := p._parsePrimitive(); _ = _1
        v := _1

        // primitive @ _operand_57o
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _operand_57o -> _operand_56g?
            // RULE: _operand_56g -> ':' primitive
            switch p.PeekToken().Kind {
            case tkCL:
                // @ ':' primitive
                _1 := p.ConsumeToken(); _ = _1

                // ':' @ primitive
                _2 := p._parsePrimitive(); _ = _2
                v = &Vec{KwTpl.ToId(_1), v, _2}
            case tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkPOSTFIX_OPERATOR, tkBINARY_OPERATOR, tkDOT_OPERATOR, tkSC, tkEOF, tkRC, tkATMI, tkRS:
                // NOP
            default:
                p.ErrorUnexpected("':', etc.")
            }
            break
        }
        *res = v
    default:
        p.ErrorUnexpected("operand")
    }
    return
}

/** ** **
  primitive ->
      CONDITION
    | decorated_register
    | memory_access
    | data_value
    | block
 ** ** **/
func (p *Parser) _parsePrimitive() (ret Value) {
    res := &ret; _ = res
    // RULE: primitive -> CONDITION
    // RULE: primitive -> decorated_register
    // RULE: primitive -> memory_access
    // RULE: primitive -> data_value
    // RULE: primitive -> block
    switch p.PeekToken().Kind {
    case tkCONDITION:
        // @ CONDITION
        _1 := p.ConsumeToken(); _ = _1
        *res = _1.Value
    case tkREGISTER:
        // @ decorated_register
        _1 := p._parseDecoratedRegister(); _ = _1
        *res = _maybeunwrapwith(_1)
    case tkLS:
        // @ memory_access
        _1 := p._parseMemoryAccess(); _ = _1
        *res = _1
    case tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ data_value
        _1 := p._parseDataValue(); _ = _1
        *res = _1
    case tkLC, tkEQLC:
        // @ block
        _1 := p._parseBlock(); _ = _1
        *res = _1
    default:
        p.ErrorUnexpected("primitive")
    }
    return
}

/** ** **
  decorated_register ->
      REGISTER (
        '-@' primitive
      )?
 ** ** **/
func (p *Parser) _parseDecoratedRegister() (ret Value) {
    res := &ret; _ = res
    // RULE: decorated_register -> REGISTER _decorated_register_59o
    switch p.PeekToken().Kind {
    case tkREGISTER:
        // @ REGISTER _decorated_register_59o
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{KwWith.ToId(_1), _1.Value}

        // REGISTER @ _decorated_register_59o
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _decorated_register_59o -> _decorated_register_58g?
            // RULE: _decorated_register_58g -> '-@' primitive
            switch p.PeekToken().Kind {
            case tkMIAT:
                // @ '-@' primitive
                _1 := p.ConsumeToken(); _ = _1

                // '-@' @ primitive
                _2 := p._parsePrimitive(); _ = _2
                v.Push(&Vec{_atopid(_2, _1), _2})
            case tkCL, tkPOSTFIX_OPERATOR, tkBINARY_OPERATOR, tkDOT_OPERATOR, tkCONDITION, tkLC, tkEQLC, tkREGISTER, tkLS, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkSC, tkEOF, tkATMI, tkRC, tkRS:
                // NOP
            default:
                p.ErrorUnexpected("'-@', etc.")
            }
            break
        }
        *res = v
    default:
        p.ErrorUnexpected("register")
    }
    return
}

/** ** **
  memory_access ->
      '[' (
        context_expression
      | constexpr
      )* ']'
 ** ** **/
func (p *Parser) _parseMemoryAccess() (ret Value) {
    res := &ret; _ = res
    // RULE: memory_access -> '[' _memory_access_61r ']'
    switch p.PeekToken().Kind {
    case tkLS:
        // @ '[' _memory_access_61r ']'
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{KwMem.ToId(_1)}

        // '[' @ _memory_access_61r ']'
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _memory_access_61r -> _memory_access_60g*
            // RULE: _memory_access_60g -> context_expression
            // RULE: _memory_access_60g -> constexpr
            switch p.PeekToken().Kind {
            case tkATMI, tkREGISTER, tkLS, tkDLAT, tkDLDLAT:
                // @ context_expression
                _1 := p._parseContextExpression(); _ = _1
                v.Push(_maybeunwrapwith(_1))

                continue
            case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ constexpr
                _1 := p._parseConstexpr(); _ = _1
                v.Push(_1)

                continue
            case tkRS:
                // NOP
            default:
                p.ErrorUnexpected("context-expression, constexpr, ']'")
            }
            break
        }

        // '[' _memory_access_61r @ ']'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRS {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("']'")
        }
        *res = v
    default:
        p.ErrorUnexpected("memory-access")
    }
    return
}

/** ** **
  dot_operand ->
      proc_call
    | decorated_register
    | block
 ** ** **/
func (p *Parser) _parseDotOperand() (ret Value) {
    res := &ret; _ = res
    // RULE: dot_operand -> proc_call
    // RULE: dot_operand -> decorated_register
    // RULE: dot_operand -> block
    switch p.PeekToken().Kind {
    case tkCONDDOT, tkIDENTIFIERP:
        // @ proc_call
        _1 := p._parseProcCall(); _ = _1
        *res = _1
    case tkREGISTER:
        // @ decorated_register
        _1 := p._parseDecoratedRegister(); _ = _1
        *res = _1
    case tkLC, tkEQLC:
        // @ block
        _1 := p._parseBlock(); _ = _1
        *res = _1
    default:
        p.ErrorUnexpected("operand")
    }
    return
}

/** ** **
  explicit_value ->
      '$@' constval
    | '$$@' constval
 ** ** **/
func (p *Parser) _parseExplicitValue() (ret Value) {
    res := &ret; _ = res
    // RULE: explicit_value -> '$@' constval
    // RULE: explicit_value -> '$$@' constval
    switch p.PeekToken().Kind {
    case tkDLAT:
        // @ '$@' constval
        _1 := p.ConsumeToken(); _ = _1

        // '$@' @ constval
        _2 := p._parseConstval(); _ = _2
        *res = _2
    case tkDLDLAT:
        // @ '$$@' constval
        _1 := p.ConsumeToken(); _ = _1

        // '$$@' @ constval
        _2 := p._parseConstval(); _ = _2
        *res = &Vec{KwValueOf.ToId(_1), _2}
    default:
        p.ErrorUnexpected("explicit-value")
    }
    return
}

/** ** **
  constexpr ->
      iexpr
 ** ** **/
func (p *Parser) _parseConstexpr() (ret Value) {
    res := &ret; _ = res
    // RULE: constexpr -> iexpr
    here := p.PeekToken()
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ iexpr
        _1 := p._parseIexpr(); _ = _1
        *res = _constexpr(_1, here)
    default:
        p.ErrorUnexpected("constexpr")
    }
    return
}

/** ** **
  constval ->
      ival
 ** ** **/
func (p *Parser) _parseConstval() (ret Value) {
    res := &ret; _ = res
    // RULE: constval -> ival
    here := p.PeekToken()
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ ival
        _1 := p._parseIval(); _ = _1
        *res = _constexpr(_1, here)
    default:
        p.ErrorUnexpected("constval")
    }
    return
}

/** ** **
  iexpr ->
      ival (
        BINARY_OPERATOR ival
      )*
 ** ** **/
func (p *Parser) _parseIexpr() (ret Value) {
    res := &ret; _ = res
    // RULE: iexpr -> ival _iexpr_63r
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
        // @ ival _iexpr_63r
        _1 := p._parseIval(); _ = _1
        v := []Value{_1}

        // ival @ _iexpr_63r
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _iexpr_63r -> _iexpr_62g*
            // RULE: _iexpr_62g -> BINARY_OPERATOR ival
            switch p.PeekToken().Kind {
            case tkBINARY_OPERATOR:
                // @ BINARY_OPERATOR ival
                _1 := p.ConsumeToken(); _ = _1

                // BINARY_OPERATOR @ ival
                _2 := p._parseIval(); _ = _2
                v = p.cc.orderByPrec(v, _1.Value.(*Identifier), _2)

                continue
            case tkRP, tkIDENTIFIER, tkLABEL_NAME, tkSC, tkEOF, tkLS, tkLC, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkATMI, tkREGISTER, tkRS, tkREST, tkRC:
                // NOP
            default:
                p.ErrorUnexpected("BINARY-OPERATOR, etc.")
            }
            break
        }
        *res = p.cc.orderByPrec(v, idOpLast, nil)[0]
    default:
        p.ErrorUnexpected("constexpr")
    }
    return
}

/** ** **
  ival ->
      INTEGER
    | STRING
    | RESERVED
    | IDENTIFIER (
        '.-' IDENTIFIER (
          '.-' IDENTIFIER
        )*
      )?
    | IDENTIFIERP '(' (
        iexpr
      )* ')'
    | '(' iexpr ')'
    | PREFIX_OPERATOR ival
 ** ** **/
func (p *Parser) _parseIval() (ret Value) {
    res := &ret; _ = res
    // RULE: ival -> INTEGER
    // RULE: ival -> STRING
    // RULE: ival -> RESERVED
    // RULE: ival -> IDENTIFIER _ival_67o
    // RULE: ival -> IDENTIFIERP '(' _ival_69r ')'
    // RULE: ival -> '(' iexpr ')'
    // RULE: ival -> PREFIX_OPERATOR ival
    switch p.PeekToken().Kind {
    case tkINTEGER:
        // @ INTEGER
        _1 := p.ConsumeToken(); _ = _1
        *res = _1.Value
    case tkSTRING:
        // @ STRING
        _1 := p.ConsumeToken(); _ = _1
        *res = _1.Value
    case tkRESERVED:
        // @ RESERVED
        _1 := p.ConsumeToken(); _ = _1
        *res = _1.Value
    case tkIDENTIFIER:
        // @ IDENTIFIER _ival_67o
        _1 := p.ConsumeToken(); _ = _1
        v := _1.Value

        // IDENTIFIER @ _ival_67o
        var _2 Value; _ = _2
        for {
            res := &_2; _ = res
            // RULE: _ival_67o -> _ival_66g?
            // RULE: _ival_66g -> '.-' IDENTIFIER _ival_65r
            switch p.PeekToken().Kind {
            case tkDTMI:
                // @ '.-' IDENTIFIER _ival_65r
                _1 := p.ConsumeToken(); _ = _1

                // '.-' @ IDENTIFIER _ival_65r
                _2 := p.PeekToken(); _ = _2
                if _2.Kind == tkIDENTIFIER {
                    p.ConsumeToken()
                } else {
                    p.ErrorUnexpected("identifier")
                }
                w := &Vec{KwField.ToId(_1), v, _2.Value}

                // '.-' IDENTIFIER @ _ival_65r
                var _3 Value; _ = _3
                for {
                    res := &_3; _ = res
                    // RULE: _ival_65r -> _ival_64g*
                    // RULE: _ival_64g -> '.-' IDENTIFIER
                    switch p.PeekToken().Kind {
                    case tkDTMI:
                        // @ '.-' IDENTIFIER
                        _1 := p.ConsumeToken(); _ = _1

                        // '.-' @ IDENTIFIER
                        _2 := p.PeekToken(); _ = _2
                        if _2.Kind == tkIDENTIFIER {
                            p.ConsumeToken()
                        } else {
                            p.ErrorUnexpected("identifier")
                        }
                        w.Push(_2.Value)

                        continue
                    case tkBINARY_OPERATOR, tkCL, tkIDENTIFIER, tkLABEL_NAME, tkSC, tkEOF, tkLS, tkLC, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkPOSTFIX_OPERATOR, tkDOT_OPERATOR, tkRP, tkATMI, tkREGISTER, tkAT, tkCONDITION, tkEQLC, tkREST, tkRC, tkRS:
                        // NOP
                    default:
                        p.ErrorUnexpected("'.-', etc.")
                    }
                    break
                }
                v = w
            case tkBINARY_OPERATOR, tkCL, tkIDENTIFIER, tkLABEL_NAME, tkSC, tkEOF, tkLS, tkLC, tkDLAT, tkDLDLAT, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR, tkPOSTFIX_OPERATOR, tkDOT_OPERATOR, tkRP, tkATMI, tkREGISTER, tkAT, tkCONDITION, tkEQLC, tkREST, tkRC, tkRS:
                // NOP
            default:
                p.ErrorUnexpected("'.-', etc.")
            }
            break
        }
        *res = v
    case tkIDENTIFIERP:
        // @ IDENTIFIERP '(' _ival_69r ')'
        _1 := p.ConsumeToken(); _ = _1
        v := &Vec{ _1.Value }

        // IDENTIFIERP @ '(' _ival_69r ')'
        _2 := p.PeekToken(); _ = _2
        if _2.Kind == tkLP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("'('")
        }

        // IDENTIFIERP '(' @ _ival_69r ')'
        var _3 Value; _ = _3
        for {
            res := &_3; _ = res
            // RULE: _ival_69r -> _ival_68g*
            // RULE: _ival_68g -> iexpr
            switch p.PeekToken().Kind {
            case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkPREFIX_OPERATOR:
                // @ iexpr
                _1 := p._parseIexpr(); _ = _1
                v.Push(_1)

                continue
            case tkRP:
                // NOP
            default:
                p.ErrorUnexpected("constexpr, ')'")
            }
            break
        }

        // IDENTIFIERP '(' _ival_69r @ ')'
        _4 := p.PeekToken(); _ = _4
        if _4.Kind == tkRP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("')'")
        }
        *res = v
    case tkLP:
        // @ '(' iexpr ')'
        _1 := p.ConsumeToken(); _ = _1

        // '(' @ iexpr ')'
        _2 := p._parseIexpr(); _ = _2

        // '(' iexpr @ ')'
        _3 := p.PeekToken(); _ = _3
        if _3.Kind == tkRP {
            p.ConsumeToken()
        } else {
            p.ErrorUnexpected("')'")
        }
        *res = _2
    case tkPREFIX_OPERATOR:
        // @ PREFIX_OPERATOR ival
        _1 := p.ConsumeToken(); _ = _1

        // PREFIX_OPERATOR @ ival
        _2 := p._parseIval(); _ = _2
        *res = &Vec{ _1.Value, _2 }
    default:
        p.ErrorUnexpected("constval")
    }
    return
}

/** ** **
  identifier ->
      IDENTIFIER
 ** ** **/
func (p *Parser) _parseIdentifier() (ret Value) {
    res := &ret; _ = res
    // RULE: identifier -> IDENTIFIER
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
        // @ IDENTIFIER
        _1 := p.ConsumeToken(); _ = _1
        *res = _constexpr(_1.Value, _1)
    default:
        p.ErrorUnexpected("identifier")
    }
    return
}

/** ** **
  identifierp ->
      IDENTIFIERP
 ** ** **/
func (p *Parser) _parseIdentifierp() (ret Value) {
    res := &ret; _ = res
    // RULE: identifierp -> IDENTIFIERP
    switch p.PeekToken().Kind {
    case tkIDENTIFIERP:
        // @ IDENTIFIERP
        _1 := p.ConsumeToken(); _ = _1
        *res = _constexpr(_1.Value, _1)
    default:
        p.ErrorUnexpected("identifier")
    }
    return
}

/** ** **
  label_name ->
      LABEL_NAME
 ** ** **/
func (p *Parser) _parseLabelName() (ret Value) {
    res := &ret; _ = res
    // RULE: label_name -> LABEL_NAME
    switch p.PeekToken().Kind {
    case tkLABEL_NAME:
        // @ LABEL_NAME
        _1 := p.ConsumeToken(); _ = _1
        *res = _constexpr(_1.Value, _1)
    default:
        p.ErrorUnexpected("label-name")
    }
    return
}
