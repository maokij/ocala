// GENERATED BY llpg
//lint:file-ignore U1000 generated code
//lint:file-ignore SA4004 generated code

package core

const (
    tkEOF = iota
    tkSCANERROR
    tkSC
    tkCL
    tkREST
    tkEQ
    tkLS
    tkRS
    tkLP
    tkRP
    tkMACRO
    tkPROC
    tkCONST
    tkDATA
    tkMODULE
    tkSTRUCT
    tkLC
    tkRC
    tkBOP
    tkPELC
    tkIDENTIFIER
    tkSTRING
    tkMIAS
    tkEQGT
    tkEX
    tkREG
    tkEQLC
    tkCONDDOT
    tkATMI
    tkUOP
    tkDOP
    tkCOND
    tkMIAT
    tkDLMI
    tkDLDLMI
    tkDTMI
    tkINTEGER
    tkRESERVED
    tkIDENTIFIERP
    tkAOP
    tkLABEL
)

var tokenKinds = map[string]int32{
    ";": tkSC,
    ":": tkCL,
    "=": tkEQ,
    "[": tkLS,
    "]": tkRS,
    "(": tkLP,
    ")": tkRP,
    "{": tkLC,
    "}": tkRC,
    "%{": tkPELC,
    "-*": tkMIAS,
    "=>": tkEQGT,
    "!": tkEX,
    "={": tkEQLC,
    "@-": tkATMI,
    "-@": tkMIAT,
    "$-": tkDLMI,
    "$$-": tkDLDLMI,
    ".-": tkDTMI,
}

var tokenLabels = [...]string{
    "EOF", // tkEOF
    "SCANERROR", // tkSCANERROR
    "';'", // tkSC
    "':'", // tkCL
    "REST", // tkREST
    "'='", // tkEQ
    "'['", // tkLS
    "']'", // tkRS
    "'('", // tkLP
    "')'", // tkRP
    "MACRO", // tkMACRO
    "PROC", // tkPROC
    "CONST", // tkCONST
    "DATA", // tkDATA
    "MODULE", // tkMODULE
    "STRUCT", // tkSTRUCT
    "'{'", // tkLC
    "'}'", // tkRC
    "BOP", // tkBOP
    "'%{'", // tkPELC
    "IDENTIFIER", // tkIDENTIFIER
    "STRING", // tkSTRING
    "'-*'", // tkMIAS
    "'=>'", // tkEQGT
    "'!'", // tkEX
    "REG", // tkREG
    "'={'", // tkEQLC
    "CONDDOT", // tkCONDDOT
    "'@-'", // tkATMI
    "UOP", // tkUOP
    "DOP", // tkDOP
    "COND", // tkCOND
    "'-@'", // tkMIAT
    "'$-'", // tkDLMI
    "'$$-'", // tkDLDLMI
    "'.-'", // tkDTMI
    "INTEGER", // tkINTEGER
    "RESERVED", // tkRESERVED
    "IDENTIFIERP", // tkIDENTIFIERP
    "AOP", // tkAOP
    "LABEL", // tkLABEL
}

var reservedWords = map[string]int32{
  "macro": tkMACRO,
  "proc": tkPROC,
  "const": tkCONST,
  "data": tkDATA,
  "module": tkMODULE,
  "struct": tkSTRUCT,
  "_": tkRESERVED,
  "_BEG": tkRESERVED,
  "_END": tkRESERVED,
  "_COND": tkRESERVED,
  "__PROC__": tkRESERVED,
}

func (p *Parser) _parse() (res Value, ok bool) {
    res = p._parseProgram()
    if (p.PeekToken().Kind != tkEOF) {
         p.RaiseParseError(p.PeekToken(), "EOF")
    }
    ok = true
    return
}

/** ** **
  program ->
      stmt? (
        ';' stmt?
      )*
 ** ** **/
func (p *Parser) _parseProgram() (res Value) {
    // RULE: program -> _program_1o _program_4r
    v := &Vec{KwBlock.ToId(_here(p))}
    switch p.PeekToken().Kind {
    case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI, tkSC, tkEOF, tkRC:
            // @ _program_1o _program_4r
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _program_1o -> stmt
                // RULE: _program_1o -> 
                switch p.PeekToken().Kind {
                case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI:
                        // @ stmt
                        _1 := p._parseStmt(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkEOF, tkRC:
                        // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-', ';', EOF, '}'")
                }
                break
            }
            if _1 != nil { v.Push(_1) }
    
            // _program_1o @ _program_4r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _program_4r -> _program_3g*
                // RULE: _program_3g -> ';' _program_2o
                switch p.PeekToken().Kind {
                case tkSC:
                        // @ ';' _program_2o
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ';' @ _program_2o
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _program_2o -> stmt
                            // RULE: _program_2o -> 
                            switch p.PeekToken().Kind {
                            case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI:
                                    // @ stmt
                                    _1 := p._parseStmt(); _ = _1
                                    *res = _1 // DEFAULT OPT ACTION
                            case tkSC, tkEOF, tkRC:
                                    // NOP
                            default:
                                p.RaiseParseError(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-', ';', EOF, '}'")
                            }
                            break
                        }
                        if _2 != nil { v.Push(_2) }
                
                        continue
                case tkEOF, tkRC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "';', EOF, '}'")
                }
                break
            }
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-', ';', EOF, '}'")
    }
    return
}

/** ** **
  stmt ->
      MACRO identifierp '(' (
        identifier
      | label ':' dataexpr
      )* REST? ')' (
        '[' (
          identifier (
            '=' symexpr
          )?
        )* ']'
      )? block
    | PROC identifierp '(' sig ')' block
    | CONST (
        identifier
      | identifierp '(' (
          identifier
        | label ':' dataexpr
        )* ')'
      ) '=' dataexpr
    | DATA (
        identifier (
          '=' (
            identifier
          | struct
          )
        )?
      | struct
      ) databody
    | MODULE identifier block
    | label ':'
    | expr
 ** ** **/
func (p *Parser) _parseStmt() (res Value) {
    // RULE: stmt -> MACRO identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o block
    // RULE: stmt -> PROC identifierp '(' sig ')' block
    // RULE: stmt -> CONST _stmt_16g '=' dataexpr
    // RULE: stmt -> DATA _stmt_20g databody
    // RULE: stmt -> MODULE identifier block
    // RULE: stmt -> label ':'
    // RULE: stmt -> expr
    switch p.PeekToken().Kind {
    case tkMACRO:
            // @ MACRO identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o block
            _1 := p.ConsumeToken(); _ = _1
    
            // MACRO @ identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o block
            _2 := p._parseIdentifierp(); _ = _2
            v := &Vec{}; w := &Vec{}
    
            // MACRO identifierp @ '(' _stmt_6r _stmt_7o ')' _stmt_13o block
            if p.PeekToken().Kind != tkLP {
                p.RaiseParseError(p.PeekToken(), "'('")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // MACRO identifierp '(' @ _stmt_6r _stmt_7o ')' _stmt_13o block
            var _4 Value; _ = _4
            for {
                res := &_4; _ = res
                // RULE: _stmt_6r -> _stmt_5g*
                // RULE: _stmt_5g -> identifier
                // RULE: _stmt_5g -> label ':' dataexpr
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        v.Push(&Vec{_1, NIL})
                
                        continue
                case tkLABEL:
                        // @ label ':' dataexpr
                        _1 := p._parseLabel(); _ = _1
                
                        // label @ ':' dataexpr
                        if p.PeekToken().Kind != tkCL {
                            p.RaiseParseError(p.PeekToken(), "':'")
                        }
                        _2 := p.ConsumeToken(); _ = _2
                
                        // label ':' @ dataexpr
                        _3 := p._parseDataexpr(); _ = _3
                        v.Push(&Vec{_1, _3})
                
                        continue
                case tkREST, tkRP:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "IDENTIFIER, LABEL, REST, ')'")
                }
                break
            }
    
            // MACRO identifierp '(' _stmt_6r @ _stmt_7o ')' _stmt_13o block
            var _5 *Token; _ = _5
            for {
                res := &_5; _ = res
                // RULE: _stmt_7o -> REST
                // RULE: _stmt_7o -> 
                switch p.PeekToken().Kind {
                case tkREST:
                        // @ REST
                        _1 := p.ConsumeToken(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkRP:
                        *res = NILTK
                default:
                    p.RaiseParseError(p.PeekToken(), "REST, ')'")
                }
                break
            }
    
            // MACRO identifierp '(' _stmt_6r _stmt_7o @ ')' _stmt_13o block
            if p.PeekToken().Kind != tkRP {
                p.RaiseParseError(p.PeekToken(), "')'")
            }
            _6 := p.ConsumeToken(); _ = _6
    
            // MACRO identifierp '(' _stmt_6r _stmt_7o ')' @ _stmt_13o block
            var _7 Value; _ = _7
            for {
                res := &_7; _ = res
                // RULE: _stmt_13o -> _stmt_12g?
                // RULE: _stmt_12g -> '[' _stmt_11r ']'
                switch p.PeekToken().Kind {
                case tkLS:
                        // @ '[' _stmt_11r ']'
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '[' @ _stmt_11r ']'
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _stmt_11r -> _stmt_10g*
                            // RULE: _stmt_10g -> identifier _stmt_9o
                            switch p.PeekToken().Kind {
                            case tkIDENTIFIER:
                                    // @ identifier _stmt_9o
                                    _1 := p._parseIdentifier(); _ = _1
                                    l := _1; r := Value(NIL)
                            
                                    // identifier @ _stmt_9o
                                    var _2 Value; _ = _2
                                    for {
                                        res := &_2; _ = res
                                        // RULE: _stmt_9o -> _stmt_8g?
                                        // RULE: _stmt_8g -> '=' symexpr
                                        switch p.PeekToken().Kind {
                                        case tkEQ:
                                                // @ '=' symexpr
                                                _1 := p.ConsumeToken(); _ = _1
                                        
                                                // '=' @ symexpr
                                                _2 := p._parseSymexpr(); _ = _2
                                                r = _2
                                        case tkIDENTIFIER, tkRS:
                                            // NOP
                                        default:
                                            p.RaiseParseError(p.PeekToken(), "'=', IDENTIFIER, ']'")
                                        }
                                        break
                                    }
                                    w.Push(l, r)
                            
                                    continue
                            case tkRS:
                                // NOP
                            default:
                                p.RaiseParseError(p.PeekToken(), "IDENTIFIER, ']'")
                            }
                            break
                        }
                
                        // '[' _stmt_11r @ ']'
                        if p.PeekToken().Kind != tkRS {
                            p.RaiseParseError(p.PeekToken(), "']'")
                        }
                        _3 := p.ConsumeToken(); _ = _3
                case tkLC, tkEQLC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'[', '{', '={'")
                }
                break
            }
    
            // MACRO identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o @ block
            _8 := p._parseBlock(); _ = _8
            res = &Vec{KwMacro.ToId(_1), _2, v, w, _5.Value, _8}
    case tkPROC:
            // @ PROC identifierp '(' sig ')' block
            _1 := p.ConsumeToken(); _ = _1
    
            // PROC @ identifierp '(' sig ')' block
            _2 := p._parseIdentifierp(); _ = _2
    
            // PROC identifierp @ '(' sig ')' block
            if p.PeekToken().Kind != tkLP {
                p.RaiseParseError(p.PeekToken(), "'('")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // PROC identifierp '(' @ sig ')' block
            _4 := p._parseSig(); _ = _4
    
            // PROC identifierp '(' sig @ ')' block
            if p.PeekToken().Kind != tkRP {
                p.RaiseParseError(p.PeekToken(), "')'")
            }
            _5 := p.ConsumeToken(); _ = _5
    
            // PROC identifierp '(' sig ')' @ block
            _6 := p._parseBlock(); _ = _6
            res = &Vec{KwProc.ToId(_1), _2, _4, _6}
    case tkCONST:
            // @ CONST _stmt_16g '=' dataexpr
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{}
    
            // CONST @ _stmt_16g '=' dataexpr
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _stmt_16g -> identifier
                // RULE: _stmt_16g -> identifierp '(' _stmt_15r ')'
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        *res = _1
                case tkIDENTIFIERP:
                        // @ identifierp '(' _stmt_15r ')'
                        _1 := p._parseIdentifierp(); _ = _1
                
                        // identifierp @ '(' _stmt_15r ')'
                        if p.PeekToken().Kind != tkLP {
                            p.RaiseParseError(p.PeekToken(), "'('")
                        }
                        _2 := p.ConsumeToken(); _ = _2
                
                        // identifierp '(' @ _stmt_15r ')'
                        var _3 Value; _ = _3
                        for {
                            res := &_3; _ = res
                            // RULE: _stmt_15r -> _stmt_14g*
                            // RULE: _stmt_14g -> identifier
                            // RULE: _stmt_14g -> label ':' dataexpr
                            switch p.PeekToken().Kind {
                            case tkIDENTIFIER:
                                    // @ identifier
                                    _1 := p._parseIdentifier(); _ = _1
                                    v.Push(&Vec{_1, NIL})
                            
                                    continue
                            case tkLABEL:
                                    // @ label ':' dataexpr
                                    _1 := p._parseLabel(); _ = _1
                            
                                    // label @ ':' dataexpr
                                    if p.PeekToken().Kind != tkCL {
                                        p.RaiseParseError(p.PeekToken(), "':'")
                                    }
                                    _2 := p.ConsumeToken(); _ = _2
                            
                                    // label ':' @ dataexpr
                                    _3 := p._parseDataexpr(); _ = _3
                                    v.Push(&Vec{_1, _3})
                            
                                    continue
                            case tkRP:
                                // NOP
                            default:
                                p.RaiseParseError(p.PeekToken(), "IDENTIFIER, LABEL, ')'")
                            }
                            break
                        }
                
                        // identifierp '(' _stmt_15r @ ')'
                        if p.PeekToken().Kind != tkRP {
                            p.RaiseParseError(p.PeekToken(), "')'")
                        }
                        _4 := p.ConsumeToken(); _ = _4
                        *res = _1
                default:
                    p.RaiseParseError(p.PeekToken(), "IDENTIFIER, IDENTIFIERP")
                }
                break
            }
    
            // CONST _stmt_16g @ '=' dataexpr
            if p.PeekToken().Kind != tkEQ {
                p.RaiseParseError(p.PeekToken(), "'='")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // CONST _stmt_16g '=' @ dataexpr
            _4 := p._parseDataexpr(); _ = _4
            res = &Vec{KwConst.ToId(_1), _2, v, _4}
    case tkDATA:
            // @ DATA _stmt_20g databody
            _1 := p.ConsumeToken(); _ = _1
            v := Value(NIL); var w Value
    
            // DATA @ _stmt_20g databody
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _stmt_20g -> identifier _stmt_19o
                // RULE: _stmt_20g -> struct
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier _stmt_19o
                        _1 := p._parseIdentifier(); _ = _1
                        w = _1
                
                        // identifier @ _stmt_19o
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _stmt_19o -> _stmt_18g?
                            // RULE: _stmt_18g -> '=' _stmt_17g
                            switch p.PeekToken().Kind {
                            case tkEQ:
                                    // @ '=' _stmt_17g
                                    _1 := p.ConsumeToken(); _ = _1
                            
                                    // '=' @ _stmt_17g
                                    var _2 Value; _ = _2
                                    for {
                                        res := &_2; _ = res
                                        // RULE: _stmt_17g -> identifier
                                        // RULE: _stmt_17g -> struct
                                        switch p.PeekToken().Kind {
                                        case tkIDENTIFIER:
                                                // @ identifier
                                                _1 := p._parseIdentifier(); _ = _1
                                                v = w; w = _1
                                        case tkSTRUCT:
                                                // @ struct
                                                _1 := p._parseStruct(); _ = _1
                                                v = w; w = _1
                                        default:
                                            p.RaiseParseError(p.PeekToken(), "IDENTIFIER, STRUCT")
                                        }
                                        break
                                    }
                            case tkBOP, tkCL, tkLS, tkSC, tkEOF, tkRC:
                                // NOP
                            default:
                                p.RaiseParseError(p.PeekToken(), "'=', BOP, ':', '[', ';', EOF, '}'")
                            }
                            break
                        }
                case tkSTRUCT:
                        // @ struct
                        _1 := p._parseStruct(); _ = _1
                        w = _1
                default:
                    p.RaiseParseError(p.PeekToken(), "IDENTIFIER, STRUCT")
                }
                break
            }
    
            // DATA _stmt_20g @ databody
            _3 := p._parseDatabody(); _ = _3
            res = &Vec{KwData.ToId(_1), v, w, _3}
    case tkMODULE:
            // @ MODULE identifier block
            _1 := p.ConsumeToken(); _ = _1
    
            // MODULE @ identifier block
            _2 := p._parseIdentifier(); _ = _2
    
            // MODULE identifier @ block
            _3 := p._parseBlock(); _ = _3
            res = &Vec{KwModule.ToId(_1), _2, _3}
    case tkLABEL:
            // @ label ':'
            _1 := p._parseLabel(); _ = _1
    
            // label @ ':'
            if p.PeekToken().Kind != tkCL {
                p.RaiseParseError(p.PeekToken(), "':'")
            }
            _2 := p.ConsumeToken(); _ = _2
            res = &Vec{KwLabel.ToId(_2), _1}; p.state = pstNl
    case tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI:
            // @ expr
            _1 := p._parseExpr(); _ = _1
            res = _1
    default:
        p.RaiseParseError(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-'")
    }
    return
}

/** ** **
  struct ->
      STRUCT identifier? '{' labeleddata? (
        ';' labeleddata?
      )* '}'
 ** ** **/
func (p *Parser) _parseStruct() (res Value) {
    // RULE: struct -> STRUCT _struct_21o '{' _struct_22o _struct_25r '}'
    switch p.PeekToken().Kind {
    case tkSTRUCT:
            // @ STRUCT _struct_21o '{' _struct_22o _struct_25r '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // STRUCT @ _struct_21o '{' _struct_22o _struct_25r '}'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _struct_21o -> identifier
                // RULE: _struct_21o -> 
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkLC:
                        // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "IDENTIFIER, '{'")
                }
                break
            }
    
            // STRUCT _struct_21o @ '{' _struct_22o _struct_25r '}'
            if p.PeekToken().Kind != tkLC {
                p.RaiseParseError(p.PeekToken(), "'{'")
            }
            _3 := p.ConsumeToken(); _ = _3
            v := &Vec{}
    
            // STRUCT _struct_21o '{' @ _struct_22o _struct_25r '}'
            var _4 Value; _ = _4
            for {
                res := &_4; _ = res
                // RULE: _struct_22o -> labeleddata
                // RULE: _struct_22o -> 
                switch p.PeekToken().Kind {
                case tkLABEL:
                        // @ labeleddata
                        _1 := p._parseLabeleddata(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkRC:
                        // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "LABEL, ';', '}'")
                }
                break
            }
            if _2 != nil { v.Push(_2) }
    
            // STRUCT _struct_21o '{' _struct_22o @ _struct_25r '}'
            var _5 Value; _ = _5
            for {
                res := &_5; _ = res
                // RULE: _struct_25r -> _struct_24g*
                // RULE: _struct_24g -> ';' _struct_23o
                switch p.PeekToken().Kind {
                case tkSC:
                        // @ ';' _struct_23o
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ';' @ _struct_23o
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _struct_23o -> labeleddata
                            // RULE: _struct_23o -> 
                            switch p.PeekToken().Kind {
                            case tkLABEL:
                                    // @ labeleddata
                                    _1 := p._parseLabeleddata(); _ = _1
                                    *res = _1 // DEFAULT OPT ACTION
                            case tkSC, tkRC:
                                    // NOP
                            default:
                                p.RaiseParseError(p.PeekToken(), "LABEL, ';', '}'")
                            }
                            break
                        }
                        if _2 != nil { v.Push(_2) }
                
                        continue
                case tkRC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "';', '}'")
                }
                break
            }
    
            // STRUCT _struct_21o '{' _struct_22o _struct_25r @ '}'
            if p.PeekToken().Kind != tkRC {
                p.RaiseParseError(p.PeekToken(), "'}'")
            }
            _6 := p.ConsumeToken(); _ = _6
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "STRUCT")
    }
    return
}

/** ** **
  labeleddata ->
      label ':' identifier databody
 ** ** **/
func (p *Parser) _parseLabeleddata() (res Value) {
    // RULE: labeleddata -> label ':' identifier databody
    switch p.PeekToken().Kind {
    case tkLABEL:
            // @ label ':' identifier databody
            _1 := p._parseLabel(); _ = _1
    
            // label @ ':' identifier databody
            if p.PeekToken().Kind != tkCL {
                p.RaiseParseError(p.PeekToken(), "':'")
            }
            _2 := p.ConsumeToken(); _ = _2
    
            // label ':' @ identifier databody
            _3 := p._parseIdentifier(); _ = _3
    
            // label ':' identifier @ databody
            _4 := p._parseDatabody(); _ = _4
            res = &Vec{_1, _3, _4}
    default:
        p.RaiseParseError(p.PeekToken(), "LABEL")
    }
    return
}

/** ** **
  databody ->
      datalist? (
        BOP dataval
      )? (
        ':' identifier
      )?
 ** ** **/
func (p *Parser) _parseDatabody() (res Value) {
    // RULE: databody -> _databody_26o _databody_28o _databody_30o
    here := _here(p)
    switch p.PeekToken().Kind {
    case tkLS, tkBOP, tkCL, tkSC, tkEOF, tkRC:
            // @ _databody_26o _databody_28o _databody_30o
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _databody_26o -> datalist
                // RULE: _databody_26o -> 
                switch p.PeekToken().Kind {
                case tkLS:
                        // @ datalist
                        _1 := p._parseDatalist(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkBOP, tkCL, tkSC, tkEOF, tkRC:
                        *res = NIL
                default:
                    p.RaiseParseError(p.PeekToken(), "'[', BOP, ':', ';', EOF, '}'")
                }
                break
            }
            alloc := Value(KwMulOp.ToId(here))
                                                     size := _constexpr(Int(1), here)
    
            // _databody_26o @ _databody_28o _databody_30o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _databody_28o -> _databody_27g?
                // RULE: _databody_27g -> BOP dataval
                switch p.PeekToken().Kind {
                case tkBOP:
                        // @ BOP dataval
                        _1 := p.ConsumeToken(); _ = _1
                
                        // BOP @ dataval
                        _2 := p._parseDataval(); _ = _2
                        alloc = _1.Value; size = _2
                case tkCL, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "BOP, ':', ';', EOF, '}'")
                }
                break
            }
            section := Value(NIL)
    
            // _databody_26o _databody_28o @ _databody_30o
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _databody_30o -> _databody_29g?
                // RULE: _databody_29g -> ':' identifier
                switch p.PeekToken().Kind {
                case tkCL:
                        // @ ':' identifier
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ':' @ identifier
                        _2 := p._parseIdentifier(); _ = _2
                        section = _2
                case tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "':', ';', EOF, '}'")
                }
                break
            }
            res = &Vec{_1, alloc, size, section }
    default:
        p.RaiseParseError(p.PeekToken(), "'[', BOP, ':', ';', EOF, '}'")
    }
    return
}

/** ** **
  datalist ->
      '[' (
        dataexpr
      | datalist
      )* ']'
 ** ** **/
func (p *Parser) _parseDatalist() (res Value) {
    // RULE: datalist -> '[' _datalist_32r ']'
    switch p.PeekToken().Kind {
    case tkLS:
            // @ '[' _datalist_32r ']'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwVec.ToId(_1)}
    
            // '[' @ _datalist_32r ']'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _datalist_32r -> _datalist_31g*
                // RULE: _datalist_31g -> dataexpr
                // RULE: _datalist_31g -> datalist
                switch p.PeekToken().Kind {
                case tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ dataexpr
                        _1 := p._parseDataexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkLS:
                        // @ datalist
                        _1 := p._parseDatalist(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '[', ']'")
                }
                break
            }
    
            // '[' _datalist_32r @ ']'
            if p.PeekToken().Kind != tkRS {
                p.RaiseParseError(p.PeekToken(), "']'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "'['")
    }
    return
}

/** ** **
  dataexpr ->
      constexpr
    | explicitval
 ** ** **/
func (p *Parser) _parseDataexpr() (res Value) {
    // RULE: dataexpr -> constexpr
    // RULE: dataexpr -> explicitval
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ constexpr
            _1 := p._parseConstexpr(); _ = _1
            res = _1
    case tkDLMI, tkDLDLMI:
            // @ explicitval
            _1 := p._parseExplicitval(); _ = _1
            res = _1
    default:
        p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '$-', '$$-'")
    }
    return
}

/** ** **
  dataval ->
      constval
    | explicitval
 ** ** **/
func (p *Parser) _parseDataval() (res Value) {
    // RULE: dataval -> constval
    // RULE: dataval -> explicitval
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ constval
            _1 := p._parseConstval(); _ = _1
            res = _1
    case tkDLMI, tkDLDLMI:
            // @ explicitval
            _1 := p._parseExplicitval(); _ = _1
            res = _1
    default:
        p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '$-', '$$-'")
    }
    return
}

/** ** **
  symexpr ->
      '%{' symval (
        symval
      )* '}'
 ** ** **/
func (p *Parser) _parseSymexpr() (res Value) {
    // RULE: symexpr -> '%{' symval _symexpr_34r '}'
    switch p.PeekToken().Kind {
    case tkPELC:
            // @ '%{' symval _symexpr_34r '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // '%{' @ symval _symexpr_34r '}'
            _2 := p._parseSymval(); _ = _2
            v := &Vec{KwMakeId.ToId(_1), _2}
    
            // '%{' symval @ _symexpr_34r '}'
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _symexpr_34r -> _symexpr_33g*
                // RULE: _symexpr_33g -> symval
                switch p.PeekToken().Kind {
                case tkIDENTIFIER, tkSTRING:
                        // @ symval
                        _1 := p._parseSymval(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "IDENTIFIER, STRING, '}'")
                }
                break
            }
    
            // '%{' symval _symexpr_34r @ '}'
            if p.PeekToken().Kind != tkRC {
                p.RaiseParseError(p.PeekToken(), "'}'")
            }
            _4 := p.ConsumeToken(); _ = _4
            res = _constexpr(v, _1)
    default:
        p.RaiseParseError(p.PeekToken(), "'%{'")
    }
    return
}

/** ** **
  symval ->
      IDENTIFIER
    | STRING
 ** ** **/
func (p *Parser) _parseSymval() (res Value) {
    // RULE: symval -> IDENTIFIER
    // RULE: symval -> STRING
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ IDENTIFIER
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkSTRING:
            // @ STRING
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    default:
        p.RaiseParseError(p.PeekToken(), "IDENTIFIER, STRING")
    }
    return
}

/** ** **
  sig ->
      (
        '-*'
      )? regs (
        '=>' regs
      )? (
        '!' regs
      )?
 ** ** **/
func (p *Parser) _parseSig() (res Value) {
    // RULE: sig -> _sig_36o regs _sig_38o _sig_40o
    v := &Vec{NIL, NIL, NIL, NIL}
    switch p.PeekToken().Kind {
    case tkMIAS, tkREG, tkEQGT, tkEX, tkRP:
            // @ _sig_36o regs _sig_38o _sig_40o
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _sig_36o -> _sig_35g?
                // RULE: _sig_35g -> '-*'
                switch p.PeekToken().Kind {
                case tkMIAS:
                        // @ '-*'
                        _1 := p.ConsumeToken(); _ = _1
                        v.SetAt(3, Int(1))
                case tkREG, tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'-*', REG, '=>', '!', ')'")
                }
                break
            }
    
            // _sig_36o @ regs _sig_38o _sig_40o
            _2 := p._parseRegs(); _ = _2
            v.SetAt(0, _2)
    
            // _sig_36o regs @ _sig_38o _sig_40o
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _sig_38o -> _sig_37g?
                // RULE: _sig_37g -> '=>' regs
                switch p.PeekToken().Kind {
                case tkEQGT:
                        // @ '=>' regs
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '=>' @ regs
                        _2 := p._parseRegs(); _ = _2
                        v.SetAt(1, _2)
                case tkEX, tkRP:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'=>', '!', ')'")
                }
                break
            }
    
            // _sig_36o regs _sig_38o @ _sig_40o
            var _4 Value; _ = _4
            for {
                res := &_4; _ = res
                // RULE: _sig_40o -> _sig_39g?
                // RULE: _sig_39g -> '!' regs
                switch p.PeekToken().Kind {
                case tkEX:
                        // @ '!' regs
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '!' @ regs
                        _2 := p._parseRegs(); _ = _2
                        v.SetAt(2, _2)
                case tkRP:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'!', ')'")
                }
                break
            }
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "'-*', REG, '=>', '!', ')'")
    }
    return
}

/** ** **
  regs ->
      (
        REG
      )*
 ** ** **/
func (p *Parser) _parseRegs() (res Value) {
    // RULE: regs -> _regs_42r
    v := &Vec{}
    switch p.PeekToken().Kind {
    case tkREG, tkEQGT, tkEX, tkRP:
            // @ _regs_42r
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _regs_42r -> _regs_41g*
                // RULE: _regs_41g -> REG
                switch p.PeekToken().Kind {
                case tkREG:
                        // @ REG
                        _1 := p.ConsumeToken(); _ = _1
                        v.Push(_1.Value)
                
                        continue
                case tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "REG, '=>', '!', ')'")
                }
                break
            }
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "REG, '=>', '!', ')'")
    }
    return
}

/** ** **
  block ->
      '{' program '}'
    | '={' program '}'
 ** ** **/
func (p *Parser) _parseBlock() (res Value) {
    // RULE: block -> '{' program '}'
    // RULE: block -> '={' program '}'
    switch p.PeekToken().Kind {
    case tkLC:
            // @ '{' program '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // '{' @ program '}'
            _2 := p._parseProgram(); _ = _2
    
            // '{' program @ '}'
            if p.PeekToken().Kind != tkRC {
                p.RaiseParseError(p.PeekToken(), "'}'")
            }
            _3 := p.ConsumeToken(); _ = _3
            v := _2.(*Vec); v.SetAt(0, KwProg.ToId(_1)); res = v
    case tkEQLC:
            // @ '={' program '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // '={' @ program '}'
            _2 := p._parseProgram(); _ = _2
    
            // '={' program @ '}'
            if p.PeekToken().Kind != tkRC {
                p.RaiseParseError(p.PeekToken(), "'}'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = _2
    default:
        p.RaiseParseError(p.PeekToken(), "'{', '={'")
    }
    return
}

/** ** **
  expr ->
      identifier (
        oper
      )*
    | callproc
    | contextexpr
 ** ** **/
func (p *Parser) _parseExpr() (res Value) {
    // RULE: expr -> identifier _expr_44r
    // RULE: expr -> callproc
    // RULE: expr -> contextexpr
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ identifier _expr_44r
            _1 := p._parseIdentifier(); _ = _1
            v := &Vec{_idfrom(_1)}
    
            // identifier @ _expr_44r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _expr_44r -> _expr_43g*
                // RULE: _expr_43g -> oper
                switch p.PeekToken().Kind {
                case tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ oper
                        _1 := p._parseOper(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ';', EOF, '}'")
                }
                break
            }
            res = v
    case tkCONDDOT, tkIDENTIFIERP:
            // @ callproc
            _1 := p._parseCallproc(); _ = _1
            res = _1
    case tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI:
            // @ contextexpr
            _1 := p._parseContextexpr(); _ = _1
            res = _1
    default:
        p.RaiseParseError(p.PeekToken(), "IDENTIFIER, CONDDOT, IDENTIFIERP, '@-', REG, '[', '$-', '$$-'")
    }
    return
}

/** ** **
  callproc ->
      CONDDOT? identifierp '(' sig ')'
 ** ** **/
func (p *Parser) _parseCallproc() (res Value) {
    // RULE: callproc -> _callproc_45o identifierp '(' sig ')'
    switch p.PeekToken().Kind {
    case tkCONDDOT, tkIDENTIFIERP:
            // @ _callproc_45o identifierp '(' sig ')'
            var _1 *Token; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _callproc_45o -> CONDDOT
                // RULE: _callproc_45o -> 
                switch p.PeekToken().Kind {
                case tkCONDDOT:
                        // @ CONDDOT
                        _1 := p.ConsumeToken(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkIDENTIFIERP:
                        *res = NILTK
                default:
                    p.RaiseParseError(p.PeekToken(), "CONDDOT, IDENTIFIERP")
                }
                break
            }
    
            // _callproc_45o @ identifierp '(' sig ')'
            _2 := p._parseIdentifierp(); _ = _2
    
            // _callproc_45o identifierp @ '(' sig ')'
            if p.PeekToken().Kind != tkLP {
                p.RaiseParseError(p.PeekToken(), "'('")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // _callproc_45o identifierp '(' @ sig ')'
            _4 := p._parseSig(); _ = _4
    
            // _callproc_45o identifierp '(' sig @ ')'
            if p.PeekToken().Kind != tkRP {
                p.RaiseParseError(p.PeekToken(), "')'")
            }
            _5 := p.ConsumeToken(); _ = _5
            res = &Vec{KwCallproc.ToId(_3), _2, _1.Value, _4, KwCall}
    default:
        p.RaiseParseError(p.PeekToken(), "CONDDOT, IDENTIFIERP")
    }
    return
}

/** ** **
  contextexpr ->
      (
        regld
      | mem
      | explicitval
      | '@-' prim
      ) (
        CONDDOT? (
          UOP
        | BOP oper
        | DOP dotarg
        )
      )*
 ** ** **/
func (p *Parser) _parseContextexpr() (res Value) {
    // RULE: contextexpr -> _contextexpr_46g _contextexpr_50r
    v := &Vec{KwWith.ToId(_here(p))}
    switch p.PeekToken().Kind {
    case tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI:
            // @ _contextexpr_46g _contextexpr_50r
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _contextexpr_46g -> regld
                // RULE: _contextexpr_46g -> mem
                // RULE: _contextexpr_46g -> explicitval
                // RULE: _contextexpr_46g -> '@-' prim
                switch p.PeekToken().Kind {
                case tkREG:
                        // @ regld
                        _1 := p._parseRegld(); _ = _1
                        v = _1.(*Vec)
                case tkLS:
                        // @ mem
                        _1 := p._parseMem(); _ = _1
                        v.Push(_1)
                case tkDLMI, tkDLDLMI:
                        // @ explicitval
                        _1 := p._parseExplicitval(); _ = _1
                        v.Push(_1)
                case tkATMI:
                        // @ '@-' prim
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '@-' @ prim
                        _2 := p._parsePrim(); _ = _2
                        v.Push(p.cc.KwRegA.ToId(_1), &Vec{KwLeftArrow.ToId(_1), _2})
                default:
                    p.RaiseParseError(p.PeekToken(), "REG, '[', '$-', '$$-', '@-'")
                }
                break
            }
    
            // _contextexpr_46g @ _contextexpr_50r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _contextexpr_50r -> _contextexpr_49g*
                // RULE: _contextexpr_49g -> _contextexpr_47o _contextexpr_48g
                switch p.PeekToken().Kind {
                case tkCONDDOT, tkUOP, tkBOP, tkDOP:
                        // @ _contextexpr_47o _contextexpr_48g
                        var _1 *Token; _ = _1
                        for {
                            res := &_1; _ = res
                            // RULE: _contextexpr_47o -> CONDDOT
                            // RULE: _contextexpr_47o -> 
                            switch p.PeekToken().Kind {
                            case tkCONDDOT:
                                    // @ CONDDOT
                                    _1 := p.ConsumeToken(); _ = _1
                                    *res = _1 // DEFAULT OPT ACTION
                            case tkUOP, tkBOP, tkDOP:
                                    *res = NILTK
                            default:
                                p.RaiseParseError(p.PeekToken(), "CONDDOT, UOP, BOP, DOP")
                            }
                            break
                        }
                        c := _1.Value
                
                        // _contextexpr_47o @ _contextexpr_48g
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _contextexpr_48g -> UOP
                            // RULE: _contextexpr_48g -> BOP oper
                            // RULE: _contextexpr_48g -> DOP dotarg
                            switch p.PeekToken().Kind {
                            case tkUOP:
                                    // @ UOP
                                    _1 := p.ConsumeToken(); _ = _1
                                    v.Push(&Vec{_1.Value, NIL, c})
                            case tkBOP:
                                    // @ BOP oper
                                    _1 := p.ConsumeToken(); _ = _1
                            
                                    // BOP @ oper
                                    _2 := p._parseOper(); _ = _2
                                    v.Push(&Vec{_1.Value, _2, c})
                            case tkDOP:
                                    // @ DOP dotarg
                                    _1 := p.ConsumeToken(); _ = _1
                            
                                    // DOP @ dotarg
                                    _2 := p._parseDotarg(); _ = _2
                                    v.Push(&Vec{_1.Value, _2})
                            default:
                                p.RaiseParseError(p.PeekToken(), "UOP, BOP, DOP")
                            }
                            break
                        }
                
                        continue
                case tkSC, tkEOF, tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkRC, tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "CONDDOT, UOP, BOP, DOP, ';', EOF, '@-', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '}', ']'")
                }
                break
            }
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "'@-', REG, '[', '$-', '$$-'")
    }
    return
}

/** ** **
  oper ->
      prim (
        ':' prim
      )?
 ** ** **/
func (p *Parser) _parseOper() (res Value) {
    // RULE: oper -> prim _oper_52o
    switch p.PeekToken().Kind {
    case tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ prim _oper_52o
            _1 := p._parsePrim(); _ = _1
            v := _1
    
            // prim @ _oper_52o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _oper_52o -> _oper_51g?
                // RULE: _oper_51g -> ':' prim
                switch p.PeekToken().Kind {
                case tkCL:
                        // @ ':' prim
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ':' @ prim
                        _2 := p._parsePrim(); _ = _2
                        v = &Vec{KwTpl.ToId(_1), v, _2}
                case tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkCONDDOT, tkUOP, tkBOP, tkDOP, tkSC, tkEOF, tkRC, tkATMI, tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "':', COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, CONDDOT, UOP, BOP, DOP, ';', EOF, '}', '@-', ']'")
                }
                break
            }
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  prim ->
      COND
    | regld
    | mem
    | dataval
    | block
 ** ** **/
func (p *Parser) _parsePrim() (res Value) {
    // RULE: prim -> COND
    // RULE: prim -> regld
    // RULE: prim -> mem
    // RULE: prim -> dataval
    // RULE: prim -> block
    switch p.PeekToken().Kind {
    case tkCOND:
            // @ COND
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkREG:
            // @ regld
            _1 := p._parseRegld(); _ = _1
            res = _maybeunwrapwith(_1)
    case tkLS:
            // @ mem
            _1 := p._parseMem(); _ = _1
            res = _1
    case tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ dataval
            _1 := p._parseDataval(); _ = _1
            res = _1
    case tkLC, tkEQLC:
            // @ block
            _1 := p._parseBlock(); _ = _1
            res = _1
    default:
        p.RaiseParseError(p.PeekToken(), "COND, REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '{', '={'")
    }
    return
}

/** ** **
  regld ->
      REG (
        '-@' prim
      )?
 ** ** **/
func (p *Parser) _parseRegld() (res Value) {
    // RULE: regld -> REG _regld_54o
    switch p.PeekToken().Kind {
    case tkREG:
            // @ REG _regld_54o
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwWith.ToId(_1), _1.Value}
    
            // REG @ _regld_54o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _regld_54o -> _regld_53g?
                // RULE: _regld_53g -> '-@' prim
                switch p.PeekToken().Kind {
                case tkMIAT:
                        // @ '-@' prim
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '-@' @ prim
                        _2 := p._parsePrim(); _ = _2
                        v.Push(&Vec{KwLeftArrow.ToId(_1), _2})
                case tkCL, tkCONDDOT, tkUOP, tkBOP, tkDOP, tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkSC, tkEOF, tkATMI, tkRC, tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'-@', ':', CONDDOT, UOP, BOP, DOP, COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ';', EOF, '@-', '}', ']'")
                }
                break
            }
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "REG")
    }
    return
}

/** ** **
  mem ->
      '[' (
        contextexpr
      | constexpr
      )* ']'
 ** ** **/
func (p *Parser) _parseMem() (res Value) {
    // RULE: mem -> '[' _mem_56r ']'
    switch p.PeekToken().Kind {
    case tkLS:
            // @ '[' _mem_56r ']'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwMem.ToId(_1)}
    
            // '[' @ _mem_56r ']'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _mem_56r -> _mem_55g*
                // RULE: _mem_55g -> contextexpr
                // RULE: _mem_55g -> constexpr
                switch p.PeekToken().Kind {
                case tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI:
                        // @ contextexpr
                        _1 := p._parseContextexpr(); _ = _1
                        v.Push(_maybeunwrapwith(_1))
                
                        continue
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ constexpr
                        _1 := p._parseConstexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'@-', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ']'")
                }
                break
            }
    
            // '[' _mem_56r @ ']'
            if p.PeekToken().Kind != tkRS {
                p.RaiseParseError(p.PeekToken(), "']'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = v
    default:
        p.RaiseParseError(p.PeekToken(), "'['")
    }
    return
}

/** ** **
  dotarg ->
      callproc
    | regld
    | block
 ** ** **/
func (p *Parser) _parseDotarg() (res Value) {
    // RULE: dotarg -> callproc
    // RULE: dotarg -> regld
    // RULE: dotarg -> block
    switch p.PeekToken().Kind {
    case tkCONDDOT, tkIDENTIFIERP:
            // @ callproc
            _1 := p._parseCallproc(); _ = _1
            res = _1
    case tkREG:
            // @ regld
            _1 := p._parseRegld(); _ = _1
            res = _1
    case tkLC, tkEQLC:
            // @ block
            _1 := p._parseBlock(); _ = _1
            res = _1
    default:
        p.RaiseParseError(p.PeekToken(), "CONDDOT, IDENTIFIERP, REG, '{', '={'")
    }
    return
}

/** ** **
  explicitval ->
      '$-' constval
    | '$$-' constval
 ** ** **/
func (p *Parser) _parseExplicitval() (res Value) {
    // RULE: explicitval -> '$-' constval
    // RULE: explicitval -> '$$-' constval
    switch p.PeekToken().Kind {
    case tkDLMI:
            // @ '$-' constval
            _1 := p.ConsumeToken(); _ = _1
    
            // '$-' @ constval
            _2 := p._parseConstval(); _ = _2
            res = _2
    case tkDLDLMI:
            // @ '$$-' constval
            _1 := p.ConsumeToken(); _ = _1
    
            // '$$-' @ constval
            _2 := p._parseConstval(); _ = _2
            res = &Vec{KwValueOf.ToId(_1), _2}
    default:
        p.RaiseParseError(p.PeekToken(), "'$-', '$$-'")
    }
    return
}

/** ** **
  constexpr ->
      iexpr
 ** ** **/
func (p *Parser) _parseConstexpr() (res Value) {
    // RULE: constexpr -> iexpr
    here := _here(p)
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ iexpr
            _1 := p._parseIexpr(); _ = _1
            res = _constexpr(_1, here)
    default:
        p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  constval ->
      ival
 ** ** **/
func (p *Parser) _parseConstval() (res Value) {
    // RULE: constval -> ival
    here := _here(p)
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ ival
            _1 := p._parseIval(); _ = _1
            res = _constexpr(_1, here)
    default:
        p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  iexpr ->
      ival (
        BOP ival
      )*
 ** ** **/
func (p *Parser) _parseIexpr() (res Value) {
    // RULE: iexpr -> ival _iexpr_58r
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ ival _iexpr_58r
            _1 := p._parseIval(); _ = _1
            v := []Value{_1}
    
            // ival @ _iexpr_58r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _iexpr_58r -> _iexpr_57g*
                // RULE: _iexpr_57g -> BOP ival
                switch p.PeekToken().Kind {
                case tkBOP:
                        // @ BOP ival
                        _1 := p.ConsumeToken(); _ = _1
                
                        // BOP @ ival
                        _2 := p._parseIval(); _ = _2
                        v = p.cc.orderByPrec(v, _1.Value.(*Identifier), _2)
                
                        continue
                case tkRP, tkIDENTIFIER, tkLABEL, tkSC, tkEOF, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkAOP, tkATMI, tkREG, tkREST, tkRC, tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "BOP, ')', IDENTIFIER, LABEL, ';', EOF, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIERP, '(', AOP, '@-', REG, REST, '}', ']'")
                }
                break
            }
            res = p.cc.orderByPrec(v, idOpLast, nil)[0]
    default:
        p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  ival ->
      INTEGER
    | STRING
    | RESERVED
    | IDENTIFIER (
        '.-' IDENTIFIER
      )*
    | IDENTIFIERP '(' (
        iexpr
      )* ')'
    | '(' iexpr ')'
    | AOP ival
 ** ** **/
func (p *Parser) _parseIval() (res Value) {
    // RULE: ival -> INTEGER
    // RULE: ival -> STRING
    // RULE: ival -> RESERVED
    // RULE: ival -> IDENTIFIER _ival_60r
    // RULE: ival -> IDENTIFIERP '(' _ival_62r ')'
    // RULE: ival -> '(' iexpr ')'
    // RULE: ival -> AOP ival
    switch p.PeekToken().Kind {
    case tkINTEGER:
            // @ INTEGER
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkSTRING:
            // @ STRING
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkRESERVED:
            // @ RESERVED
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkIDENTIFIER:
            // @ IDENTIFIER _ival_60r
            _1 := p.ConsumeToken(); _ = _1
            v := _1.Value
    
            // IDENTIFIER @ _ival_60r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _ival_60r -> _ival_59g*
                // RULE: _ival_59g -> '.-' IDENTIFIER
                switch p.PeekToken().Kind {
                case tkDTMI:
                        // @ '.-' IDENTIFIER
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '.-' @ IDENTIFIER
                        if p.PeekToken().Kind != tkIDENTIFIER {
                            p.RaiseParseError(p.PeekToken(), "IDENTIFIER")
                        }
                        _2 := p.ConsumeToken(); _ = _2
                        v = &Vec{KwField.ToId(_1), v, _2.Value}
                
                        continue
                case tkBOP, tkCL, tkIDENTIFIER, tkLABEL, tkSC, tkEOF, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkAOP, tkCONDDOT, tkUOP, tkDOP, tkRP, tkATMI, tkREG, tkCOND, tkLC, tkEQLC, tkREST, tkRC, tkRS:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "'.-', BOP, ':', IDENTIFIER, LABEL, ';', EOF, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIERP, '(', AOP, CONDDOT, UOP, DOP, ')', '@-', REG, COND, '{', '={', REST, '}', ']'")
                }
                break
            }
            res = v
    case tkIDENTIFIERP:
            // @ IDENTIFIERP '(' _ival_62r ')'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{ _1.Value }
    
            // IDENTIFIERP @ '(' _ival_62r ')'
            if p.PeekToken().Kind != tkLP {
                p.RaiseParseError(p.PeekToken(), "'('")
            }
            _2 := p.ConsumeToken(); _ = _2
    
            // IDENTIFIERP '(' @ _ival_62r ')'
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _ival_62r -> _ival_61g*
                // RULE: _ival_61g -> iexpr
                switch p.PeekToken().Kind {
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ iexpr
                        _1 := p._parseIexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRP:
                    // NOP
                default:
                    p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ')'")
                }
                break
            }
    
            // IDENTIFIERP '(' _ival_62r @ ')'
            if p.PeekToken().Kind != tkRP {
                p.RaiseParseError(p.PeekToken(), "')'")
            }
            _4 := p.ConsumeToken(); _ = _4
            res = v
    case tkLP:
            // @ '(' iexpr ')'
            _1 := p.ConsumeToken(); _ = _1
    
            // '(' @ iexpr ')'
            _2 := p._parseIexpr(); _ = _2
    
            // '(' iexpr @ ')'
            if p.PeekToken().Kind != tkRP {
                p.RaiseParseError(p.PeekToken(), "')'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = _2
    case tkAOP:
            // @ AOP ival
            _1 := p.ConsumeToken(); _ = _1
    
            // AOP @ ival
            _2 := p._parseIval(); _ = _2
            res = &Vec{ _1.Value, _2 }
    default:
        p.RaiseParseError(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  identifier ->
      IDENTIFIER
 ** ** **/
func (p *Parser) _parseIdentifier() (res Value) {
    // RULE: identifier -> IDENTIFIER
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ IDENTIFIER
            _1 := p.ConsumeToken(); _ = _1
            res = _constexpr(_1.Value, _1)
    default:
        p.RaiseParseError(p.PeekToken(), "IDENTIFIER")
    }
    return
}

/** ** **
  identifierp ->
      IDENTIFIERP
 ** ** **/
func (p *Parser) _parseIdentifierp() (res Value) {
    // RULE: identifierp -> IDENTIFIERP
    switch p.PeekToken().Kind {
    case tkIDENTIFIERP:
            // @ IDENTIFIERP
            _1 := p.ConsumeToken(); _ = _1
            res = _constexpr(_1.Value, _1)
    default:
        p.RaiseParseError(p.PeekToken(), "IDENTIFIERP")
    }
    return
}

/** ** **
  label ->
      LABEL
 ** ** **/
func (p *Parser) _parseLabel() (res Value) {
    // RULE: label -> LABEL
    switch p.PeekToken().Kind {
    case tkLABEL:
            // @ LABEL
            _1 := p.ConsumeToken(); _ = _1
            res = _constexpr(_1.Value, _1)
    default:
        p.RaiseParseError(p.PeekToken(), "LABEL")
    }
    return
}
