// GENERATED BY llpg
//lint:file-ignore U1000 generated code
//lint:file-ignore SA4004 generated code

package core

const (
    tkEOF = iota
    tkSCANERROR
    tkSC
    tkCL
    tkREST
    tkEQ
    tkLS
    tkRS
    tkAT
    tkLP
    tkRP
    tkMACRO
    tkPROC
    tkCONST
    tkDATA
    tkMODULE
    tkSTRUCT
    tkLC
    tkRC
    tkBOP
    tkPELC
    tkIDENTIFIER
    tkSTRING
    tkMIAS
    tkEQGT
    tkEX
    tkREG
    tkEQLC
    tkCONDDOT
    tkATMI
    tkUOP
    tkDOP
    tkCOND
    tkMIAT
    tkDLMI
    tkDLDLMI
    tkDTMI
    tkINTEGER
    tkRESERVED
    tkIDENTIFIERP
    tkAOP
    tkLABEL
)

var tokenKinds = map[string]int32{
    ";": tkSC,
    ":": tkCL,
    "=": tkEQ,
    "[": tkLS,
    "]": tkRS,
    "@": tkAT,
    "(": tkLP,
    ")": tkRP,
    "{": tkLC,
    "}": tkRC,
    "%{": tkPELC,
    "-*": tkMIAS,
    "=>": tkEQGT,
    "!": tkEX,
    "={": tkEQLC,
    "@-": tkATMI,
    "-@": tkMIAT,
    "$-": tkDLMI,
    "$$-": tkDLDLMI,
    ".-": tkDTMI,
}

var tokenLabels = [...]string{
    "EOF", // tkEOF
    "SCANERROR", // tkSCANERROR
    "';'", // tkSC
    "':'", // tkCL
    "REST", // tkREST
    "'='", // tkEQ
    "'['", // tkLS
    "']'", // tkRS
    "'@'", // tkAT
    "'('", // tkLP
    "')'", // tkRP
    "MACRO", // tkMACRO
    "PROC", // tkPROC
    "CONST", // tkCONST
    "DATA", // tkDATA
    "MODULE", // tkMODULE
    "STRUCT", // tkSTRUCT
    "'{'", // tkLC
    "'}'", // tkRC
    "BOP", // tkBOP
    "'%{'", // tkPELC
    "IDENTIFIER", // tkIDENTIFIER
    "STRING", // tkSTRING
    "'-*'", // tkMIAS
    "'=>'", // tkEQGT
    "'!'", // tkEX
    "REG", // tkREG
    "'={'", // tkEQLC
    "CONDDOT", // tkCONDDOT
    "'@-'", // tkATMI
    "UOP", // tkUOP
    "DOP", // tkDOP
    "COND", // tkCOND
    "'-@'", // tkMIAT
    "'$-'", // tkDLMI
    "'$$-'", // tkDLDLMI
    "'.-'", // tkDTMI
    "INTEGER", // tkINTEGER
    "RESERVED", // tkRESERVED
    "IDENTIFIERP", // tkIDENTIFIERP
    "AOP", // tkAOP
    "LABEL", // tkLABEL
}

var reservedWords = map[string]int32{
  "macro": tkMACRO,
  "proc": tkPROC,
  "const": tkCONST,
  "data": tkDATA,
  "module": tkMODULE,
  "struct": tkSTRUCT,
  "_": tkRESERVED,
  "_BEG": tkRESERVED,
  "_END": tkRESERVED,
  "_COND": tkRESERVED,
  "__PROC__": tkRESERVED,
}

func (p *Parser) _parse() (res Value, ok bool) {
    res = p._parseProgram()
    if (p.PeekToken().Kind != tkEOF) {
         p.ErrorUnexpected(p.PeekToken(), "EOF")
    }
    ok = true
    return
}

/** ** **
  program ->
      stmt? (
        ';' stmt?
      )*
 ** ** **/
func (p *Parser) _parseProgram() (res Value) {
    // RULE: program -> _program_1o _program_4r
    v := &Vec{_markerid(p, KwBlock)}
    switch p.PeekToken().Kind {
    case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI, tkSC, tkEOF, tkRC:
            // @ _program_1o _program_4r
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _program_1o -> stmt
                // RULE: _program_1o -> 
                switch p.PeekToken().Kind {
                case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI:
                        // @ stmt
                        _1 := p._parseStmt(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkEOF, tkRC:
                        // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, STRUCT, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-', ';', EOF, '}'")
                }
                break
            }
            if _1 != nil { v.Push(_1) }
    
            // _program_1o @ _program_4r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _program_4r -> _program_3g*
                // RULE: _program_3g -> ';' _program_2o
                switch p.PeekToken().Kind {
                case tkSC:
                        // @ ';' _program_2o
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ';' @ _program_2o
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _program_2o -> stmt
                            // RULE: _program_2o -> 
                            switch p.PeekToken().Kind {
                            case tkMACRO, tkPROC, tkCONST, tkDATA, tkMODULE, tkLABEL, tkSTRUCT, tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI:
                                    // @ stmt
                                    _1 := p._parseStmt(); _ = _1
                                    *res = _1 // DEFAULT OPT ACTION
                            case tkSC, tkEOF, tkRC:
                                    // NOP
                            default:
                                p.ErrorUnexpected(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, STRUCT, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-', ';', EOF, '}'")
                            }
                            break
                        }
                        if _2 != nil { v.Push(_2) }
                
                        continue
                case tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "';', EOF, '}'")
                }
                break
            }
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, STRUCT, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-', ';', EOF, '}'")
    }
    return
}

/** ** **
  stmt ->
      MACRO identifierp '(' (
        identifier
      | label ':' dataexpr
      )* REST? ')' (
        '[' (
          identifier (
            '=' symexpr
          )?
        )* ']'
      )? block
    | PROC identifierp '(' sig ')' (
        block
      | '@' dataexpr
      )
    | CONST (
        identifier
      | identifierp '(' (
          identifier
        | label ':' dataexpr
        )* ')'
      ) '=' dataexpr
    | DATA datatype (
        '=' datatype
      )? databody
    | MODULE identifier block
    | label ':'
    | struct
    | expr
 ** ** **/
func (p *Parser) _parseStmt() (res Value) {
    // RULE: stmt -> MACRO identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o block
    // RULE: stmt -> PROC identifierp '(' sig ')' _stmt_14g
    // RULE: stmt -> CONST _stmt_17g '=' dataexpr
    // RULE: stmt -> DATA datatype _stmt_19o databody
    // RULE: stmt -> MODULE identifier block
    // RULE: stmt -> label ':'
    // RULE: stmt -> struct
    // RULE: stmt -> expr
    switch p.PeekToken().Kind {
    case tkMACRO:
            // @ MACRO identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o block
            _1 := p.ConsumeToken(); _ = _1
    
            // MACRO @ identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o block
            _2 := p._parseIdentifierp(); _ = _2
            v := &Vec{}; w := &Vec{}
    
            // MACRO identifierp @ '(' _stmt_6r _stmt_7o ')' _stmt_13o block
            if p.PeekToken().Kind != tkLP {
                p.ErrorUnexpected(p.PeekToken(), "'('")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // MACRO identifierp '(' @ _stmt_6r _stmt_7o ')' _stmt_13o block
            var _4 Value; _ = _4
            for {
                res := &_4; _ = res
                // RULE: _stmt_6r -> _stmt_5g*
                // RULE: _stmt_5g -> identifier
                // RULE: _stmt_5g -> label ':' dataexpr
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        v.Push(&Vec{_1, NIL})
                
                        continue
                case tkLABEL:
                        // @ label ':' dataexpr
                        _1 := p._parseLabel(); _ = _1
                
                        // label @ ':' dataexpr
                        if p.PeekToken().Kind != tkCL {
                            p.ErrorUnexpected(p.PeekToken(), "':'")
                        }
                        _2 := p.ConsumeToken(); _ = _2
                
                        // label ':' @ dataexpr
                        _3 := p._parseDataexpr(); _ = _3
                        v.Push(&Vec{_1, _3})
                
                        continue
                case tkREST, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, LABEL, REST, ')'")
                }
                break
            }
    
            // MACRO identifierp '(' _stmt_6r @ _stmt_7o ')' _stmt_13o block
            var _5 *Token; _ = _5
            for {
                res := &_5; _ = res
                // RULE: _stmt_7o -> REST
                // RULE: _stmt_7o -> 
                switch p.PeekToken().Kind {
                case tkREST:
                        // @ REST
                        _1 := p.ConsumeToken(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkRP:
                        *res = NILTK
                default:
                    p.ErrorUnexpected(p.PeekToken(), "REST, ')'")
                }
                break
            }
    
            // MACRO identifierp '(' _stmt_6r _stmt_7o @ ')' _stmt_13o block
            if p.PeekToken().Kind != tkRP {
                p.ErrorUnexpected(p.PeekToken(), "')'")
            }
            _6 := p.ConsumeToken(); _ = _6
    
            // MACRO identifierp '(' _stmt_6r _stmt_7o ')' @ _stmt_13o block
            var _7 Value; _ = _7
            for {
                res := &_7; _ = res
                // RULE: _stmt_13o -> _stmt_12g?
                // RULE: _stmt_12g -> '[' _stmt_11r ']'
                switch p.PeekToken().Kind {
                case tkLS:
                        // @ '[' _stmt_11r ']'
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '[' @ _stmt_11r ']'
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _stmt_11r -> _stmt_10g*
                            // RULE: _stmt_10g -> identifier _stmt_9o
                            switch p.PeekToken().Kind {
                            case tkIDENTIFIER:
                                    // @ identifier _stmt_9o
                                    _1 := p._parseIdentifier(); _ = _1
                                    l := _1; r := Value(NIL)
                            
                                    // identifier @ _stmt_9o
                                    var _2 Value; _ = _2
                                    for {
                                        res := &_2; _ = res
                                        // RULE: _stmt_9o -> _stmt_8g?
                                        // RULE: _stmt_8g -> '=' symexpr
                                        switch p.PeekToken().Kind {
                                        case tkEQ:
                                                // @ '=' symexpr
                                                _1 := p.ConsumeToken(); _ = _1
                                        
                                                // '=' @ symexpr
                                                _2 := p._parseSymexpr(); _ = _2
                                                r = _2
                                        case tkIDENTIFIER, tkRS:
                                            // NOP
                                        default:
                                            p.ErrorUnexpected(p.PeekToken(), "'=', IDENTIFIER, ']'")
                                        }
                                        break
                                    }
                                    w.Push(l, r)
                            
                                    continue
                            case tkRS:
                                // NOP
                            default:
                                p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, ']'")
                            }
                            break
                        }
                
                        // '[' _stmt_11r @ ']'
                        if p.PeekToken().Kind != tkRS {
                            p.ErrorUnexpected(p.PeekToken(), "']'")
                        }
                        _3 := p.ConsumeToken(); _ = _3
                case tkLC, tkEQLC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'[', '{', '={'")
                }
                break
            }
    
            // MACRO identifierp '(' _stmt_6r _stmt_7o ')' _stmt_13o @ block
            _8 := p._parseBlock(); _ = _8
            res = &Vec{KwMacro.ToId(_1), _2, v, w, _5.Value, _8}
    case tkPROC:
            // @ PROC identifierp '(' sig ')' _stmt_14g
            _1 := p.ConsumeToken(); _ = _1
    
            // PROC @ identifierp '(' sig ')' _stmt_14g
            _2 := p._parseIdentifierp(); _ = _2
    
            // PROC identifierp @ '(' sig ')' _stmt_14g
            if p.PeekToken().Kind != tkLP {
                p.ErrorUnexpected(p.PeekToken(), "'('")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // PROC identifierp '(' @ sig ')' _stmt_14g
            _4 := p._parseSig(); _ = _4
    
            // PROC identifierp '(' sig @ ')' _stmt_14g
            if p.PeekToken().Kind != tkRP {
                p.ErrorUnexpected(p.PeekToken(), "')'")
            }
            _5 := p.ConsumeToken(); _ = _5
            v := &Vec{KwProc.ToId(_1), _2, _4}
    
            // PROC identifierp '(' sig ')' @ _stmt_14g
            var _6 Value; _ = _6
            for {
                res := &_6; _ = res
                // RULE: _stmt_14g -> block
                // RULE: _stmt_14g -> '@' dataexpr
                switch p.PeekToken().Kind {
                case tkLC, tkEQLC:
                        // @ block
                        _1 := p._parseBlock(); _ = _1
                        v.Push(_1)
                case tkAT:
                        // @ '@' dataexpr
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '@' @ dataexpr
                        _2 := p._parseDataexpr(); _ = _2
                        v.Push(_2)
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'{', '={', '@'")
                }
                break
            }
            res = v
    case tkCONST:
            // @ CONST _stmt_17g '=' dataexpr
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{}
    
            // CONST @ _stmt_17g '=' dataexpr
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _stmt_17g -> identifier
                // RULE: _stmt_17g -> identifierp '(' _stmt_16r ')'
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        *res = _1
                case tkIDENTIFIERP:
                        // @ identifierp '(' _stmt_16r ')'
                        _1 := p._parseIdentifierp(); _ = _1
                
                        // identifierp @ '(' _stmt_16r ')'
                        if p.PeekToken().Kind != tkLP {
                            p.ErrorUnexpected(p.PeekToken(), "'('")
                        }
                        _2 := p.ConsumeToken(); _ = _2
                
                        // identifierp '(' @ _stmt_16r ')'
                        var _3 Value; _ = _3
                        for {
                            res := &_3; _ = res
                            // RULE: _stmt_16r -> _stmt_15g*
                            // RULE: _stmt_15g -> identifier
                            // RULE: _stmt_15g -> label ':' dataexpr
                            switch p.PeekToken().Kind {
                            case tkIDENTIFIER:
                                    // @ identifier
                                    _1 := p._parseIdentifier(); _ = _1
                                    v.Push(&Vec{_1, NIL})
                            
                                    continue
                            case tkLABEL:
                                    // @ label ':' dataexpr
                                    _1 := p._parseLabel(); _ = _1
                            
                                    // label @ ':' dataexpr
                                    if p.PeekToken().Kind != tkCL {
                                        p.ErrorUnexpected(p.PeekToken(), "':'")
                                    }
                                    _2 := p.ConsumeToken(); _ = _2
                            
                                    // label ':' @ dataexpr
                                    _3 := p._parseDataexpr(); _ = _3
                                    v.Push(&Vec{_1, _3})
                            
                                    continue
                            case tkRP:
                                // NOP
                            default:
                                p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, LABEL, ')'")
                            }
                            break
                        }
                
                        // identifierp '(' _stmt_16r @ ')'
                        if p.PeekToken().Kind != tkRP {
                            p.ErrorUnexpected(p.PeekToken(), "')'")
                        }
                        _4 := p.ConsumeToken(); _ = _4
                        *res = _1
                default:
                    p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, IDENTIFIERP")
                }
                break
            }
    
            // CONST _stmt_17g @ '=' dataexpr
            if p.PeekToken().Kind != tkEQ {
                p.ErrorUnexpected(p.PeekToken(), "'='")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // CONST _stmt_17g '=' @ dataexpr
            _4 := p._parseDataexpr(); _ = _4
            res = &Vec{KwConst.ToId(_1), _2, v, _4}
    case tkDATA:
            // @ DATA datatype _stmt_19o databody
            _1 := p.ConsumeToken(); _ = _1
    
            // DATA @ datatype _stmt_19o databody
            _2 := p._parseDatatype(); _ = _2
            v := Value(NIL); w := _2
    
            // DATA datatype @ _stmt_19o databody
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _stmt_19o -> _stmt_18g?
                // RULE: _stmt_18g -> '=' datatype
                switch p.PeekToken().Kind {
                case tkEQ:
                        // @ '=' datatype
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '=' @ datatype
                        _2 := p._parseDatatype(); _ = _2
                        v = w; w = _2
                case tkBOP, tkCL, tkAT, tkLS, tkLC, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'=', BOP, ':', '@', '[', '{', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ';', EOF, '}'")
                }
                break
            }
    
            // DATA datatype _stmt_19o @ databody
            _4 := p._parseDatabody(); _ = _4
            res = &Vec{KwData.ToId(_1), v, w, _4}
    case tkMODULE:
            // @ MODULE identifier block
            _1 := p.ConsumeToken(); _ = _1
    
            // MODULE @ identifier block
            _2 := p._parseIdentifier(); _ = _2
    
            // MODULE identifier @ block
            _3 := p._parseBlock(); _ = _3
            res = &Vec{KwModule.ToId(_1), _2, _3}
    case tkLABEL:
            // @ label ':'
            _1 := p._parseLabel(); _ = _1
    
            // label @ ':'
            if p.PeekToken().Kind != tkCL {
                p.ErrorUnexpected(p.PeekToken(), "':'")
            }
            _2 := p.ConsumeToken(); _ = _2
            res = &Vec{KwLabel.ToId(_2), _1}; p.state = pstNl
    case tkSTRUCT:
            // @ struct
            _1 := p._parseStruct(); _ = _1
            v := _1.(*Vec); v.SetAt(1, NIL); res = v
    case tkIDENTIFIER, tkCONDDOT, tkATMI, tkIDENTIFIERP, tkREG, tkLS, tkDLMI, tkDLDLMI:
            // @ expr
            _1 := p._parseExpr(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "MACRO, PROC, CONST, DATA, MODULE, LABEL, STRUCT, IDENTIFIER, CONDDOT, '@-', IDENTIFIERP, REG, '[', '$-', '$$-'")
    }
    return
}

/** ** **
  struct ->
      STRUCT identifier? '{' structfield? (
        ';' structfield?
      )* '}'
 ** ** **/
func (p *Parser) _parseStruct() (res Value) {
    // RULE: struct -> STRUCT _struct_20o '{' _struct_21o _struct_24r '}'
    switch p.PeekToken().Kind {
    case tkSTRUCT:
            // @ STRUCT _struct_20o '{' _struct_21o _struct_24r '}'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwStruct.ToId(_1), Int(1), NIL}
    
            // STRUCT @ _struct_20o '{' _struct_21o _struct_24r '}'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _struct_20o -> identifier
                // RULE: _struct_20o -> 
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ identifier
                        _1 := p._parseIdentifier(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkLC:
                        // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, '{'")
                }
                break
            }
            if _2 != nil { v.SetAt(2, _2) }
    
            // STRUCT _struct_20o @ '{' _struct_21o _struct_24r '}'
            if p.PeekToken().Kind != tkLC {
                p.ErrorUnexpected(p.PeekToken(), "'{'")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // STRUCT _struct_20o '{' @ _struct_21o _struct_24r '}'
            var _4 Value; _ = _4
            for {
                res := &_4; _ = res
                // RULE: _struct_21o -> structfield
                // RULE: _struct_21o -> 
                switch p.PeekToken().Kind {
                case tkIDENTIFIER:
                        // @ structfield
                        _1 := p._parseStructfield(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkSC, tkRC:
                        // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, ';', '}'")
                }
                break
            }
            if _4 != nil { v.Push(_4) }
    
            // STRUCT _struct_20o '{' _struct_21o @ _struct_24r '}'
            var _5 Value; _ = _5
            for {
                res := &_5; _ = res
                // RULE: _struct_24r -> _struct_23g*
                // RULE: _struct_23g -> ';' _struct_22o
                switch p.PeekToken().Kind {
                case tkSC:
                        // @ ';' _struct_22o
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ';' @ _struct_22o
                        var _2 Value; _ = _2
                        for {
                            res := &_2; _ = res
                            // RULE: _struct_22o -> structfield
                            // RULE: _struct_22o -> 
                            switch p.PeekToken().Kind {
                            case tkIDENTIFIER:
                                    // @ structfield
                                    _1 := p._parseStructfield(); _ = _1
                                    *res = _1 // DEFAULT OPT ACTION
                            case tkSC, tkRC:
                                    // NOP
                            default:
                                p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, ';', '}'")
                            }
                            break
                        }
                        if _2 != nil { v.Push(_2) }
                
                        continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "';', '}'")
                }
                break
            }
    
            // STRUCT _struct_20o '{' _struct_21o _struct_24r @ '}'
            if p.PeekToken().Kind != tkRC {
                p.ErrorUnexpected(p.PeekToken(), "'}'")
            }
            _6 := p.ConsumeToken(); _ = _6
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "STRUCT")
    }
    return
}

/** ** **
  structfield ->
      identifier datatype
 ** ** **/
func (p *Parser) _parseStructfield() (res Value) {
    // RULE: structfield -> identifier datatype
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ identifier datatype
            _1 := p._parseIdentifier(); _ = _1
    
            // identifier @ datatype
            _2 := p._parseDatatype(); _ = _2
            res = &Vec{_1, _2}
    default:
        p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER")
    }
    return
}

/** ** **
  datatype ->
      '[' (
        constexpr
      )? ']' datatype
    | identifier
    | struct
 ** ** **/
func (p *Parser) _parseDatatype() (res Value) {
    // RULE: datatype -> '[' _datatype_26o ']' datatype
    // RULE: datatype -> identifier
    // RULE: datatype -> struct
    switch p.PeekToken().Kind {
    case tkLS:
            // @ '[' _datatype_26o ']' datatype
            _1 := p.ConsumeToken(); _ = _1
            v := Value(NIL)
    
            // '[' @ _datatype_26o ']' datatype
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _datatype_26o -> _datatype_25g?
                // RULE: _datatype_25g -> constexpr
                switch p.PeekToken().Kind {
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ constexpr
                        _1 := p._parseConstexpr(); _ = _1
                        v = _1
                case tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ']'")
                }
                break
            }
    
            // '[' _datatype_26o @ ']' datatype
            if p.PeekToken().Kind != tkRS {
                p.ErrorUnexpected(p.PeekToken(), "']'")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // '[' _datatype_26o ']' @ datatype
            _4 := p._parseDatatype(); _ = _4
            res = &Vec{KwArray.ToId(_1), _4, v}
    case tkIDENTIFIER:
            // @ identifier
            _1 := p._parseIdentifier(); _ = _1
            res = _1
    case tkSTRUCT:
            // @ struct
            _1 := p._parseStruct(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "'[', IDENTIFIER, STRUCT")
    }
    return
}

/** ** **
  databody ->
      (
        datalist
      | constval
      )? (
        BOP dataval
      )? (
        ':' identifier
      | '@' dataexpr
      )?
 ** ** **/
func (p *Parser) _parseDatabody() (res Value) {
    // RULE: databody -> _databody_28o _databody_30o _databody_32o
    values := Value(NIL);
    switch p.PeekToken().Kind {
    case tkLS, tkLC, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkBOP, tkCL, tkAT, tkSC, tkEOF, tkRC:
            // @ _databody_28o _databody_30o _databody_32o
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _databody_28o -> _databody_27g?
                // RULE: _databody_27g -> datalist
                // RULE: _databody_27g -> constval
                switch p.PeekToken().Kind {
                case tkLS, tkLC:
                        // @ datalist
                        _1 := p._parseDatalist(); _ = _1
                        values = _1
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ constval
                        _1 := p._parseConstval(); _ = _1
                        values = _1
                case tkBOP, tkCL, tkAT, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'[', '{', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, BOP, ':', '@', ';', EOF, '}'")
                }
                break
            }
            alloc := Value(idMulOp);
                                                     size := Value(InternalConstexpr(Int(1)))
    
            // _databody_28o @ _databody_30o _databody_32o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _databody_30o -> _databody_29g?
                // RULE: _databody_29g -> BOP dataval
                switch p.PeekToken().Kind {
                case tkBOP:
                        // @ BOP dataval
                        _1 := p.ConsumeToken(); _ = _1
                
                        // BOP @ dataval
                        _2 := p._parseDataval(); _ = _2
                        alloc = _1.Value; size = _2
                case tkCL, tkAT, tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "BOP, ':', '@', ';', EOF, '}'")
                }
                break
            }
            section := Value(NIL); addr := Value(NIL)
    
            // _databody_28o _databody_30o @ _databody_32o
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _databody_32o -> _databody_31g?
                // RULE: _databody_31g -> ':' identifier
                // RULE: _databody_31g -> '@' dataexpr
                switch p.PeekToken().Kind {
                case tkCL:
                        // @ ':' identifier
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ':' @ identifier
                        _2 := p._parseIdentifier(); _ = _2
                        section = _2
                case tkAT:
                        // @ '@' dataexpr
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '@' @ dataexpr
                        _2 := p._parseDataexpr(); _ = _2
                        addr = _2
                case tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "':', '@', ';', EOF, '}'")
                }
                break
            }
            res = &Vec{values, alloc, size, section, addr }
    default:
        p.ErrorUnexpected(p.PeekToken(), "'[', '{', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, BOP, ':', '@', ';', EOF, '}'")
    }
    return
}

/** ** **
  datalist ->
      '[' (
        dataexpr
      | datalist
      )* ']'
    | '{' (
        dataexpr
      | datalist
      )* '}'
 ** ** **/
func (p *Parser) _parseDatalist() (res Value) {
    // RULE: datalist -> '[' _datalist_34r ']'
    // RULE: datalist -> '{' _datalist_36r '}'
    switch p.PeekToken().Kind {
    case tkLS:
            // @ '[' _datalist_34r ']'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwDataList.ToId(_1)}
    
            // '[' @ _datalist_34r ']'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _datalist_34r -> _datalist_33g*
                // RULE: _datalist_33g -> dataexpr
                // RULE: _datalist_33g -> datalist
                switch p.PeekToken().Kind {
                case tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ dataexpr
                        _1 := p._parseDataexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkLS, tkLC:
                        // @ datalist
                        _1 := p._parseDatalist(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '[', '{', ']'")
                }
                break
            }
    
            // '[' _datalist_34r @ ']'
            if p.PeekToken().Kind != tkRS {
                p.ErrorUnexpected(p.PeekToken(), "']'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = v
    case tkLC:
            // @ '{' _datalist_36r '}'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwStructData.ToId(_1)}
                                                     p.contexts = append(p.contexts, '#')
    
            // '{' @ _datalist_36r '}'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _datalist_36r -> _datalist_35g*
                // RULE: _datalist_35g -> dataexpr
                // RULE: _datalist_35g -> datalist
                switch p.PeekToken().Kind {
                case tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ dataexpr
                        _1 := p._parseDataexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkLS, tkLC:
                        // @ datalist
                        _1 := p._parseDatalist(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '[', '{', '}'")
                }
                break
            }
    
            // '{' _datalist_36r @ '}'
            if p.PeekToken().Kind != tkRC {
                p.ErrorUnexpected(p.PeekToken(), "'}'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "'[', '{'")
    }
    return
}

/** ** **
  dataexpr ->
      constexpr
    | explicitval
 ** ** **/
func (p *Parser) _parseDataexpr() (res Value) {
    // RULE: dataexpr -> constexpr
    // RULE: dataexpr -> explicitval
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ constexpr
            _1 := p._parseConstexpr(); _ = _1
            res = _1
    case tkDLMI, tkDLDLMI:
            // @ explicitval
            _1 := p._parseExplicitval(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '$-', '$$-'")
    }
    return
}

/** ** **
  dataval ->
      constval
    | explicitval
 ** ** **/
func (p *Parser) _parseDataval() (res Value) {
    // RULE: dataval -> constval
    // RULE: dataval -> explicitval
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ constval
            _1 := p._parseConstval(); _ = _1
            res = _1
    case tkDLMI, tkDLDLMI:
            // @ explicitval
            _1 := p._parseExplicitval(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '$-', '$$-'")
    }
    return
}

/** ** **
  symexpr ->
      '%{' symval (
        symval
      )* '}'
 ** ** **/
func (p *Parser) _parseSymexpr() (res Value) {
    // RULE: symexpr -> '%{' symval _symexpr_38r '}'
    switch p.PeekToken().Kind {
    case tkPELC:
            // @ '%{' symval _symexpr_38r '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // '%{' @ symval _symexpr_38r '}'
            _2 := p._parseSymval(); _ = _2
            v := &Vec{KwMakeId.ToId(_1), _2}
    
            // '%{' symval @ _symexpr_38r '}'
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _symexpr_38r -> _symexpr_37g*
                // RULE: _symexpr_37g -> symval
                switch p.PeekToken().Kind {
                case tkIDENTIFIER, tkSTRING:
                        // @ symval
                        _1 := p._parseSymval(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, STRING, '}'")
                }
                break
            }
    
            // '%{' symval _symexpr_38r @ '}'
            if p.PeekToken().Kind != tkRC {
                p.ErrorUnexpected(p.PeekToken(), "'}'")
            }
            _4 := p.ConsumeToken(); _ = _4
            res = _constexpr(v, _1)
    default:
        p.ErrorUnexpected(p.PeekToken(), "'%{'")
    }
    return
}

/** ** **
  symval ->
      IDENTIFIER
    | STRING
 ** ** **/
func (p *Parser) _parseSymval() (res Value) {
    // RULE: symval -> IDENTIFIER
    // RULE: symval -> STRING
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ IDENTIFIER
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkSTRING:
            // @ STRING
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    default:
        p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, STRING")
    }
    return
}

/** ** **
  sig ->
      (
        '-*'
      )? regs (
        '=>' regs
      )? (
        '!' regs
      )?
 ** ** **/
func (p *Parser) _parseSig() (res Value) {
    // RULE: sig -> _sig_40o regs _sig_42o _sig_44o
    v := &Vec{NIL, NIL, NIL, NIL}
    switch p.PeekToken().Kind {
    case tkMIAS, tkREG, tkEQGT, tkEX, tkRP:
            // @ _sig_40o regs _sig_42o _sig_44o
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _sig_40o -> _sig_39g?
                // RULE: _sig_39g -> '-*'
                switch p.PeekToken().Kind {
                case tkMIAS:
                        // @ '-*'
                        _1 := p.ConsumeToken(); _ = _1
                        v.SetAt(3, Int(1))
                case tkREG, tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'-*', REG, '=>', '!', ')'")
                }
                break
            }
    
            // _sig_40o @ regs _sig_42o _sig_44o
            _2 := p._parseRegs(); _ = _2
            v.SetAt(0, _2)
    
            // _sig_40o regs @ _sig_42o _sig_44o
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _sig_42o -> _sig_41g?
                // RULE: _sig_41g -> '=>' regs
                switch p.PeekToken().Kind {
                case tkEQGT:
                        // @ '=>' regs
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '=>' @ regs
                        _2 := p._parseRegs(); _ = _2
                        v.SetAt(1, _2)
                case tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'=>', '!', ')'")
                }
                break
            }
    
            // _sig_40o regs _sig_42o @ _sig_44o
            var _4 Value; _ = _4
            for {
                res := &_4; _ = res
                // RULE: _sig_44o -> _sig_43g?
                // RULE: _sig_43g -> '!' regs
                switch p.PeekToken().Kind {
                case tkEX:
                        // @ '!' regs
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '!' @ regs
                        _2 := p._parseRegs(); _ = _2
                        v.SetAt(2, _2)
                case tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'!', ')'")
                }
                break
            }
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "'-*', REG, '=>', '!', ')'")
    }
    return
}

/** ** **
  regs ->
      (
        REG
      )*
 ** ** **/
func (p *Parser) _parseRegs() (res Value) {
    // RULE: regs -> _regs_46r
    v := &Vec{}
    switch p.PeekToken().Kind {
    case tkREG, tkEQGT, tkEX, tkRP:
            // @ _regs_46r
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _regs_46r -> _regs_45g*
                // RULE: _regs_45g -> REG
                switch p.PeekToken().Kind {
                case tkREG:
                        // @ REG
                        _1 := p.ConsumeToken(); _ = _1
                        v.Push(_1.Value)
                
                        continue
                case tkEQGT, tkEX, tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "REG, '=>', '!', ')'")
                }
                break
            }
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "REG, '=>', '!', ')'")
    }
    return
}

/** ** **
  block ->
      '{' program '}'
    | '={' program '}'
 ** ** **/
func (p *Parser) _parseBlock() (res Value) {
    // RULE: block -> '{' program '}'
    // RULE: block -> '={' program '}'
    switch p.PeekToken().Kind {
    case tkLC:
            // @ '{' program '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // '{' @ program '}'
            _2 := p._parseProgram(); _ = _2
    
            // '{' program @ '}'
            if p.PeekToken().Kind != tkRC {
                p.ErrorUnexpected(p.PeekToken(), "'}'")
            }
            _3 := p.ConsumeToken(); _ = _3
            v := _2.(*Vec); v.SetAt(0, KwProg.ToId(_1)); res = v
    case tkEQLC:
            // @ '={' program '}'
            _1 := p.ConsumeToken(); _ = _1
    
            // '={' @ program '}'
            _2 := p._parseProgram(); _ = _2
    
            // '={' program @ '}'
            if p.PeekToken().Kind != tkRC {
                p.ErrorUnexpected(p.PeekToken(), "'}'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = _2
    default:
        p.ErrorUnexpected(p.PeekToken(), "'{', '={'")
    }
    return
}

/** ** **
  expr ->
      identifier (
        oper
      )*
    | callproc
    | contextexpr
 ** ** **/
func (p *Parser) _parseExpr() (res Value) {
    // RULE: expr -> identifier _expr_48r
    // RULE: expr -> callproc
    // RULE: expr -> contextexpr
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ identifier _expr_48r
            _1 := p._parseIdentifier(); _ = _1
            v := &Vec{_idfrom(_1)}
    
            // identifier @ _expr_48r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _expr_48r -> _expr_47g*
                // RULE: _expr_47g -> oper
                switch p.PeekToken().Kind {
                case tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ oper
                        _1 := p._parseOper(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkSC, tkEOF, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ';', EOF, '}'")
                }
                break
            }
            res = v
    case tkCONDDOT, tkIDENTIFIERP:
            // @ callproc
            _1 := p._parseCallproc(); _ = _1
            res = _1
    case tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI:
            // @ contextexpr
            _1 := p._parseContextexpr(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER, CONDDOT, IDENTIFIERP, '@-', REG, '[', '$-', '$$-'")
    }
    return
}

/** ** **
  callproc ->
      CONDDOT? identifierp '(' sig ')'
 ** ** **/
func (p *Parser) _parseCallproc() (res Value) {
    // RULE: callproc -> _callproc_49o identifierp '(' sig ')'
    switch p.PeekToken().Kind {
    case tkCONDDOT, tkIDENTIFIERP:
            // @ _callproc_49o identifierp '(' sig ')'
            var _1 *Token; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _callproc_49o -> CONDDOT
                // RULE: _callproc_49o -> 
                switch p.PeekToken().Kind {
                case tkCONDDOT:
                        // @ CONDDOT
                        _1 := p.ConsumeToken(); _ = _1
                        *res = _1 // DEFAULT OPT ACTION
                case tkIDENTIFIERP:
                        *res = NILTK
                default:
                    p.ErrorUnexpected(p.PeekToken(), "CONDDOT, IDENTIFIERP")
                }
                break
            }
    
            // _callproc_49o @ identifierp '(' sig ')'
            _2 := p._parseIdentifierp(); _ = _2
    
            // _callproc_49o identifierp @ '(' sig ')'
            if p.PeekToken().Kind != tkLP {
                p.ErrorUnexpected(p.PeekToken(), "'('")
            }
            _3 := p.ConsumeToken(); _ = _3
    
            // _callproc_49o identifierp '(' @ sig ')'
            _4 := p._parseSig(); _ = _4
    
            // _callproc_49o identifierp '(' sig @ ')'
            if p.PeekToken().Kind != tkRP {
                p.ErrorUnexpected(p.PeekToken(), "')'")
            }
            _5 := p.ConsumeToken(); _ = _5
            res = &Vec{KwCallproc.ToId(_3), _2, _1.Value, _4, KwCall}
    default:
        p.ErrorUnexpected(p.PeekToken(), "CONDDOT, IDENTIFIERP")
    }
    return
}

/** ** **
  contextexpr ->
      (
        regld
      | mem
      | explicitval
      | '@-' prim
      ) (
        UOP
      | BOP oper
      | DOP dotarg
      )*
 ** ** **/
func (p *Parser) _parseContextexpr() (res Value) {
    // RULE: contextexpr -> _contextexpr_50g _contextexpr_52r
    v := &Vec{_markerid(p, KwWith)}
    switch p.PeekToken().Kind {
    case tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI:
            // @ _contextexpr_50g _contextexpr_52r
            var _1 Value; _ = _1
            for {
                res := &_1; _ = res
                // RULE: _contextexpr_50g -> regld
                // RULE: _contextexpr_50g -> mem
                // RULE: _contextexpr_50g -> explicitval
                // RULE: _contextexpr_50g -> '@-' prim
                switch p.PeekToken().Kind {
                case tkREG:
                        // @ regld
                        _1 := p._parseRegld(); _ = _1
                        v = _1.(*Vec)
                case tkLS:
                        // @ mem
                        _1 := p._parseMem(); _ = _1
                        v.Push(_1)
                case tkDLMI, tkDLDLMI:
                        // @ explicitval
                        _1 := p._parseExplicitval(); _ = _1
                        v.Push(_1)
                case tkATMI:
                        // @ '@-' prim
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '@-' @ prim
                        _2 := p._parsePrim(); _ = _2
                        v.Push(p.cc.KwRegA.ToId(_1), &Vec{KwLeftArrow.ToId(_1), _2})
                default:
                    p.ErrorUnexpected(p.PeekToken(), "REG, '[', '$-', '$$-', '@-'")
                }
                break
            }
    
            // _contextexpr_50g @ _contextexpr_52r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _contextexpr_52r -> _contextexpr_51g*
                // RULE: _contextexpr_51g -> UOP
                // RULE: _contextexpr_51g -> BOP oper
                // RULE: _contextexpr_51g -> DOP dotarg
                switch p.PeekToken().Kind {
                case tkUOP:
                        // @ UOP
                        _1 := p.ConsumeToken(); _ = _1
                        v.Push(&Vec{_1.Value, NIL})
                
                        continue
                case tkBOP:
                        // @ BOP oper
                        _1 := p.ConsumeToken(); _ = _1
                
                        // BOP @ oper
                        _2 := p._parseOper(); _ = _2
                        v.Push(&Vec{_1.Value, _2})
                
                        continue
                case tkDOP:
                        // @ DOP dotarg
                        _1 := p.ConsumeToken(); _ = _1
                
                        // DOP @ dotarg
                        _2 := p._parseDotarg(); _ = _2
                        v.Push(&Vec{_1.Value, _2})
                
                        continue
                case tkSC, tkEOF, tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkRC, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "UOP, BOP, DOP, ';', EOF, '@-', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '}', ']'")
                }
                break
            }
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "'@-', REG, '[', '$-', '$$-'")
    }
    return
}

/** ** **
  oper ->
      prim (
        ':' prim
      )?
 ** ** **/
func (p *Parser) _parseOper() (res Value) {
    // RULE: oper -> prim _oper_54o
    switch p.PeekToken().Kind {
    case tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ prim _oper_54o
            _1 := p._parsePrim(); _ = _1
            v := _1
    
            // prim @ _oper_54o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _oper_54o -> _oper_53g?
                // RULE: _oper_53g -> ':' prim
                switch p.PeekToken().Kind {
                case tkCL:
                        // @ ':' prim
                        _1 := p.ConsumeToken(); _ = _1
                
                        // ':' @ prim
                        _2 := p._parsePrim(); _ = _2
                        v = &Vec{KwTpl.ToId(_1), v, _2}
                case tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkUOP, tkBOP, tkDOP, tkSC, tkEOF, tkRC, tkATMI, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "':', COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, UOP, BOP, DOP, ';', EOF, '}', '@-', ']'")
                }
                break
            }
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  prim ->
      COND
    | regld
    | mem
    | dataval
    | block
 ** ** **/
func (p *Parser) _parsePrim() (res Value) {
    // RULE: prim -> COND
    // RULE: prim -> regld
    // RULE: prim -> mem
    // RULE: prim -> dataval
    // RULE: prim -> block
    switch p.PeekToken().Kind {
    case tkCOND:
            // @ COND
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkREG:
            // @ regld
            _1 := p._parseRegld(); _ = _1
            res = _maybeunwrapwith(_1)
    case tkLS:
            // @ mem
            _1 := p._parseMem(); _ = _1
            res = _1
    case tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ dataval
            _1 := p._parseDataval(); _ = _1
            res = _1
    case tkLC, tkEQLC:
            // @ block
            _1 := p._parseBlock(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "COND, REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, '{', '={'")
    }
    return
}

/** ** **
  regld ->
      REG (
        '-@' prim
      )?
 ** ** **/
func (p *Parser) _parseRegld() (res Value) {
    // RULE: regld -> REG _regld_56o
    switch p.PeekToken().Kind {
    case tkREG:
            // @ REG _regld_56o
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwWith.ToId(_1), _1.Value}
    
            // REG @ _regld_56o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _regld_56o -> _regld_55g?
                // RULE: _regld_55g -> '-@' prim
                switch p.PeekToken().Kind {
                case tkMIAT:
                        // @ '-@' prim
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '-@' @ prim
                        _2 := p._parsePrim(); _ = _2
                        v.Push(&Vec{KwLeftArrow.ToId(_1), _2})
                case tkCL, tkUOP, tkBOP, tkDOP, tkCOND, tkLC, tkEQLC, tkREG, tkLS, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP, tkSC, tkEOF, tkATMI, tkRC, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'-@', ':', UOP, BOP, DOP, COND, '{', '={', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ';', EOF, '@-', '}', ']'")
                }
                break
            }
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "REG")
    }
    return
}

/** ** **
  mem ->
      '[' (
        contextexpr
      | constexpr
      )* ']'
 ** ** **/
func (p *Parser) _parseMem() (res Value) {
    // RULE: mem -> '[' _mem_58r ']'
    switch p.PeekToken().Kind {
    case tkLS:
            // @ '[' _mem_58r ']'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{KwMem.ToId(_1)}
    
            // '[' @ _mem_58r ']'
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _mem_58r -> _mem_57g*
                // RULE: _mem_57g -> contextexpr
                // RULE: _mem_57g -> constexpr
                switch p.PeekToken().Kind {
                case tkATMI, tkREG, tkLS, tkDLMI, tkDLDLMI:
                        // @ contextexpr
                        _1 := p._parseContextexpr(); _ = _1
                        v.Push(_maybeunwrapwith(_1))
                
                        continue
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ constexpr
                        _1 := p._parseConstexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'@-', REG, '[', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ']'")
                }
                break
            }
    
            // '[' _mem_58r @ ']'
            if p.PeekToken().Kind != tkRS {
                p.ErrorUnexpected(p.PeekToken(), "']'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = v
    default:
        p.ErrorUnexpected(p.PeekToken(), "'['")
    }
    return
}

/** ** **
  dotarg ->
      callproc
    | regld
    | block
 ** ** **/
func (p *Parser) _parseDotarg() (res Value) {
    // RULE: dotarg -> callproc
    // RULE: dotarg -> regld
    // RULE: dotarg -> block
    switch p.PeekToken().Kind {
    case tkCONDDOT, tkIDENTIFIERP:
            // @ callproc
            _1 := p._parseCallproc(); _ = _1
            res = _1
    case tkREG:
            // @ regld
            _1 := p._parseRegld(); _ = _1
            res = _1
    case tkLC, tkEQLC:
            // @ block
            _1 := p._parseBlock(); _ = _1
            res = _1
    default:
        p.ErrorUnexpected(p.PeekToken(), "CONDDOT, IDENTIFIERP, REG, '{', '={'")
    }
    return
}

/** ** **
  explicitval ->
      '$-' constval
    | '$$-' constval
 ** ** **/
func (p *Parser) _parseExplicitval() (res Value) {
    // RULE: explicitval -> '$-' constval
    // RULE: explicitval -> '$$-' constval
    switch p.PeekToken().Kind {
    case tkDLMI:
            // @ '$-' constval
            _1 := p.ConsumeToken(); _ = _1
    
            // '$-' @ constval
            _2 := p._parseConstval(); _ = _2
            res = _2
    case tkDLDLMI:
            // @ '$$-' constval
            _1 := p.ConsumeToken(); _ = _1
    
            // '$$-' @ constval
            _2 := p._parseConstval(); _ = _2
            res = &Vec{KwValueOf.ToId(_1), _2}
    default:
        p.ErrorUnexpected(p.PeekToken(), "'$-', '$$-'")
    }
    return
}

/** ** **
  constexpr ->
      iexpr
 ** ** **/
func (p *Parser) _parseConstexpr() (res Value) {
    // RULE: constexpr -> iexpr
    here := _marker(p)
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ iexpr
            _1 := p._parseIexpr(); _ = _1
            res = _constexpr(_1, here)
    default:
        p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  constval ->
      ival
 ** ** **/
func (p *Parser) _parseConstval() (res Value) {
    // RULE: constval -> ival
    here := _marker(p)
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ ival
            _1 := p._parseIval(); _ = _1
            res = _constexpr(_1, here)
    default:
        p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  iexpr ->
      ival (
        BOP ival
      )*
 ** ** **/
func (p *Parser) _parseIexpr() (res Value) {
    // RULE: iexpr -> ival _iexpr_60r
    switch p.PeekToken().Kind {
    case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
            // @ ival _iexpr_60r
            _1 := p._parseIval(); _ = _1
            v := []Value{_1}
    
            // ival @ _iexpr_60r
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _iexpr_60r -> _iexpr_59g*
                // RULE: _iexpr_59g -> BOP ival
                switch p.PeekToken().Kind {
                case tkBOP:
                        // @ BOP ival
                        _1 := p.ConsumeToken(); _ = _1
                
                        // BOP @ ival
                        _2 := p._parseIval(); _ = _2
                        v = p.cc.orderByPrec(v, _1.Value.(*Identifier), _2)
                
                        continue
                case tkRP, tkIDENTIFIER, tkLABEL, tkSC, tkEOF, tkLS, tkLC, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkAOP, tkATMI, tkREG, tkRS, tkREST, tkRC:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "BOP, ')', IDENTIFIER, LABEL, ';', EOF, '[', '{', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIERP, '(', AOP, '@-', REG, ']', REST, '}'")
                }
                break
            }
            res = p.cc.orderByPrec(v, idOpLast, nil)[0]
    default:
        p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  ival ->
      INTEGER
    | STRING
    | RESERVED
    | IDENTIFIER (
        '.-' IDENTIFIER (
          '.-' IDENTIFIER
        )*
      )?
    | IDENTIFIERP '(' (
        iexpr
      )* ')'
    | '(' iexpr ')'
    | AOP ival
 ** ** **/
func (p *Parser) _parseIval() (res Value) {
    // RULE: ival -> INTEGER
    // RULE: ival -> STRING
    // RULE: ival -> RESERVED
    // RULE: ival -> IDENTIFIER _ival_64o
    // RULE: ival -> IDENTIFIERP '(' _ival_66r ')'
    // RULE: ival -> '(' iexpr ')'
    // RULE: ival -> AOP ival
    switch p.PeekToken().Kind {
    case tkINTEGER:
            // @ INTEGER
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkSTRING:
            // @ STRING
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkRESERVED:
            // @ RESERVED
            _1 := p.ConsumeToken(); _ = _1
            res = _1.Value
    case tkIDENTIFIER:
            // @ IDENTIFIER _ival_64o
            _1 := p.ConsumeToken(); _ = _1
            v := _1.Value
    
            // IDENTIFIER @ _ival_64o
            var _2 Value; _ = _2
            for {
                res := &_2; _ = res
                // RULE: _ival_64o -> _ival_63g?
                // RULE: _ival_63g -> '.-' IDENTIFIER _ival_62r
                switch p.PeekToken().Kind {
                case tkDTMI:
                        // @ '.-' IDENTIFIER _ival_62r
                        _1 := p.ConsumeToken(); _ = _1
                
                        // '.-' @ IDENTIFIER _ival_62r
                        if p.PeekToken().Kind != tkIDENTIFIER {
                            p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER")
                        }
                        _2 := p.ConsumeToken(); _ = _2
                        w := &Vec{KwField.ToId(_1), v, _2.Value}
                
                        // '.-' IDENTIFIER @ _ival_62r
                        var _3 Value; _ = _3
                        for {
                            res := &_3; _ = res
                            // RULE: _ival_62r -> _ival_61g*
                            // RULE: _ival_61g -> '.-' IDENTIFIER
                            switch p.PeekToken().Kind {
                            case tkDTMI:
                                    // @ '.-' IDENTIFIER
                                    _1 := p.ConsumeToken(); _ = _1
                            
                                    // '.-' @ IDENTIFIER
                                    if p.PeekToken().Kind != tkIDENTIFIER {
                                        p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER")
                                    }
                                    _2 := p.ConsumeToken(); _ = _2
                                    w.Push(_2.Value)
                            
                                    continue
                            case tkBOP, tkCL, tkIDENTIFIER, tkLABEL, tkSC, tkEOF, tkLS, tkLC, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkAOP, tkUOP, tkDOP, tkRP, tkATMI, tkREG, tkAT, tkCOND, tkEQLC, tkREST, tkRC, tkRS:
                                // NOP
                            default:
                                p.ErrorUnexpected(p.PeekToken(), "'.-', BOP, ':', IDENTIFIER, LABEL, ';', EOF, '[', '{', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIERP, '(', AOP, UOP, DOP, ')', '@-', REG, '@', COND, '={', REST, '}', ']'")
                            }
                            break
                        }
                        v = w
                case tkBOP, tkCL, tkIDENTIFIER, tkLABEL, tkSC, tkEOF, tkLS, tkLC, tkDLMI, tkDLDLMI, tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIERP, tkLP, tkAOP, tkUOP, tkDOP, tkRP, tkATMI, tkREG, tkAT, tkCOND, tkEQLC, tkREST, tkRC, tkRS:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "'.-', BOP, ':', IDENTIFIER, LABEL, ';', EOF, '[', '{', '$-', '$$-', INTEGER, STRING, RESERVED, IDENTIFIERP, '(', AOP, UOP, DOP, ')', '@-', REG, '@', COND, '={', REST, '}', ']'")
                }
                break
            }
            res = v
    case tkIDENTIFIERP:
            // @ IDENTIFIERP '(' _ival_66r ')'
            _1 := p.ConsumeToken(); _ = _1
            v := &Vec{ _1.Value }
    
            // IDENTIFIERP @ '(' _ival_66r ')'
            if p.PeekToken().Kind != tkLP {
                p.ErrorUnexpected(p.PeekToken(), "'('")
            }
            _2 := p.ConsumeToken(); _ = _2
    
            // IDENTIFIERP '(' @ _ival_66r ')'
            var _3 Value; _ = _3
            for {
                res := &_3; _ = res
                // RULE: _ival_66r -> _ival_65g*
                // RULE: _ival_65g -> iexpr
                switch p.PeekToken().Kind {
                case tkINTEGER, tkSTRING, tkRESERVED, tkIDENTIFIER, tkIDENTIFIERP, tkLP, tkAOP:
                        // @ iexpr
                        _1 := p._parseIexpr(); _ = _1
                        v.Push(_1)
                
                        continue
                case tkRP:
                    // NOP
                default:
                    p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP, ')'")
                }
                break
            }
    
            // IDENTIFIERP '(' _ival_66r @ ')'
            if p.PeekToken().Kind != tkRP {
                p.ErrorUnexpected(p.PeekToken(), "')'")
            }
            _4 := p.ConsumeToken(); _ = _4
            res = v
    case tkLP:
            // @ '(' iexpr ')'
            _1 := p.ConsumeToken(); _ = _1
    
            // '(' @ iexpr ')'
            _2 := p._parseIexpr(); _ = _2
    
            // '(' iexpr @ ')'
            if p.PeekToken().Kind != tkRP {
                p.ErrorUnexpected(p.PeekToken(), "')'")
            }
            _3 := p.ConsumeToken(); _ = _3
            res = _2
    case tkAOP:
            // @ AOP ival
            _1 := p.ConsumeToken(); _ = _1
    
            // AOP @ ival
            _2 := p._parseIval(); _ = _2
            res = &Vec{ _1.Value, _2 }
    default:
        p.ErrorUnexpected(p.PeekToken(), "INTEGER, STRING, RESERVED, IDENTIFIER, IDENTIFIERP, '(', AOP")
    }
    return
}

/** ** **
  identifier ->
      IDENTIFIER
 ** ** **/
func (p *Parser) _parseIdentifier() (res Value) {
    // RULE: identifier -> IDENTIFIER
    switch p.PeekToken().Kind {
    case tkIDENTIFIER:
            // @ IDENTIFIER
            _1 := p.ConsumeToken(); _ = _1
            res = _constexpr(_1.Value, _1)
    default:
        p.ErrorUnexpected(p.PeekToken(), "IDENTIFIER")
    }
    return
}

/** ** **
  identifierp ->
      IDENTIFIERP
 ** ** **/
func (p *Parser) _parseIdentifierp() (res Value) {
    // RULE: identifierp -> IDENTIFIERP
    switch p.PeekToken().Kind {
    case tkIDENTIFIERP:
            // @ IDENTIFIERP
            _1 := p.ConsumeToken(); _ = _1
            res = _constexpr(_1.Value, _1)
    default:
        p.ErrorUnexpected(p.PeekToken(), "IDENTIFIERP")
    }
    return
}

/** ** **
  label ->
      LABEL
 ** ** **/
func (p *Parser) _parseLabel() (res Value) {
    // RULE: label -> LABEL
    switch p.PeekToken().Kind {
    case tkLABEL:
            // @ LABEL
            _1 := p.ConsumeToken(); _ = _1
            res = _constexpr(_1.Value, _1)
    default:
        p.ErrorUnexpected(p.PeekToken(), "LABEL")
    }
    return
}
