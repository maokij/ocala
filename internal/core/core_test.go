package core_test

import (
	"ocala/internal/core"
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"os"
	"slices"
	"testing"
)

func compile(src string) ([]byte, string) {
	return ttarch.Compile(ttarch.BuildCompiler(), src)
}

func genlist(src string) (string, string) {
	return ttarch.GenList(ttarch.BuildCompiler(), src)
}

func TestCompileAndGenerate(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: arch", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			arch ttarch
			db 0 1 2 3
		`)
		g.Archs = map[string]func() *core.Compiler{
			"ttarch": ttarch.BuildCompiler,
		}
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: auto generate output path and list path", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.OutPath = ""
		g.GenList = true
		g.ListPath = ""
		g.CompileAndGenerate("testdata/test.oc")
		b, _ := os.ReadFile("testdata/test.bin")
		s, _ := os.ReadFile("testdata/test.lst")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, b, g.ErrorMessage())
		tt.Eq(t, tt.Unindent(`
				|                                            ; generated by ocala

				     - 0000                                 .org 0
				000000 0000[4] 00 01 02 03                  .byte 0, 1, 2, 3
		`)[1:]+"\n", string(s))
	})

	t.Run("ok: defs", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			db USERDEF
		`)
		g.Defs = []string{"USERDEF"}
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{1}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: variant", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompilerExt(), `flat!
			A -ext 1
		`)
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0x70, 0x01}, tt.Flush(g.OutWriter), g.ErrorMessage())
	})

	t.Run("error: arch required", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: the first statement must be an `arch` directive "+
			"unless the `-t` option is specified", g.ErrorMessage())
	})

	t.Run("error: invalid arch form", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			arch
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: the first statement must be an `arch` directive "+
			"unless the `-t` option is specified", g.ErrorMessage())
	})

	t.Run("error: unknown arch", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			arch unknown
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: unknown arch: unknown", g.ErrorMessage())
	})

	t.Run("error: full error message", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			// comment
			data byte [this-error]
		`))
		g.CompileAndGenerate("-")
		tt.Eq(t, tt.Unindent(`
			compile error: undefined name this-error
			[error #0]
			  at -:2:11
			   |data byte [this-error]
			   |           ^-- ??
		`)+"\n", string(g.FullErrorMessage()))
	})

	t.Run("error: full error message 2", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			macro m(a) { A <- %=a }
			flat!; m ""
		`))
		g.CompileAndGenerate("-")
		tt.Eq(t, tt.Unindent(`
			compile error: operand must be integer
			[error #0]
			  at -:2:9
			   |flat!; m ""
			   |         ^-- ??
			[error #1]
			  at internal identifier LD
			  from -:1:15
			   |macro m(a) { A <- %=a }
			   |               ^-- ??
			  from -:2:7
			   |flat!; m ""
			   |       ^-- ??
		`)+"\n", string(g.FullErrorMessage()))
	})

	t.Run("error: debug mode", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			compile-error "!"
		`))
		g.DebugMode = true
		g.CompileAndGenerate("-")
		tt.Prefix(t, "compile error: !\n-- ", g.ErrorMessage())
	})

	t.Run("error: open failed", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.CompileAndGenerate("./testdata/nothing.oc")
		tt.Prefix(t, "generate error: open ", g.ErrorMessage())
	})

	t.Run("error: write", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.OutPath = "./testdata"
		g.CompileAndGenerate("-")
		tt.Prefix(t, "generate error: open ", g.ErrorMessage())
	})

	t.Run("error: output file name required", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.OutPath = ""
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: output file name required", g.ErrorMessage())
	})

	t.Run("error: list file name required", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.GenList = true
		g.ListPath = ""
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: list file name required", g.ErrorMessage())
	})

	t.Run("error: invalid defs", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.Defs = []string{"loop"}
		g.CompileAndGenerate("-")
		tt.Eq(t, "compile error: loop is a builtin name", g.ErrorMessage())
	})
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list, mes := genlist(`
			link { org 0 0 1; merge text _; org 0xc000 0 0; merge bss _ }
			section text
			const c001 = 1

			module ModA {
				const c002 = 2
				proc f002(!) { RET }
			}

			pragma list-constants 0 "omit c003, c004"
			const c003 = 3
			module ModB {
				const c004 = 4
				proc f004(!) { RET }
			}
			pragma list-constants 1
			const c005 = 5
			pragma comment "comment"
			pragma comment "comment" 1 c003 "test" __ORG__

			proc f001(!) {
				const c006 = -(6)
				A <- c001
				A <- ModA:c002
				A <- c003
				A <- ModB:c004
				A <- c005
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				f001(!)
				ModA:f002(!)
				ModB:f004(!)
				RET
			}

			align 8
			data byte [0 1 2 3 4 5 6 7]
			data byte [1 2 "string" 0xABCD]
			data word [0 1 2 3]
			data word [1 2 's' 't' 'r' 'i' 'n' 'g' 0xABCD]
			data byte [0 1 2 3] * 4

			align 8
			data byte ["long long string byte\n"]

			L0: data byte load-file("./testdata/embed01.dat")

			section bss
			data byte * 16
			data word * 16
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            c001 = 1
			                                            ModA:c002 = 2
			                                            ; omit c003, c004
			                                            c005 = 5

			     - 0000                                 .org 0
			                                            ; comment
			                                            ; comment 1 3 "test" 0

			     - 0000                             f001:
			~                                            \.c006\.#\d+ = -\(6\)
			000000 0000[2] 23 01                        LD     A, 0+ c001
			000002 0002[2] 23 02                        LD     A, 0+ ModA:c002
			000004 0004[2] 23 03                        LD     A, 0+ c003
			000006 0006[2] 23 04                        LD     A, 0+ ModB:c004
			000008 0008[2] 23 05                        LD     A, 0+ c005
			00000a 000a[2] 23 04                        LD     A, 0+ (3 + 2) - 1
			00000c 000c[2] 23 01                        LD     A, 0+ lobyte(1)
			00000e 000e[2] 23 05                        LD     A, 0+ ((3 + 2) - 1) + lobyte(1)
			000010 0010[3] 03 00 00                     JSR    0+ f001
			000013 0013[3] 03 86 00                     JSR    0+ ModA:f002
			000016 0016[3] 03 87 00                     JSR    0+ ModB:f004
			000019 0019[1] 04                           RET

			00001a 001a[6] ..                           .align 8 ; (.defb 6)
			000020 0020[8] 00 01 02 03 04 05 06 07      .byte 0, 1, 2, 3, 4, 5, 6, 7
			000028 0028[2] 01 02                        .byte 1, 2
			00002a 002a[6] 73 74 72 69 6e 67            .byte "string"
			000030 0030[1] cd                           .byte 43981
			000031 0031[8] 00 00 01 00 02 00 03 00      .word 0, 1, 2, 3
			000039 0039[8] 01 00 02 00 73 00 74 00      .word 1, 2, 115, 116
			000041 0041[8] 72 00 69 00 6e 00 67 00      .word 114, 105, 110, 103
			000049 0049[2] cd ab                        .word 43981
			00004b 004b[4] 00 01 02 03                  .byte 0, 1, 2, 3
			00004f 004f[4] 00 01 02 03                  ; ... repeat 2/4
			000053 0053[4] 00 01 02 03                  ; ... repeat 3/4
			000057 0057[4] 00 01 02 03                  ; ... repeat 4/4
			00005b 005b[5] ..                           .align 8 ; (.defb 5)
			000060 0060[8] 6c 6f 6e 67 20 6c 6f 6e      .byte "long long string byte\n"
			          :[8] 67 20 73 74 72 69 6e 67
			          :[6] 20 62 79 74 65 0a
			     - 0076                             L0:
			000076 0076[16] ..                          .incbin "./testdata/embed01.dat"

			     - 0086                             ModA:f002:
			000086 0086[1] 04                           RET

			     - 0087                             ModB:f004:
			000087 0087[1] 04                           RET

			     - c000                                 .org 49152
			     - c000[16] ..                          .defb 16
			     - c010[32] ..                          .defw 16
		`)[1:]+"\n", list, mes)
	})

	t.Run("ok: pack-mode", func(t *testing.T) {
		list, mes := genlist(`
			link { org 0 0x4000 2; merge text ModA; org 0x4000 0 4; merge text ModB }
			module ModA { data byte [0x00 0x01] }
			module ModB { data byte [0x02 0x03] }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			000000 0000[2] 00 01                        .byte 0, 1

			     - 4000                                 .org 16384
			000002 4000[2] 02 03                        .byte 2, 3
		`)[1:]+"\n", list, mes)
	})

	t.Run("ok: trim asm operand", func(t *testing.T) {
		cc := ttarch.BuildCompiler()
		cc.TrimAsmOperand = true
		list, mes := ttarch.GenList(cc, `flat!
			A <- 123
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			000000 0000[2] 23 7b                        LD     A, 123
		`)[1:]+"\n", list, mes)
	})
}

func TestCompileCommentAndBlank(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			// comment
			/*
			 * comment
			 */

			db 1 /* comment */ 2

			db 1,
				2


			db 1 /* comment
			*/
			db (1 + /* comment
					 */ 2)
			db (1 /* comment
				   */ + /* comment
						 */ 2)
		`)
		tt.EqSlice(t, []byte{1, 2, 1, 2, 1, 3, 3}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the block comment is not terminated", `
				/* ...
			`,
			"the comma followed by blank lines is not allowed", `
				db 1,

				   2
			`,
			"the block comment must be followed by new line", `
				db 1 /* comment
				      */ 2
			`,
			"invalid comma", `
				db 1,,
			`,
			"invalid comma", `
				db 1 /*
				     */, 2
			`,
			"invalid comma", `
				db $(1 + 1
					 , + 2
			`,
			"invalid comma", `
				db $(1 + 1,, + 2
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "scan error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileArch(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			arch ttarch; data byte * 8
		`)
		tt.Eq(t, 8, len(dat), mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"current target arch is ttarch", `flat!
				arch mos6502
			`,
			"arch must be in toplevel", `flat!
				proc f(!) { arch ttarch }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileOrg(t *testing.T) {
	t.Run("ok: simple mode", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 256 1; merge text { data byte * 64 } }
		`)
		tt.Eq(t, 64, len(dat), dat, mes)
	})

	t.Run("ok: padding mode", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 256 2; merge text { data byte * 64 } }
		`)
		tt.Eq(t, 256, len(dat), dat, mes)
	})

	t.Run("ok: pack mode", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0 256 2; merge text { data byte * 64 }
				org 0 256 4; merge text { data byte * 64 }
			}
		`)
		tt.Eq(t, 256, len(dat), dat, mes)
	})

	t.Run("ok: skip mode", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 256 0; merge text { data byte * 256 } }
		`)
		tt.Eq(t, 0, len(dat), dat, mes)
	})

	t.Run("ok: __ORG__", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0x4000 256 1; merge text { dw __ORG__ }
				org 0x8000 256 1; merge text { dw __ORG__ }
			}
		`)
		tt.EqSlice(t, []byte{0x00, 0x40, 0x00, 0x80}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid org mode", `
				link { org 0 256 5 }
			`,
			"a pack mode must follow a fill/pack mode", `
				link { org 0 256 0; org 0 256 3 }
			`,
			"the orgin address required", `
				link { org 0 256 2; org -1 0 1 }
			`,
			"size limit exceeded(257/256)", `
				link { org 0 256 0; merge text { data byte * 257 } }
			`,
			"size limit exceeded(512/256)", `
				link {
					org 0 256 2; merge text { data byte * 256 }
					org 0 256 4; merge text { data byte * 256 }
				}
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileNamed(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"undefined name test", `flat!
				db test
			`,
			"undefined name test", `flat!
				module ModA { const test = 1 }
				db test
			`,
			"undefined name ModA:test", `flat!
				db ModA:test
			`,
			"undefined name ModA:test", `flat!
				module ModA { }
				db ModA:test
			`,
			"undefined name ModA:test", `flat!
				const test = 1
				module ModA { }
				db ModA:test
			`,
			"LD is not a namespace", `flat!
				db LD:test
			`,
			"L1 is not a namespace", `flat!
				L1: db L1:test
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileAlias(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro m001() { db 0 1 }
			alias am001 m001; am001
			proc i001(-*) { db 2 3; RET }
			alias ai001 i001; ai001(-*)
			proc l001(A => !) { RET }
			alias al001 l001; al001(A => !)
			l002:
			alias al002 l002; db al002
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3, 4, 3, 4, 0, 8}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown name unknown", `flat!
				alias a001 unknown
			`,
			"m001 is already defined", `flat!
				macro m001() { }
				alias m001 m001
			`,
			"aliases are not allowed for this type(module)", `flat!
				module m001 {}
				alias a001 m001
			`,
			"aliases are not allowed for this type(syntax)", `flat!
				alias a001 do
			`,
			"aliases are not allowed for this type(func)", `flat!
				alias a001 hibyte
			`,
			"aliases are not allowed for this type(inst)", `flat!
				alias a001 ADD
			`,
			"aliases are not allowed for this type(const)", `flat!
				const c001 = 1
				alias a001 c001
			`,
			"aliases are not allowed for this type(special)", `flat!
				alias a001 __PC__
			`,
			"aliases are not allowed for this type(invalid)", `flat!
				proc i001(-*) { alias a001 __PROC__ }
				i001(-*)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileProc(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RET }
			proc f003(!) { JMP __PROC__ }
			f001(!)
			f002(!)
			f003(!)

			proc f004(A B => A X ! B Y) { RET }
			f004(A B => A X ! B Y)
			f004(B A => X A ! Y B)

			proc f101(!) @ 0x0005
			proc f102(!) @ f001 + 3
			f101(!)
			f102(!)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: inline", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(-* !) { db 0 1 2; RET }
			f001(-* !)

			f002(-* !)
			proc f002(-* !) {
				g(-*); RET
				proc g(-*) { db 0 1 2; RET }
			}
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 0, 1, 2}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				proc ModA:p001(!) {}
			`,
			"test is already defined", `
				proc test(!) {}; proc test(!) {}
			`,
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [B] ! [],\n" +
				"  given    [Y] => [A] ! [Y]", `flat!
				proc f001(X => B) { RET }
				f001(Y => A ! Y)
			`,
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [] ! [_],\n" +
				"  given    [X] => [] ! [Y]", `flat!
				proc f001(X => !) { RET }
				f001(X => ! Y)
			`,
			"unsupported operand(#2)", `flat!
				proc f001(!) { RET }
				CC?.f001(!)
			`,
			"LD is a builtin name", `
				proc LD(!) {}
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { A@1 }
			`,
			"the last instruction must be placed before inner procs", `flat!
				proc f001() {
					proc f002() { RET }
					RET
				}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { fallthrough }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
			"undefined proc f001", `flat!
				f001(-* !)
			`,
			"f001 is not a proc", `flat!
				data f001 = byte [0]
				f001(!)
			`,
			"f001 is not a inline proc", `flat!
				data f001 = byte [0]
				f001(-* !)
			`,
			"inline proc expansion too deep", `flat!
				proc f001(-*) { f001(-*); RET}
				f001(-*)
			`,
			"cannot use the invalid `__PROC__` within this context", `flat!
				proc f001(-* !) { JMP __PROC__ }
				f001(-* !)
			`,
			"cannot bind inline proc", `flat!
				proc f001(-* !) @ 0x0005
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileConstexpr(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			const c001 = 1
			make-counter enum001 0
			L1: db $$(1 + 2) $("ok") $$(c001) L1 __PC__ enum001 enum001
		`)
		tt.EqSlice(t, []byte{3, 'o', 'k', 1, 0, 5, 0, 1}, dat, mes, dat)
	})

	t.Run("ok: escape sequenses", func(t *testing.T) {
		dat, mes := compile(`flat!
			db '\0' '\a' '\b' '\e' '\f' '\n' '\r' '\t' '\v' '\\' '\'' '\"' '\x10'
			db "\0\a\b\e\f\n\r\t\v\\\'\"\x10"
		`)
		tt.EqSlice(t, []byte{
			0, '\a', '\b', 0x1b, '\f', '\n', '\r', '\t', '\v', '\\', '\'', '"', '\x10',
			0, '\a', '\b', 0x1b, '\f', '\n', '\r', '\t', '\v', '\\', '\'', '"', '\x10',
		}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"undefined name f", `flat!
				db $$(f)
			`,
			"unknown operator f", `flat!
				db $$(f())
			`,
			"L1 is not callable", `flat!
				L1: db $$(L1())
			`,
			"LD is not callable", `flat!
				db $$(LD())
			`,
			"cannot use label address in compile phase", `flat!
				L1: db $$(L1)
			`,
			"cannot use __PC__ in compile phase", `flat!
				db $$(__PC__)
			`,
			"cannot use __ORG__ in compile phase", `flat!
				db $$(__ORG__)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileConst(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			const c001 = 1
			module ModA {
				const c002 = 2
			}
			module ModB {
				const c003 = 3
			}
			data byte [ c001 ModA:c002 ModB:c003 ]
			const f001(a) = a + 1
			proc p001(!) {
				const c004 = 4
				data byte [ c001 ModA:c002 ModB:c003 c004 f001(1) ]
				RET
			}
		`)
		tt.EqSlice(t, []byte{1, 2, 3, 1, 2, 3, 4, 2}, dat[:len(dat)-1], mes, dat)
	})

	t.Run("ok: function", func(t *testing.T) {
		dat, mes := compile(`
			const c001 = 5
			const f001(a) = a + 1
			const f002(a b) = a * b + 1
			const f003(a b:3 c: c001) = a * b + c
			data byte [ f001(1) f002(2 3) f003(2) f003(2 4) f003(2 4 6)]
		`)
		tt.EqSlice(t, []byte{2, 7, 11, 13, 14}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				const ModA:c001 = 1
			`,
			"test is already defined", `
				const test = 1; const test = 1
			`,
			"undefined name c001", `flat!
				db $$(c001)
				const c001 = 1
			`,
			"f001 is not callable", `flat!
				const f001 = 1
				db f001()
			`,
			"constant c001 used before declaration", `flat!
				do {
					db c001
					const c001 = 1
				}
			`,
			"label f001 used before declaration", `flat!
				do {
					db f001
					proc f001() @ 0x0005
				}
			`,
			"LD is a builtin name", `flat!
				const LD = 1
			`,
			"constant value must be constexpr", `flat!
				macro mac(a) ={ const a = %=a }
				mac EQ?
			`,
			"qualified name is not allowed in this context", `flat!
				const f001(invalid:a) = a + 1
			`,
			"f001: 1 argument(s) required, but given 0", `flat!
				const f001(a) = a + 1
				db f001()
			`,
			"f001: 1 argument(s) required, but given 2", `flat!
				const f001(a) = a + 1
				db f001(1 2)
			`,
			"f001: 1..2 argument(s) required, but given 3", `flat!
				const f001(a b: 1) = a + b
				db f001(1 2 3)
			`,
			"default value required", `flat!
				const f001(a: 1 b) = a + 1
			`,
			"undefined name b", `flat!
				const f001(a: b) = a + 1
				db f001()
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileData(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 0 1; merge text _; merge rodata _; org 0 0 0; merge bss _ }
			section text
			data b000 = byte [] : rodata
			data w000 = word [] : rodata
			data b001 = byte [0x01]
			data b002 = byte [0x23 0x45]
			data b003 = byte ["test" $(1) $$(2 + 3)]
			data r001 = byte [0x10] : rodata
			data w001 = word [0x6789]
			data w002 = word [0xABCD 0xEF01]
			data w003 = word [0x1234 't', 'e', 's', 't']
			data b004 = byte [0 1 2 3 4 5 6 7 8] : rodata
			data b005 = byte [0 1 2 3] * 1 : rodata
			data b006 = byte [4 5 6 7] * 3 : rodata
			data w005 = word [0xa 0xb] * 1 : rodata
			data w006 = word [0xc 0xd] * 2 : rodata
			data p001 = word @ b001

			section bss
			data b100 = byte * 10
			data w100 = word * 10
		`)
		tt.EqSlice(t, []byte{
			0x01, 0x23, 0x45, 't', 'e', 's', 't', 1, 5,
			0x89, 0x67, 0xCD, 0xAB, 0x01, 0xEF,
			0x34, 0x12, 't', 0, 'e', 0, 's', 0, 't', 0,
			0x10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3,
			4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7,
			0xa, 0, 0xb, 0, 0xc, 0, 0xd, 0, 0xc, 0, 0xd, 0,
		}, dat, mes, dat)
	})

	t.Run("ok: struct", func(t *testing.T) {
		dat, mes := compile(`
			struct s { a byte; b word }
			data s {}
			data s {3}
			data s {3 2}
			data s {"a"}

			data s []
			data s [{}]
			data s [{3}]
			data s [{3 2}]
			data s [{3 2} {5}]
			data s [{3 2} {5 4}]

			struct t { c byte; d s }
			data t {}
			data t {8}
			data t {8 {}}
			data t {8 {3}}
			data t {8 {3 2}}

			data t []
			data t [{}]
			data t [{8}]
			data t [{8 {}}]
			data t [{8 {3}}]
			data t [{8 {3 2}}]
		`)
		tt.EqSlice(t, []byte{
			0, 0, 0,
			3, 0, 0,
			3, 2, 0,
			'a', 0, 0,

			0, 0, 0,
			3, 0, 0,
			3, 2, 0,
			3, 2, 0, 5, 0, 0,
			3, 2, 0, 5, 4, 0,

			0, 0, 0, 0,
			8, 0, 0, 0,
			8, 0, 0, 0,
			8, 3, 0, 0,
			8, 3, 2, 0,

			0, 0, 0, 0,
			8, 0, 0, 0,
			8, 0, 0, 0,
			8, 3, 0, 0,
			8, 3, 2, 0,
		}, dat, mes, dat)
	})

	t.Run("ok: sized", func(t *testing.T) {
		dat, mes := compile(`
			data [4]byte []
			data [4]byte [5]
			data [4]byte [5 4]
			data [4]byte [5 4 3]
			data [4]byte [5 4 3 2]

			data [4]word []
			data [4]word [5]
			data [4]word [5 4]
			data [4]word [5 4 3]
			data [4]word [5 4 3 2]

			struct s { a byte; b word }
			data [4]s []
			data [4]s [{}]
			data [4]s [{5}]
			data [4]s [{5 4}]
			data [4]s [{5 4} {3}]
			data [4]s [{5 4} {3 2}]

			data [4]byte ["a"]
			data [4]byte ["ab"]
			data [4]byte ["abc"]
			data [4]byte ["abcd"]

			data [4]byte ["a", 4, 3, 2]
			data [4]byte ["ab", 3, 2]
			data [4]byte ["abc", 2]
		`)
		tt.EqSlice(t, []byte{
			0, 0, 0, 0,
			5, 0, 0, 0,
			5, 4, 0, 0,
			5, 4, 3, 0,
			5, 4, 3, 2,

			0, 0, 0, 0, 0, 0, 0, 0,
			5, 0, 0, 0, 0, 0, 0, 0,
			5, 0, 4, 0, 0, 0, 0, 0,
			5, 0, 4, 0, 3, 0, 0, 0,
			5, 0, 4, 0, 3, 0, 2, 0,

			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0,

			'a', 0, 0, 0,
			'a', 'b', 0, 0,
			'a', 'b', 'c', 0,
			'a', 'b', 'c', 'd',

			'a', 4, 3, 2,
			'a', 'b', 3, 2,
			'a', 'b', 'c', 2,
		}, dat, mes, dat)
	})

	t.Run("ok: sized field", func(t *testing.T) {
		dat, mes := compile(`
			struct s { a [3]byte; b [2]word }
			data s []
			data s [{[5]}]
			data s [{[5 4]}]
			data s [{[5 4 3]}]
			data s [{[5 4 3] [2]}]
			data s [{[5 4 3] [2 1]}]
			data s [{[5] [2]}]
			data s [{[5 4] [2 1]}]

			data s [{["a"]}]
			data s [{["ab"] [2]}]
			data s [{["abc"] [2 1]}]

		`)
		tt.EqSlice(t, []byte{
			5, 0, 0, 0, 0, 0, 0,
			5, 4, 0, 0, 0, 0, 0,
			5, 4, 3, 0, 0, 0, 0,
			5, 4, 3, 2, 0, 0, 0,
			5, 4, 3, 2, 0, 1, 0,
			5, 0, 0, 2, 0, 0, 0,
			5, 4, 0, 2, 0, 1, 0,

			'a', 0, 0, 0, 0, 0, 0,
			'a', 'b', 0, 2, 0, 0, 0,
			'a', 'b', 'c', 2, 0, 1, 0,
		}, dat, mes, dat)
	})

	t.Run("ok: array", func(t *testing.T) {
		dat, mes := compile(`
			data [][4]byte []
			data [][4]byte [["a"]]
			data [][4]byte [["ab"]]
			data [][4]byte [["abc"]]
			data [][4]byte [["abcd"]]
			data [][4]byte [["a"] ["a"]]
			data [][4]byte [["ab"] ["ab"]]
			data [][4]byte [["abc"] ["abc"]]
			data [][4]byte [["abcd"] ["abcd"]]

			data [2][4]byte
			data [2][4]byte []
			data [2][4]byte [[]]
			data [2][4]byte [["a"]]
		`)
		tt.EqSlice(t, []byte{
			'a', 0, 0, 0,
			'a', 'b', 0, 0,
			'a', 'b', 'c', 0,
			'a', 'b', 'c', 'd',
			'a', 0, 0, 0, 'a', 0, 0, 0,
			'a', 'b', 0, 0, 'a', 'b', 0, 0,
			'a', 'b', 'c', 0, 'a', 'b', 'c', 0,
			'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd',

			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			'a', 0, 0, 0, 0, 0, 0, 0,
		}, dat, mes, dat)
	})
	t.Run("ok: ds", func(t *testing.T) {
		es := []struct {
			a int
			b string
		}{
			{1, "data byte"},
			{2, "data byte * 2"},
			{1, "data [1]byte"},
			{2, "data [1]byte * 2"},
			{1, "data [1][1]byte"},
			{2, "data [1][1]byte * 2"},
			{2, "data [2]byte"},
			{4, "data [2]byte * 2"},
			{4, "data [2][2]byte"},
			{8, "data [2][2]byte * 2"},

			{2, "data word"},
			{4, "data word * 2"},
			{2, "data [1]word"},
			{4, "data [1]word * 2"},
			{2, "data [1][1]word"},
			{4, "data [1][1]word * 2"},
			{4, "data [2]word"},
			{8, "data [2]word * 2"},
			{8, "data [2][2]word"},
			{16, "data [2][2]word * 2"},

			{2, "struct s { a [2]byte }; data s"},
			{4, "struct s { a [2]byte }; data s * 2"},
			{2, "struct s { a [2]byte }; data [1]s"},
			{4, "struct s { a [2]byte }; data [1]s * 2"},
			{4, "struct s { a [2]byte }; data [2]s"},
			{8, "struct s { a [2]byte }; data [2]s * 2"},

			{2, "data struct { a [2]byte }"},
			{4, "data struct { a [2]byte } * 2"},
			{2, "data [1]struct { a [2]byte }"},
			{4, "data [1]struct { a [2]byte } * 2"},
			{4, "data [2]struct { a [2]byte }"},
			{8, "data [2]struct { a [2]byte } * 2"},
		}
		for _, i := range es {
			dat, mes := compile(i.b)
			tt.Eq(t, i.a, len(dat), mes, i.a, i.b)
		}
	})

	t.Run("ok: generate list", func(t *testing.T) {
		list, mes := genlist(`
			struct s { a byte; b word}
			data d = [4]s [{} {5} {6 7}]
			data word [s.a s.b d.a d.b]
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			     - 0000                             d:
			000000 0000[3] ..                           .defb 3
			000003 0003[1] 05                           .byte 5
			000004 0004[2] ..                           .defb 2
			000006 0006[1] 06                           .byte 6
			000007 0007[2] 07 00                        .word 7
			000009 0009[3] ..                           .defb 3
			00000c 000c[8] 00 00 01 00 00 00 01 00      .word s.a, s.b, d.a, d.b
		`)[1:]+"\n", list, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid data type invalid:byte", `
				data b001 = invalid:byte
			`,
			"qualified name is not allowed in this context", `
				data b001 = byte : invalid:bss
			`,
			"invalid namespace ModA", `
				data ModA:b001 = byte
			`,
			"test is already defined", `
				data test = byte; data test = byte
			`,
			"LD is a builtin name", `
				data LD = byte
			`,
			"invalid data type qword", `flat!
				data qword
			`,
			"invalid data value", `flat!
				data b001 = byte [quote(test)]
			`,
			"invalid blob type", `flat!
				data b001 = word load-file("./testdata/embed01.dat")
			`,
			"invalid blob type", `flat!
				data b001 = [4]byte load-file("./testdata/embed01.dat")
			`,
			"repeat operator must be `*`", `flat!
				data byte / 2
			`,
			"invalid repeat count 0", `flat!
				data byte * 0
			`,
			"too many elements", `flat!
				data [2]byte [0, 1, 2]
			`,
			"the addressed data must be named", `flat!
				data byte @ 0x0005
			`,
			"the addressed data cannot contain any elements", `flat!
				data b001 = byte [1] @ 0x0005
			`,
			"strings are only allowed as byte data", `flat!
				data b001 = word ["string"]
			`,
			"the string too long", `flat!
				data b001 = [4]byte ["string"]
			`,
			"invalid data length", `flat!
				data [-1]byte [1]
			`,
			"invalid data length", `flat!
				data [0]byte [1]
			`,
			"invalid data length", `flat!
				data [-1][2]byte [1]
			`,
			"invalid data length", `flat!
				data [0][2]byte [1]
			`,
			"struct data required", `flat!
				data struct { a byte } [1]
			`,
			"data list required", `flat!
				data struct { a [2]byte } {1}
			`,
			"the string too long", `flat!
				data struct { a byte } {"ab"}
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileStruct(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			link-as-tests
			struct s0 {
				z byte
			}
			struct s1 {
				a byte
				b word
				c struct { x word; y byte }
				d s0
			}
			struct s2 {
				s [4]s1
				t [4]s0
			}
			data v0 = s0 @ 1000
			data v1 = s1 @ 1000
			data v2 = s2 @ 2000

			expect 0  s0.z
			expect 0  s1.a
			expect 1  s1.b
			expect 3  s1.c
			expect 3  s1.c.x
			expect 5  s1.c.y
			expect 6  s1.d
			expect 6  s1.d.z
			expect 0  s2.s
			expect 0  s2.s.a
			expect 1  s2.s.b
			expect 3  s2.s.c
			expect 3  s2.s.c.x
			expect 5  s2.s.c.y
			expect 6  s2.s.d
			expect 6  s2.s.d.z
			expect 28 s2.t
			expect 28 s2.t.z

			expect 1000 v0
			expect 1000 v0.z
			expect 1000 v1
			expect 1000 v1.a
			expect 1001 v1.b
			expect 1003 v1.c
			expect 1003 v1.c.x
			expect 1005 v1.c.y
			expect 1006 v1.d
			expect 1006 v1.d.z

			expect 2000 v2
			expect 2000 v2.s
			expect 2000 v2.s.a
			expect 2001 v2.s.b
			expect 2003 v2.s.c
			expect 2003 v2.s.c.x
			expect 2005 v2.s.c.y
			expect 2006 v2.s.d
			expect 2006 v2.s.d.z
			expect 2028 v2.t
			expect 2028 v2.t.z
		`)
		tt.Eq(t, "ok", string(dat), mes)
	})

	t.Run("ok: size 1", func(t *testing.T) {
		dat, mes := compile(`flat!
			struct s { a [1]byte }
			struct t { b [1]s }
			struct u { a [1][1]byte }
			data s {}
			data t {}
			data u {}
		`)
		tt.Eq(t, 3, len(dat), dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"named inner struct is not allowed", `flat!
				struct s { a struct t {} }
			`,
			"the field a is already defined", `flat!
				struct s { a byte; a byte }
			`,
			"data length required", `flat!
				struct s { a []byte }
			`,
			"invalid data length", `flat!
				struct s { a [0]byte }
			`,
			"invalid data length", `flat!
				struct s { a [1][0]byte }
			`,
			"invalid data length", `flat!
				struct s { a [0][1]byte }
			`,
			"invalid data length", `flat!
				struct s { a byte }
				struct t { b [0]s }
			`,
			"only builtin types can be used as array element types", `flat!
				struct s { a byte }
				struct t { b [2][4]s }
			`,
			"element type must be constexpr", `flat!
				struct s { a [2][4][8]byte }
			`,
			"f is not a struct type", `flat!
				proc f() { RET }
				struct s { a byte }
				db f.a
			`,
			"s is not a struct type", `flat!
				struct s {}
				db s.a
			`,
			"unknown field b", `flat!
				struct s { a byte }
				db s.b
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileInclude(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			include "inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		g.AppendIncPath("./testdata/include")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: relative path", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: twice", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc01.oc"
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: self", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc04.oc"
		`)
		tt.EqSlice(t, []byte{0x01}, dat, mes)
	})

	t.Run("ok: in module", func(t *testing.T) {
		dat, mes := compile(`
			module ModA { include "./testdata/include/inc01.oc" }
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: flat!", func(t *testing.T) {
		dat, mes := compile(`flat!
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: keep original section", func(t *testing.T) {
		dat, mes := compile(`
			section text
			include "./testdata/include/inc02.oc"
			data b001 = byte [0xFA 0xFB]
		`)
		tt.EqSlice(t, []byte{0xFA, 0xFB, 0xFC}, dat, dat, mes)
	})

	t.Run("ok: loaded as main", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.CompileAndGenerate("./testdata/include/inc03.oc")
		tt.EqSlice(t, []byte{0x01}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: not loaded as main", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			include "inc03.oc"
		`)
		g.AppendIncPath("./testdata/include")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0x00}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid path `/nothing.oc`", `
				include "/nothing.oc"
			`,
			"the file `nothing.oc` not found", `
				include "nothing.oc"
			`,
			"the file `./testdata/nothing.oc` not found", `
				include "./testdata/nothing.oc"
			`,
			"include must be in toplevel", `
				proc fn() { include "./testdata/include/inc01.oc"; RET }
			`,
			"undefined name ModA:Tc", `
				module ModA { include "./testdata/include/inc01.oc" }
				data b001 = byte [ModA:Tc]
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileLoadFile(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			data byte load-file("./testdata/embed01.dat")
		`)
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat, mes)
	})

	t.Run("ok: []byte", func(t *testing.T) {
		dat, mes := compile(`
			data []byte load-file("./testdata/embed01.dat")
		`)
		tt.Eq(t, 16, len(dat), dat, mes)
	})

	t.Run("ok: from include path", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			data byte load-file("embed01.dat")
		`)
		g.AppendIncPath("./testdata")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat, mes)
	})

	t.Run("ok: const", func(t *testing.T) {
		dat, mes := compile(`
			const blob = $$(load-file("./testdata/embed01.dat"))
			data byte blob
		`)
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat, mes)
	})

	t.Run("ok: generate list", func(t *testing.T) {
		list, mes := genlist(`
			data byte load-file("./testdata/embed01.dat")
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			000000 0000[16] ..                          .incbin "./testdata/embed01.dat"
		`)[1:]+"\n", list, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the file `./testdata/nothing.dat` not found", `flat!
				data byte compile-file("./testdata/nothing.dat")
			`,
			"cannot use compile-file in link phase", `flat!
				const blob = compile-file("./testdata/test.dat")
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileCompileFile(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			data byte compile-file("./testdata/test.oc")
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: from include path", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			data byte compile-file("test.oc")
		`)
		g.AppendIncPath("./testdata")
		dat, _, mes := ttarch.DoCompile(g, "-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: const", func(t *testing.T) {
		dat, mes := compile(`
			const blob = $$(compile-file("./testdata/test.oc"))
			data byte blob
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: include", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc05.oc"
			data byte blob
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: generate list", func(t *testing.T) {
		list, mes := genlist(`
			data byte compile-file("./testdata/test.oc")
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			000000 0000[4] ..                           .incbin "(compiled):./testdata/test.oc"

			                                            ; ----------------

			     - 0000                                 .org 0
			     - 0000[4] 00 01 02 03                  .byte 0, 1, 2, 3
		`)[1:]+"\n", list, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the file `./testdata/nothing.oc` not found", `flat!
				data byte compile-file("./testdata/nothing.oc")
			`,
			"cannot use compile-file in link phase", `flat!
				const blob = compile-file("./testdata/test.oc")
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileAlign(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			data b001 = byte [0xFA]
			align 8
			data b002 = byte [0xFB]
		`)
		tt.EqSlice(t, []byte{0xFA, 0, 0, 0, 0, 0, 0, 0, 0xFB}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"argument must be constexpr", `flat!
				align A
			`,
			"the alignment size must be power of 2", `flat!
				align 0
			`,
			"the alignment size must be power of 2", `flat!
				align 5
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileSection(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0 20 1
				merge text _
				merge rodata _
			}
			module Mod {
				db 0x00 0x01 0x02 0x03
				section rodata ={ db 0xf0 0xf1 0xf2 0xf3 }
				db 0x04 0x05 0x06 0x07
				section rodata ={ db 0xf4 0xf5 0xf6 0xf7 }
				db 0x08 0x09 0x0a 0x0b
			}
		`)
		tt.EqSlice(t, []byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
		}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"body must be block-form", `
				section text 1
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileModule(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0 8 2
				merge text _
				merge rodata _

				org 8 8 0
				merge bss _

				org 0 0 1
				merge dat _
			}
			module Mod {
				section text;   db 0xF0 0xF1 0xF2
				section rodata; db 0xF3 0xF4
				section bss;    data byte * 4
				section dat;    db 0xF5 0xF6 0xF7
			}
		`)
		tt.EqSlice(t, []byte{0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0, 0, 0,
			0xF5, 0xF6, 0xF7}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				module ModA:ModA {}
			`,
			"test is already defined", `
				module test {}; module test {}
			`,
			"#.module must be in toplevel", `
				module ModA { module ModB {} }
			`,
			"LD is a builtin name", `
				module LD {}
			`,
			"link must be in toplevel", `
				module ModA { link {} }
			`,
			"link is already registered", `
				link {}; link {}
			`,
			"the section `invalid@ModA` is not linked", `
				module ModA { section invalid; db 1 }
			`,
			"unknown module unknown", `
				link { org 0 0 0; merge text unknown _ }
			`,
			"unknown module c001", `
				const c001 = 1
				link { org 0 0 0; merge text c001 _ }
			`,
			"invalid link form", `
				link { org 0 0 0; unknown }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileMacro(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac() { db 0 }
			mac
		`)
		tt.EqSlice(t, []byte{0}, dat, mes)
	})

	t.Run("ok: req=1", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a) { db %=a }
			mac 1
		`)
		tt.EqSlice(t, []byte{1}, dat, mes)
	})

	t.Run("ok: req=2", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b) { db %=a %=b }
			mac 1 2
		`)
		tt.EqSlice(t, []byte{1, 2}, dat, mes)
	})

	t.Run("ok: opt=1", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a: 10) { db %=a }
			mac 1
			mac
		`)
		tt.EqSlice(t, []byte{1, 10}, dat, mes)
	})

	t.Run("ok: req=1 opt=1", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b: 5) { db %=a %=b }
			mac 1 2
			mac 3
		`)
		tt.EqSlice(t, []byte{1, 2, 3, 5}, dat, mes)
	})

	t.Run("ok: rest", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a ...) { db %#a (2 + %#a) %*a }
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{3, 5, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: req=1 rest", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b ...) { db %=a %*b }
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{1, 2, 3}, dat, mes)
	})

	t.Run("ok: req=1 opt=1 rest", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b: 10 c ...) { db %=a %=b %*c }
			mac 1
			mac 1 2
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{1, 10, 1, 2, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: macro variable", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac() [l] ={ %=l: JMP %=l }
			mac
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: macro variable make-id", func(t *testing.T) {
		dat, mes := compile(`flat!
			const N = "N"
			macro mac(a b c) [id = %{"X" a b c N "Z"}] { db nameof(%=id) }
			mac ABC Y "STR"
		`)
		tt.EqSlice(t, []byte("XABCYSTRNZ"), dat, mes)
	})

	t.Run("ok: placeholder operation", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro m001(a ...) { db %>*a }
			macro m002(a ...) { db %>>*a }
			macro m003(a ...) { db %>>>*a }
			macro m004(a ...) { db %><a }
			macro m005(a ...) { db %>><a }
			macro m006(a ...) { db %>>><a }
			m001 _ 0 1 2
			m002 _ 0 1 2
			m003 _ 0 1 2
			m004 _ 0 1 2
			m005 _ 0 1 2
			m006 _ 0 1 2
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 1, 2, 2, 0, 1, 2}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				macro ModA:m001() {}
			`,
			"test is already defined", `
				macro test() {}; macro test() {}
			`,
			"invalid expansion", `flat!
				macro m001(a ...) { db %<a }
				m001
			`,
			"invalid expansion", `flat!
				macro m001(a ...) { db %>a }
				m001
			`,
			"macro expansion too deep", `flat!
				macro m001() { m001 }
				m001
			`,
			"rest parameter name required", `flat!
				macro mac(...) {}
			`,
			"qualified name is not allowed in this context", `flat!
				macro mac(invalid:a) {}
			`,
			"the rest parameter cannot have default value", `flat!
				macro mac(a: _ ...) {}
			`,
			"default value required", `flat!
				macro mac(a: _ b) {}
			`,
			"parameter a is already defined", `flat!
				macro mac(a a) {}
			`,
			"unknown placeholder %=a in macro body", `flat!
				macro mac() { %=a }
				mac
			`,
			"vector operations only allowed on the rest parameter", `flat!
				macro mac(a) { %*a }
				mac 1
			`,
			"the expression itself required. use the %& placeholder", `flat!
				macro mac(a) { db $$(use?(%=a)) }
				mac (1 + 2)
			`,
			"the placeholder only accepts constant expressions", `flat!
				macro mac(a) { db $$(use?(%=a)) }
				mac A
			`,
			"the non-constant value cannot be expanded in the constant expression", `flat!
				macro mac(a ...) { db $$(use?(%>a)) }
				mac A A A
			`,
			"the %& placeholder is only allowed within constant expressions", `flat!
				macro mac(a) { db %&a }
				mac (1 + 2)
			`,
			"cannot use the macro `mac` within this context", `flat!
				macro mac() {}
				db $$(mac)
			`,
			"mac is not callable", `flat!
				macro mac() {}
				db $$(mac())
			`,
			"qualified name is not allowed in this context", `flat!
				macro mac(a) [invalid:b] {}
				mac (1 + 2)
			`,
			"variable a is already defined", `flat!
				macro mac(a) [a] {}
			`,
			"variable a is already defined", `flat!
				macro mac() [a a] {}
			`,
			"invalid fragment", `flat!
				macro mac(a) [b = %{a}] {}
				mac (1 + 2)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})

}

func TestCompileWith(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		s, _ := compile(`flat!
			LD A 1
			LD A 1
			LD A B
		`)
		dat, mes := compile(`flat!
			@1
			A <- 1
			A <- B
		`)
		tt.True(t, len(s) > 0 && slices.Equal(s, dat), mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"cannot use [X] as first operand for '<-'", `flat!
				[X] <- A
			`,
			"unknown operator: *", `flat!
				A * X
			`,
			"cannot use A as second operand for '-rep'", `flat!
				$(1) -rep A
			`,
			"cannot use X as operand#2 for LD", `flat!
				A <- X
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestExpandBcCode(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			BIT 0 A
			BIT 1 A
			BIT 2 A
			BIT 3 A
			BIT 4 A
			BIT 5 A
			BIT 6 A
			BIT 7 A
			BMM 1
			BMM 2
			BMM 3
			L0: ds (0x80 - 2); JR L0
			JR L1; ds 0x7f; L1:
			L2: ds (0x8000 - 3); JPR L2
			JPR L3; ds 0x7fff; L3:

		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error: invalid BcImp range", func(t *testing.T) {
		lines := []string{
			`flat!; BIT -2 A`,
			`flat!; BIT -1 A`,
			`flat!; BIT 8 A`,
			`flat!; BIT 9 A`,
		}
		for _, i := range lines {
			_, mes := compile(i)
			tt.Eq(t, "compile error: the operand only accepts 0..7", mes)
		}
	})

	t.Run("error: invalid BcMap range", func(t *testing.T) {
		lines := []string{
			`flat!; BMM -1`,
			`flat!; BMM 0`,
			`flat!; BMM 4`,
			`flat!; BMM 5`,
		}
		for _, i := range lines {
			_, mes := compile(i)
			tt.Eq(t, "compile error: the operand only accepts 1..3", mes)
		}
	})

	t.Run("error: relative address out of range", func(t *testing.T) {
		lines := []string{
			`flat!; L0: ds (0x80 - 2 + 1); JR L0`,
			`flat!; JR L1; ds (0x7f + 1); L1:`,
			`flat!; L2: ds (0x8000 - 3 + 1); JPR L2`,
			`flat!; JPR L3; ds (0x7fff + 1); L3:`,
		}
		for _, i := range lines {
			_, mes := compile(i)
			tt.Eq(t, "compile error: the relative address is out of range", mes)
		}
	})
}

func TestSemanticCheck(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid operands for LD. some operand values may be out of range", `flat!
				LD A, 0xFFFF
			`,
			"cannot use X as operand#2 for LD", `flat!
				LD A, X
			`,
			"too few operands for LD", `flat!
				LD A
			`,
			"cannot determine the size of the instruction(3 or 2)", `
				link { org 255 0 1; merge text _ }
				flat!
				L0: DNN (258 - (L1 - L0))
				L1:
			`,
			"invalid form b001(label)", `flat!
				data b001 = byte []
				b001 1
			`,
			"unknown form name unknown?", `flat!
				unknown? 1
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestExprCheck(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid form", `flat!
				macro mac(a ...) { %>*a }
				mac 1 2 3
			`,
			"invalid form", `flat!
				macro mac(a ...) { %*a }
				mac
			`,
			"flat! is not allowed in this context", `
				proc p001(!) { flat! }
			`,
			"section: 1..2 argument(s) required, but given 0", `
				section
			`,
			"section: 1..2 argument(s) required, but given 3", `
				section 1 2 3
			`,
			"apply: 1+ argument(s) required, but given 0", `
				apply
			`,
			"pragma must be identifier", `
				pragma 1
			`,
			"qualified name is not allowed in this context", `
				pragma ns:invalid
			`,
			"unknown pragma: unknown", `
				pragma unknown
			`,
			"pragma: 2..3 argument(s) required, but given 4", `
				pragma list-constants 1 2 3
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestScanError(t *testing.T) {
	es := []string{
		"blank character literal is invalid", `
			db ''
		`,
		"invalid character escape", `
			db '\z'
		`,
		"invalid character escape", `
			db '\xZZ'
		`,
		"invalid character literal", `
			db 'ab'
		`,
		"invalid placeholder", `
			db %=[]
		`,
		"placeholders cannot contain namespaces", `
			db %=ns:id
		`,
		"reserved words cannot be use as placeholders", `
			db %=_END
		`,
		"leading whitespaces are required before the operator `.`", `
			A. {}
		`,
		"placeholders cannot contain namespaces", `
			%=ModA:a
		`,
		"no whitespace is allowed after the prefix operator", `
			~ 1
		`,
	}
	for x := 0; x < len(es); x += 2 {
		_, mes := compile(es[x+1])
		tt.Eq(t, "scan error: "+es[x], mes, es[x+1])
	}
}

func TestParseError(t *testing.T) {
	es := []string{
		`100`,
		`a; 100`,
		`$(1) + (1;`,
		`data byte !`,
		`data byte [A]`,
		`data byte [f001(!)]`,
		`data byte [EQ?]`,
		`data byte [1 !`,
		`data byte [f(!`,
		`const a =;`,
		`const a $`,
		`$(A)`,
		`$$(A)`,
		`[{}]`,
		`[1 !`,
		`A @1`,
		`A@@`,
		`mac { s;`,
		`mac ={ s;`,
		`mac (1 ! 1)`,
		`1`,
		`mac @`,
		`func.A(`,
		`func.A(!)`,
		`func(!!)`,
		`A . { db 1 !`,
		`= 1`,
		`A <- [1;`,
		`db (1 == $$(1))`,
		`macro m;`,
		`macro m(a !`,
		`macro m(a ... !`,
		`macro m(a) !`,
		`macro m(a) [i !`,
		`proc f(!`,
		`proc f(A !)`,
		`proc f(A) !`,
		`module A`,
	}
	for _, i := range es {
		_, mes := compile(i)
		tt.Prefix(t, "parse error: ", mes, i)
	}
}
