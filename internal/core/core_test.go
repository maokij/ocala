package core_test

import (
	"ocala/internal/core"
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"os"
	"slices"
	"testing"
)

func compile(src string) ([]byte, string) {
	return ttarch.Compile(ttarch.BuildCompiler(), src)
}

func genlist(src string) (string, string) {
	return ttarch.GenList(ttarch.BuildCompiler(), src)
}

func TestCompileAndGenerate(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: arch", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			arch ttarch
			db 0 1 2 3
		`)
		g.Archs = map[string]func() *core.Compiler{
			"ttarch": ttarch.BuildCompiler,
		}
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: auto generate output path and list path", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.OutPath = ""
		g.GenList = true
		g.ListPath = ""
		g.CompileAndGenerate("testdata/test.oc")
		b, _ := os.ReadFile("testdata/test.bin")
		s, _ := os.ReadFile("testdata/test.lst")
		tt.EqSlice(t, []byte{0, 1, 2, 3}, b, g.ErrorMessage())
		tt.Eq(t, tt.Unindent(`
				|                                            ; generated by ocala

				     - 0000                                 .org 0
				000000 0000[4] 00 01 02 03                  .byte 0, 1, 2, 3
		`)[1:]+"\n", string(s))
	})

	t.Run("ok: defs", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), `
			db USERDEF
		`)
		g.Defs = []string{"USERDEF"}
		g.CompileAndGenerate("-")
		tt.EqSlice(t, []byte{1}, tt.Flush(g.OutWriter))
	})

	t.Run("error: arch required", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: the first statement must be an `arch` directive "+
			"unless the `-t` option is specified", g.ErrorMessage())
	})

	t.Run("error: invalid arch form", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			arch
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: the first statement must be an `arch` directive "+
			"unless the `-t` option is specified", g.ErrorMessage())
	})

	t.Run("error: unknown arch", func(t *testing.T) {
		g := ttarch.BuildGenerator(nil, `
			arch unknown
			db 0 1 2 3
		`)
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: unknown arch: unknown", g.ErrorMessage())
	})

	t.Run("error: with error line", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			// comment
			data byte [this-error]
		`))
		g.CompileAndGenerate("-")
		tt.Eq(t, tt.Unindent(`
			compile error: undefined name this-error
			-:2:11
			 |data byte [this-error]
			 |           ^-- ??
		`)+"\n", string(g.ErrorMessageWithErrorLine()))
	})

	t.Run("error: debug mode", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			compile-error "!"
		`))
		g.DebugMode = true
		g.CompileAndGenerate("-")
		tt.Prefix(t, "compile error: !\n-- ", g.ErrorMessage())
	})

	t.Run("error: open failed", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.CompileAndGenerate("./testdata/nothing.oc")
		tt.Prefix(t, "generate error: open ", g.ErrorMessage())
	})

	t.Run("error: write", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.OutPath = "./testdata"
		g.CompileAndGenerate("-")
		tt.Prefix(t, "generate error: open ", g.ErrorMessage())
	})

	t.Run("error: output file name required", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.OutPath = ""
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: output file name required", g.ErrorMessage())
	})

	t.Run("error: list file name required", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.GenList = true
		g.ListPath = ""
		g.CompileAndGenerate("-")
		tt.Eq(t, "generate error: list file name required", g.ErrorMessage())
	})

	t.Run("error: invalid defs", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), tt.Unindent(`
			db 0 1 2 3
		`))
		g.Defs = []string{"loop"}
		g.CompileAndGenerate("-")
		tt.Eq(t, "compile error: loop is a builtin name", g.ErrorMessage())
	})
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list, mes := genlist(`
			link { org 0 0 1; merge text _; org 0xc000 0 0; merge bss _ }
			section text
			const c001 = 1

			module ModA {
				const c002 = 2
				proc f002(!) { RET }
			}

			pragma list-constants 0 "omit c003, c004"
			const c003 = 3
			module ModB {
				const c004 = 4
				proc f004(!) { RET }
			}
			pragma list-constants 1
			const c005 = 5
			pragma comment "comment"
			pragma comment "comment" 1 c003 "test" __ORG__

			proc f001(!) {
				const c006 = -(6)
				A <- c001
				A <- ModA:c002
				A <- c003
				A <- ModB:c004
				A <- c005
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				f001(!)
				ModA:f002(!)
				ModB:f004(!)
				RET
			}

			align 8
			data byte [0 1 2 3 4 5 6 7]
			data byte [1 2 "string" 0xABCD]
			data word [0 1 2 3]
			data word [1 2 ['s' 't' 'r' 'i' 'n' 'g'] 0xABCD]
			data byte [0 1 2 3] * 4

			align 8
			data byte ["long long string byte\n"]

			L0: embed-file "./testdata/embed01.dat"

			section bss
			data byte * 16
			data word * 16
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            c001 = 1
			                                            ModA:c002 = 2
			                                            ; omit c003, c004
			                                            c005 = 5

			     - 0000                                 .org 0
			                                            ; comment
			                                            ; comment 1 3 "test" 0

			     - 0000                             f001:
			~                                            \.c006\.#\d+ = -\(6\)
			000000 0000[2] 23 01                        LD     A, 0+ c001
			000002 0002[2] 23 02                        LD     A, 0+ ModA:c002
			000004 0004[2] 23 03                        LD     A, 0+ c003
			000006 0006[2] 23 04                        LD     A, 0+ ModB:c004
			000008 0008[2] 23 05                        LD     A, 0+ c005
			00000a 000a[2] 23 04                        LD     A, 0+ (3 + 2) - 1
			00000c 000c[2] 23 01                        LD     A, 0+ lobyte(1)
			00000e 000e[2] 23 05                        LD     A, 0+ ((3 + 2) - 1) + lobyte(1)
			000010 0010[3] 03 00 00                     JSR    0+ f001
			000013 0013[3] 03 86 00                     JSR    0+ ModA:f002
			000016 0016[3] 03 87 00                     JSR    0+ ModB:f004
			000019 0019[1] 04                           RET

			00001a 001a[6] ..                           .align 8 ; (.defb 6)
			000020 0020[8] 00 01 02 03 04 05 06 07      .byte 0, 1, 2, 3, 4, 5, 6, 7
			000028 0028[2] 01 02                        .byte 1, 2
			00002a 002a[6] 73 74 72 69 6e 67            .byte "string"
			000030 0030[1] cd                           .byte 43981
			000031 0031[8] 00 00 01 00 02 00 03 00      .word 0, 1, 2, 3
			000039 0039[8] 01 00 02 00 73 00 74 00      .word 1, 2, 115, 116
			000041 0041[8] 72 00 69 00 6e 00 67 00      .word 114, 105, 110, 103
			000049 0049[2] cd ab                        .word 43981
			00004b 004b[4] 00 01 02 03                  .byte 0, 1, 2, 3
			00004f 004f[4] 00 01 02 03                  ; ... repeat 2/4
			000053 0053[4] 00 01 02 03                  ; ... repeat 3/4
			000057 0057[4] 00 01 02 03                  ; ... repeat 4/4
			00005b 005b[5] ..                           .align 8 ; (.defb 5)
			000060 0060[8] 6c 6f 6e 67 20 6c 6f 6e      .byte "long long string byte\n"
			          :[8] 67 20 73 74 72 69 6e 67
			          :[6] 20 62 79 74 65 0a
			     - 0076                             L0:
			000076 0076[16] ..                          .incbin "./testdata/embed01.dat"

			     - 0086                             ModA:f002:
			000086 0086[1] 04                           RET

			     - 0087                             ModB:f004:
			000087 0087[1] 04                           RET

			     - c000                                 .org 49152
			     - c000[16] ..                          .defb 16
			     - c010[32] ..                          .defw 16
		`)[1:]+"\n", list, mes)
	})

	t.Run("ok: pack-mode", func(t *testing.T) {
		list, mes := genlist(`
			link { org 0 0x4000 2; merge text ModA; org 0x4000 0 4; merge text ModB }
			module ModA { data byte [0x00 0x01] }
			module ModB { data byte [0x02 0x03] }
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0
			000000 0000[2] 00 01                        .byte 0, 1

			     - 4000                                 .org 16384
			000002 4000[2] 02 03                        .byte 2, 3
		`)[1:]+"\n", list, mes)
	})
}

func TestCompileCommentAndBlank(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			// comment
			/*
			 * comment
			 */

			db 1 /* comment */ 2

			db 1,
				2


			db 1 /* comment
			*/
			db (1 + /* comment
					 */ 2)
			db (1 /* comment
				   */ + /* comment
						 */ 2)
		`)
		tt.EqSlice(t, []byte{1, 2, 1, 2, 1, 3, 3}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the block comment is not terminated", `
				/* ...
			`,
			"the comma followed by blank lines is not allowed", `
				db 1,

				   2
			`,
			"the block comment must be followed by new line", `
				db 1 /* comment
				      */ 2
			`,
			"invalid comma", `
				db 1,,
			`,
			"invalid comma", `
				db 1 /*
				     */, 2
			`,
			"invalid comma", `
				db $(1 + 1
					 , + 2
			`,
			"invalid comma", `
				db $(1 + 1,, + 2
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "scan error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileArch(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			arch ttarch; data byte * 8
		`)
		tt.Eq(t, 8, len(dat), mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"current target arch is ttarch", `flat!
				arch mos6502
			`,
			"arch must be in toplevel", `flat!
				proc f(!) { arch ttarch }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileOrg(t *testing.T) {
	t.Run("ok: simple mode", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 256 1; merge text { data byte * 64 } }
		`)
		tt.Eq(t, 64, len(dat), dat, mes)
	})

	t.Run("ok: padding mode", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 256 2; merge text { data byte * 64 } }
		`)
		tt.Eq(t, 256, len(dat), dat, mes)
	})

	t.Run("ok: pack mode", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0 256 2; merge text { data byte * 64 }
				org 0 256 4; merge text { data byte * 64 }
			}
		`)
		tt.Eq(t, 256, len(dat), dat, mes)
	})

	t.Run("ok: skip mode", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 256 0; merge text { data byte * 256 } }
		`)
		tt.Eq(t, 0, len(dat), dat, mes)
	})

	t.Run("ok: __ORG__", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0x4000 256 1; merge text { dw __ORG__ }
				org 0x8000 256 1; merge text { dw __ORG__ }
			}
		`)
		tt.EqSlice(t, []byte{0x00, 0x40, 0x00, 0x80}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid org mode", `
				link { org 0 256 5 }
			`,
			"a pack mode must follow a fill/pack mode", `
				link { org 0 256 0; org 0 256 3 }
			`,
			"the orgin address required", `
				link { org 0 256 2; org -1 0 1 }
			`,
			"size limit exceeded(257/256)", `
				link { org 0 256 0; merge text { data byte * 257 } }
			`,
			"size limit exceeded(512/256)", `
				link {
					org 0 256 2; merge text { data byte * 256 }
					org 0 256 4; merge text { data byte * 256 }
				}
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileNamed(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"undefined name test", `flat!
				db test
			`,
			"undefined name test", `flat!
				module ModA { const test = 1 }
				db test
			`,
			"undefined name ModA:test", `flat!
				db ModA:test
			`,
			"undefined name ModA:test", `flat!
				module ModA { }
				db ModA:test
			`,
			"undefined name ModA:test", `flat!
				const test = 1
				module ModA { }
				db ModA:test
			`,
			"LD is not a namespace", `flat!
				db LD:test
			`,
			"L1 is not a namespace", `flat!
				L1: db L1:test
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileAlias(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro m001() { db 0 1 }
			alias am001 m001; am001
			proc i001(-*) { db 2 3; RET }
			alias ai001 i001; ai001(-*)
			proc l001(A => !) { RET }
			alias al001 l001; al001(A => !)
			l002:
			alias al002 l002; db al002
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3, 4, 3, 4, 0, 8}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown name unknown", `flat!
				alias a001 unknown
			`,
			"m001 is already defined", `flat!
				macro m001() { }
				alias m001 m001
			`,
			"aliases are not allowed for this type(module)", `flat!
				module m001 {}
				alias a001 m001
			`,
			"aliases are not allowed for this type(syntax)", `flat!
				alias a001 do
			`,
			"aliases are not allowed for this type(func)", `flat!
				alias a001 hibyte
			`,
			"aliases are not allowed for this type(inst)", `flat!
				alias a001 ADD
			`,
			"aliases are not allowed for this type(const)", `flat!
				const c001 = 1
				alias a001 c001
			`,
			"aliases are not allowed for this type(special)", `flat!
				alias a001 __PC__
			`,
			"aliases are not allowed for this type(invalid)", `flat!
				proc i001(-*) { alias a001 __PROC__ }
				i001(-*)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileProc(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RET }
			proc f003(!) { JMP __PROC__ }
			f001(!)
			f002(!)
			f003(!)

			proc f004(A B => A X ! B Y) { RET }
			f004(A B => A X ! B Y)
			f004(B A => X A ! Y B)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: inline", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(-* !) { db 0 1 2; RET }
			f001(-* !)
		`)
		tt.EqSlice(t, []byte{0, 1, 2}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				proc ModA:p001(!) {}
			`,
			"test is already defined", `
				proc test(!) {}; proc test(!) {}
			`,
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [B] ! [],\n" +
				"  given    [Y] => [A] ! [Y]", `flat!
				proc f001(X => B) { RET }
				f001(Y => A ! Y)
			`,
			"proc signature mismatch: f001.\n" +
				"  expected [X] => [] ! [_],\n" +
				"  given    [X] => [] ! [Y]", `flat!
				proc f001(X => !) { RET }
				f001(X => ! Y)
			`,
			"conditional call is not supported", `flat!
				proc f001(!) { RET }
				CC?.f001(!)
			`,
			"LD is a builtin name", `
				proc LD(!) {}
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { A@1 }
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { fallthrough }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
			"undefined proc f001", `flat!
				f001(-* !)
			`,
			"f001 is not a proc", `flat!
				data f001 = byte [0]
				f001(!)
			`,
			"f001 is not a inline proc", `flat!
				data f001 = byte [0]
				f001(-* !)
			`,
			"cannot use the invalid `__PROC__` within this context", `flat!
				proc f001(-* !) { JMP __PROC__ }
				f001(-* !)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func sbyte(n int) byte {
	return byte(n)
}

func TestCompileFunctions(t *testing.T) {
	t.Run("ok: operators", func(t *testing.T) {
		dat, mes := compile(`flat!
			db (2 * 3) (3 * -5) (-5 * -5)
			db (10 / 3) (12 / -4)  (-20 / -6)
			db (10 % 3) (12 % -4)  (-20 % -6)
			db (1 + 2) (10 + -5) (-1 + -2)
			db (10 - 2) (10 - -5) (-3 - -5)  -(32)

			db (1 << 3) (0x11 << 5) (0xd0 << 65)
			db (-0xcd >> 3 == -0x1a) (0xaa >> 10 == 0) (0xd0 >> 65 == 0)
			db (-0xcd >>> 60 == 0x0f) (0xaa >>> 10 == 0) (0xd0 >>> 65 == 0)

			db (1 > 0) (1 > 1) (2 > 1)
			db (1 >= 0) (0 >= 1) (2 >= 2)
			db (1 < 0) (1 < 1) (1 < 2)
			db (1 <= 0) (1 <= 1) (2 <= 1)
			db (1 == 1) (1 == 2) ("a" == "a") ("a" == "b")
			db (1 != 1) (1 != 2) ("a" != "a") ("a" != "b")
			db !0 !1 !-1 ~0 ~1 ~-1

			db (1 && 2) (0 && 2)
			db (1 || 2) (0 || 2)
			db (3 & 2)
			db (3 | 4)
			db (0xab ^ 0xcd)
			db ~(0x10) ~(0) ~(-0x60)
			db lobyte(0xabcd) hibyte(0xabcd)
			dw asword(0xab 0xcd)
			$(0xFF) -byte; $(0xFE) -byte; $(0x01) -rep 6
		`)
		tt.EqSlice(t, []byte{
			6, sbyte(-15), 25, 3, sbyte(-3), 3, 1, 0, sbyte(-2),
			3, 5, sbyte(-3), 8, 15, 2, sbyte(-32),
			8, 32, 0, 1, 1, 1, 1, 1, 1,
			1, 0, 1, 1, 0, 1,
			0, 0, 1, 0, 1, 0,
			1, 0, 1, 0, 0, 1, 0, 1,
			1, 0, 0, 0xff, 0xfe, 0,
			2, 0, 1, 2, 2, 7, 0x66, 0xef, 0xff, 0x5f,
			0xcd, 0xab, 0xcd, 0xab, 0xff, 0xfe, 1, 1, 1, 1, 1, 1,
		}, dat, mes, dat)
	})

	t.Run("ok: typecasts", func(t *testing.T) {
		dat, mes := compile(`flat!
			dw byte(-2) byte(-1) byte(0) byte(1) byte(2) byte(255)
			dw byte(-0xffff) byte(-0x7ffe) byte(-0x7fff) byte(0x1ff) byte(0xffff)
			dw word(-2) word(-1) word(0) word(1) word(2) word(255)
			dw word(-0x7ffe) word(-0x7fff) word(0x1ff) word(0xffff)
		`)
		tt.EqSlice(t, []byte{
			254, +0, 255, +0, 0, +0, 1, +0, 2, +0, 255, +0,
			1, +0, 2, +0, 1, +0, 255, +0, 255, +0,
			254, 255, 255, 255, 0, +0, 1, +0, 2, +0, 255, +0,
			2, 128, 1, 128, 255, 1, 255, 255,
		}, dat, mes, dat)
	})

	t.Run("ok: functions", func(t *testing.T) {
		dat, mes := compile(`flat!
			link { org 0 0 1; merge text _; org 0 0 0; merge bss _ }
			module ModA { const c001 = 1 }
			module ModB { const c002 = 2 }
			data d001 = byte * 5 : bss
			db sizeof(d001)
			db nameof(d001)
			db defined?(d001)
			db defined?(ModA:c001)
			db defined?(ModB:c001)
			db defined?(ModA:c002)
			db defined?(ModC:c002)
		`)
		tt.EqSlice(t, []byte{
			5, 'd', '0', '0', '1', 1, 1, 0, 0, 0,
		}, dat, mes, dat)
	})

	t.Run("ok: others", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 0 1; merge text ModA ModB _ }
			module ModA { const c001 = 1 }
			module ModB { import ModA; const c002 = 2 }
			macro m(a ...) {}
			macro m001() ={ macro m002(a) { db %%=a } }
			macro isform(a b) { if (formtypeof(%&a) != %=b) { compile-error %=b } }
			macro isexpr(a b) { if (exprtypeof(%=a) != %=b) { compile-error %=b } }
			section text
			proc f001(!) {
				data byte ["long long string"]
				expand-loop (1 + 2) { db 0xab}
				NOOP
				X <- 1
				AB <- 1 : 2
				A . { db 1 }
				A . f001(!)
				A . B@1
				A EQ?. <- 1
				[0x1234] -dnnm
				@1
				BCO f001 ==?
				m [+ X] [X +] (1 / 1) -10 0b1010 '\0' "ok\0" {
					A
					  + 1
					  . { db 1 }
					$(1)
					  -byte
				}
				m001; m002 1
				L0: JPR L0
				db 'o' 'k'
				isform A "reg"
				isform EQ? "cond"
				isform 1 "constexpr"
				isform { do } "block-form"
				isform [1] "mem-form"
				isform A@1 "unknown"
				isexpr 1 "int"
				isexpr "str" "str"
				isexpr (1 + 1) "unknown"
				RET
			}
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown label name L1", `flat!
				db $$(sizeof(L1))
			`,
			"L1 is not a data", `flat!
				L1: db $$(sizeof(L1))
			`,
			"unknown namespace nothing", `flat!
				import nothing
			`,
			"this is compile-error", `flat!
				compile-error "this is compile-error"
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileConstexpr(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			const c001 = 1
			make-counter enum001 0
			L1: db $$(1 + 2) $("ok") $$(c001) L1 __PC__ enum001 enum001
		`)
		tt.EqSlice(t, []byte{3, 'o', 'k', 1, 0, 5, 0, 1}, dat, mes, dat)
	})

	t.Run("ok: escape sequenses", func(t *testing.T) {
		dat, mes := compile(`flat!
			db '\0' '\a' '\b' '\e' '\f' '\n' '\r' '\t' '\v' '\\' '\'' '\"' '\x10'
			db "\0\a\b\e\f\n\r\t\v\\\'\"\x10"
		`)
		tt.EqSlice(t, []byte{
			0, '\a', '\b', 0x1b, '\f', '\n', '\r', '\t', '\v', '\\', '\'', '"', '\x10',
			0, '\a', '\b', 0x1b, '\f', '\n', '\r', '\t', '\v', '\\', '\'', '"', '\x10',
		}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"undefined name f", `flat!
				db $$(f)
			`,
			"unknown operator f", `flat!
				db $$(f())
			`,
			"L1 is not callable", `flat!
				L1: db $$(L1())
			`,
			"LD is not callable", `flat!
				db $$(LD())
			`,
			"cannot use label address in compile phase", `flat!
				L1: db $$(L1)
			`,
			"cannot use __PC__ in compile phase", `flat!
				db $$(__PC__)
			`,
			"cannot use __ORG__ in compile phase", `flat!
				db $$(__ORG__)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileConst(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			const c001 = 1
			const x001 = <declaration>
			module ModA {
				const c002 = 2
				const x002 = <declaration>
			}
			module ModB {
				const c003 = 3
				const x003 = <declaration>
			}
			data byte [ c001 ModA:c002 ModB:c003 ]
			experimental/define-constant x001 21
			experimental/define-constant x002 ModA 22
			experimental/define-constant ModB:x003 23
			const f001(a) = a + 1
			proc p001(!) {
				const c004 = 4
				data byte [ c001 ModA:c002 ModB:c003 c004 x001
 							ModA:x002 ModB:x003 f001(1) ]
				RET
			}
		`)
		tt.EqSlice(t, []byte{1, 2, 3, 1, 2, 3, 4, 21, 22, 23, 2}, dat[:len(dat)-1], mes, dat)
	})

	t.Run("ok: function", func(t *testing.T) {
		dat, mes := compile(`
			const c001 = 5
			const f001(a) = a + 1
			const f002(a b) = a * b + 1
			const f003(a b:3 c: c001) = a * b + c
			data byte [ f001(1) f002(2 3) f003(2) f003(2 4) f003(2 4 6)]
		`)
		tt.EqSlice(t, []byte{2, 7, 11, 13, 14}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				const ModA:c001 = 1
			`,
			"test is already defined", `
				const test = 1; const test = 1
			`,
			"undefined name c001", `flat!
				db $$(c001)
				const c001 = 1
			`,
			"f001 is not callable", `flat!
				const f001 = 1
				db f001()
			`,
			"constant c001 used before declaration", `flat!
				do {
					db c001
					const c001 = 1
				}
			`,
			"LD is a builtin name", `flat!
				const LD = 1
			`,
			"constant value is must be *core.Constexpr", `flat!
				macro mac(a) ={ const a = %=a }
				mac EQ?
			`,
			"qualified name is not allowed in this context", `flat!
				experimental/define-constant ModA:c001 ModB 1
			`,
			"unknown constant: ModA:c001", `flat!
				experimental/define-constant ModA:c001 1
			`,
			"unknown constant: ModA:c001", `flat!
				experimental/define-constant c001 ModA 1
			`,
			"unknown constant: c001", `flat!
				experimental/define-constant c001 1
			`,
			"c001 already defined", `flat!
				const c001 = 1
				experimental/define-constant c001 1
			`,
			"f001: 1 argument(s) required, but given 0", `flat!
				const f001(a) = a + 1
				db f001()
			`,
			"f001: 1 argument(s) required, but given 2", `flat!
				const f001(a) = a + 1
				db f001(1 2)
			`,
			"f001: 1..2 argument(s) required, but given 3", `flat!
				const f001(a b: 1) = a + b
				db f001(1 2 3)
			`,
			"undefined name b", `flat!
				const f001(a: b) = a + 1
				db f001()
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileData(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			link { org 0 0 1; merge text _; merge rodata _; org 0 0 0; merge bss _ }
			section text
			data b000 = byte [] : rodata
			data w000 = word [] : rodata
			data b001 = byte [0x01]
			data b002 = byte [0x23 0x45]
			data b003 = byte ["test" $(1) $$(2 + 3)]
			data r001 = byte [0x10] : rodata
			data w001 = word [0x6789]
			data w002 = word [0xABCD 0xEF01]
			data w003 = word [0x1234 't', 'e', 's', 't']
			data b004 = byte [0 1 [2 3] 4 5 [6 7 8]] : rodata
			data b005 = byte [0 1 2 3] * 1 : rodata
			data b006 = byte [4 5 6 7] * 3 : rodata
			data w005 = word [0xa 0xb] * 1 : rodata
			data w006 = word [0xc 0xd] * 2 : rodata

			section bss
			data b100 = byte * 10
			data w100 = word * 10
		`)
		tt.EqSlice(t, []byte{
			0x01, 0x23, 0x45, 't', 'e', 's', 't', 1, 5,
			0x89, 0x67, 0xCD, 0xAB, 0x01, 0xEF,
			0x34, 0x12, 't', 0, 'e', 0, 's', 0, 't', 0,
			0x10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3,
			4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7,
			0xa, 0, 0xb, 0, 0xc, 0, 0xd, 0, 0xc, 0, 0xd, 0,
		}, dat, mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				data ModA:b001 = byte
			`,
			"test is already defined", `
				data test = byte; data test = byte
			`,
			"LD is a builtin name", `
				data LD = byte
			`,
			"invalid data type qword", `flat!
				data qword
			`,
			"invalid data value *core.Identifier", `flat!
				data b001 = byte [quote(test)]
			`,
			"invalid repeat count 0", `flat!
				data byte * 0
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileInclude(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.AppendIncPath("./testdata/include")
		dat, _, mes := ttarch.DoCompile(g, `
			include "inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: relative path", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: twice", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc01.oc"
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: self", func(t *testing.T) {
		dat, mes := compile(`
			include "./testdata/include/inc04.oc"
		`)
		tt.EqSlice(t, []byte{0x01}, dat, mes)
	})

	t.Run("ok: in module", func(t *testing.T) {
		dat, mes := compile(`
			module ModA { include "./testdata/include/inc01.oc" }
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: flat!", func(t *testing.T) {
		dat, mes := compile(`flat!
			include "./testdata/include/inc01.oc"
			data b001 = byte [Mod:Co, Tc]
		`)
		tt.EqSlice(t, []byte{0xFC, 0xFD}, dat, mes)
	})

	t.Run("ok: keep original section", func(t *testing.T) {
		dat, mes := compile(`
			section text
			include "./testdata/include/inc02.oc"
			data b001 = byte [0xFA 0xFB]
		`)
		tt.EqSlice(t, []byte{0xFA, 0xFB, 0xFC}, dat, dat, mes)
	})

	t.Run("ok: loaded as main", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.CompileAndGenerate("./testdata/include/inc03.oc")
		tt.EqSlice(t, []byte{0x01}, tt.Flush(g.OutWriter))
	})

	t.Run("ok: not loaded as main", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.AppendIncPath("./testdata/include")
		dat, _, mes := ttarch.DoCompile(g, `
			include "inc03.oc"
		`)
		tt.EqSlice(t, []byte{0x00}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid path `/nothing.oc`", `
				include "/nothing.oc"
			`,
			"the file `nothing.oc` not found", `
				include "nothing.oc"
			`,
			"the file `./testdata/nothing.oc` not found", `
				include "./testdata/nothing.oc"
			`,
			"include must be in toplevel", `
				proc fn() { include "./testdata/include/inc01.oc"; RET }
			`,
			"undefined name ModA:Tc", `
				module ModA { include "./testdata/include/inc01.oc" }
				data b001 = byte [ModA:Tc]
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileEmbedFile(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			embed-file "./testdata/embed01.dat"
		`)
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat, mes)
	})

	t.Run("ok: from include path", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		g.AppendIncPath("./testdata")
		dat, _, mes := ttarch.DoCompile(g, `
			embed-file "embed01.dat"
		`)
		tt.EqSlice(t, []byte{0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8,
			7, 6, 5, 4, 3, 2, 1, 0}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		_, mes := compile(`
			embed-file "./testdata/nothing.dat"
		`)
		tt.Eq(t, "compile error: the file `./testdata/nothing.dat` not found", mes)
	})
}

func TestCompileAlign(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			data b001 = byte [0xFA]
			align 8
			data b002 = byte [0xFB]
		`)
		tt.EqSlice(t, []byte{0xFA, 0, 0, 0, 0, 0, 0, 0, 0xFB}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"the alignment size must be power of 2", `flat!
				align 0
			`,
			"the alignment size must be power of 2", `flat!
				align 5
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileControlFlow(t *testing.T) {
	t.Run("ok: do", func(t *testing.T) {
		dat, mes := compile(`flat!
			do ={ L01: }
			JMP L01
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error: prog", func(t *testing.T) {
		_, mes := compile(`flat!
			do { L01: }
			JMP L01
		`)
		tt.Eq(t, "compile error: undefined name L01", mes)
	})

	t.Run("ok: apply", func(t *testing.T) {
		dat, mes := compile(`flat!
			apply do { NOP }
		`)
		tt.EqSlice(t, []byte{0x00}, dat, mes)
	})

	t.Run("ok: loop", func(t *testing.T) {
		dat, mes := compile(`flat!
			loop {
				JMP _BEG
				JMP _END
				JMP _COND
			}
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: loop cond", func(t *testing.T) {
		dat, mes := compile(`flat!
			loop {
			} JMP _END
		`)
		tt.True(t, len(dat) > 0, mes)
	})
}

func TestCompileIf(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			if (1 == 2) { db 0 }
			if (1 == 1) { db 0 }
			if (1 == 2) { db 0 } else { db 1 }
			if (1 == 2) { db 0 } else if (1 == 1) { db 2 }
			if (1 == 2) { db 0 } else if (1 == 3) { db 1 } else { db 3 }
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: __if__ macro", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro __if__(c body eltag: _ elbody: _) {
				if use?(%&elbody) {
					do %=elbody
				} else {
					do %=body
				}
			}
			if EQ? { db 0 }
			if EQ? { db 0 } else { db 1 }
		`)
		tt.EqSlice(t, []byte{0, 1}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"then-body is must be block-form", `flat!
				if (1 == 1) A
			`,
			"invalid if form, expected `else`", `flat!
				if (1 == 1) { db 0 } ell
			`,
			"invalid if form, else body required", `flat!
				if (1 == 1) { db 0 } else
			`,
			"else-body is must be block-form", `flat!
				if (1 == 1) { db 0 } else iff
			`,
			"invalid else-if form", `flat!
				if (1 == 1) { db 0 } else if
			`,
			"cond is must be *core.Constexpr", `flat!
				if (1 == 1) { db 0 } else if EQ? {}
			`,
			"then-body is must be block-form", `flat!
				if (1 == 1) { db 0 } else if 1 B
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileCase(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			case 1 when 2 { db 0 }
			case 1 when 1 { db 0 }
			case 1 when 2 { db 0 } else { db 1 }
			case 1 when 2 { db 0 } when 1 { db 2 }
			case 1 when 2 { db 0 } when 3 { db 1 } else { db 3 }
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"case: 3+ argument(s) required, but given 1", `flat!
				case 1
			`,
			"value is must be *core.Constexpr", `flat!
				case A when 1 {}
			`,
			"invalid case-when form", `flat!
				case 1 when 1 {} when
			`,
			"pattern is must be *core.Constexpr", `flat!
				case 1 when EQ? {}
			`,
			"when-body is must be block-form", `flat!
				case 1 when 1 A
			`,
			"invalid case form. when/else required", `flat!
				case 1 when 1 { db 0 } ell
			`,
			"invalid case-else form", `flat!
				case 1 when 1 { db 0 } else
			`,
			"else-body is must be block-form", `flat!
				case 1 when 1 { db 0 } else A
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileModule(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			link {
				org 0 8 2
				merge text _
				merge rodata _

				org 8 8 0
				merge bss _

				org 0 0 1
				merge dat _
			}
			module Mod {
				section text;   db 0xF0 0xF1 0xF2
				section rodata; db 0xF3 0xF4
				section bss;    data byte * 4
				section dat;    db 0xF5 0xF6 0xF7
			}
		`)
		tt.EqSlice(t, []byte{0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0, 0, 0,
			0xF5, 0xF6, 0xF7}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				module ModA:ModA {}
			`,
			"test is already defined", `
				module test {}; module test {}
			`,
			"#.module must be in toplevel", `
				module ModA { module ModB {} }
			`,
			"LD is a builtin name", `
				module LD {}
			`,
			"link must be in toplevel", `
				module ModA { link {} }
			`,
			"link is already registered", `
				link {}; link {}
			`,
			"the section `invalid@ModA` is not linked", `
				module ModA { section invalid; db 1 }
			`,
			"unknown module unknown", `
				link { org 0 0 0; merge text unknown _ }
			`,
			"unknown module c001", `
				const c001 = 1
				link { org 0 0 0; merge text c001 _ }
			`,
			"invalid link form", `
				link { org 0 0 0; unknown }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileMacro(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac() { db 0 }
			mac
		`)
		tt.EqSlice(t, []byte{0}, dat, mes)
	})

	t.Run("ok: req=1", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a) { db %=a }
			mac 1
		`)
		tt.EqSlice(t, []byte{1}, dat, mes)
	})

	t.Run("ok: req=2", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b) { db %=a %=b }
			mac 1 2
		`)
		tt.EqSlice(t, []byte{1, 2}, dat, mes)
	})

	t.Run("ok: opt=1", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a: 10) { db %=a }
			mac 1
			mac
		`)
		tt.EqSlice(t, []byte{1, 10}, dat, mes)
	})

	t.Run("ok: req=1 opt=1", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b: 5) { db %=a %=b }
			mac 1 2
			mac 3
		`)
		tt.EqSlice(t, []byte{1, 2, 3, 5}, dat, mes)
	})

	t.Run("ok: rest", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a ...) { db %#a (2 + %#a) %*a }
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{3, 5, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: req=1 rest", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b ...) { db %=a %*b }
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{1, 2, 3}, dat, mes)
	})

	t.Run("ok: req=1 opt=1 rest", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac(a b: 10 c ...) { db %=a %=b %*c }
			mac 1
			mac 1 2
			mac 1 2 3
		`)
		tt.EqSlice(t, []byte{1, 10, 1, 2, 1, 2, 3}, dat, mes)
	})

	t.Run("ok: macro variable", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro mac() [l] ={ %=l: JMP %=l }
			mac
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: macro variable make-id", func(t *testing.T) {
		dat, mes := compile(`flat!
			const N = "N"
			macro mac(a b c) [id = %{"X" a b c N "Z"}] { db nameof(%=id) }
			mac ABC Y "STR"
		`)
		tt.EqSlice(t, []byte("XABCYSTRNZ"), dat, mes)
	})

	t.Run("ok: placeholder operation", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro m001(a ...) { db %>*a }
			macro m002(a ...) { db %>>*a }
			macro m003(a ...) { db %>>>*a }
			macro m004(a ...) { db %><a }
			macro m005(a ...) { db %>><a }
			macro m006(a ...) { db %>>><a }
			m001 _ 0 1 2
			m002 _ 0 1 2
			m003 _ 0 1 2
			m004 _ 0 1 2
			m005 _ 0 1 2
			m006 _ 0 1 2
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 1, 2, 2, 0, 1, 2}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid namespace ModA", `
				macro ModA:m001() {}
			`,
			"test is already defined", `
				macro test() {}; macro test() {}
			`,
			"invalid expansion", `flat!
				macro m001(a ...) { db %<a }
				m001
			`,
			"invalid expansion", `flat!
				macro m001(a ...) { db %>a }
				m001
			`,
			"rest parameter name required", `flat!
				macro mac(...) {}
			`,
			"the rest parameter cannot have default value", `flat!
				macro mac(a: _ ...) {}
			`,
			"default value required", `flat!
				macro mac(a: _ b) {}
			`,
			"unknown placeholder %=a in macro body", `flat!
				macro mac() { %=a }
				mac
			`,
			"vector operations only allowed on the rest parameter", `flat!
				macro mac(a) { %*a }
				mac 1
			`,
			"the expression itself required. use the %& placeholder", `flat!
				macro mac(a) { db $$(use?(%=a)) }
				mac (1 + 2)
			`,
			"the placeholder only accepts constant expressions", `flat!
				macro mac(a) { db $$(use?(%=a)) }
				mac A
			`,
			"the non-constant value cannot be expanded in the constant expression", `flat!
				macro mac(a ...) { db $$(use?(%>a)) }
				mac A A A
			`,
			"the %& placeholder is only allowed within constant expressions", `flat!
				macro mac(a) { db %&a }
				mac (1 + 2)
			`,
			"cannot use the macro `mac` within this context", `flat!
				macro mac() {}
				db $$(mac)
			`,
			"mac is not callable", `flat!
				macro mac() {}
				db $$(mac())
			`,
			"invalid fragment", `flat!
				macro mac(a) [b = %{a}] {}
				mac (1 + 2)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})

}

func TestCompileTco(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		s, _ := compile(`flat!
			proc f001(!) { RET }
			JMP f001
		`)
		dat, mes := compile(`flat!
			proc f001(!) { RET }
			tco { f001(!) }
		`)
		tt.True(t, len(s) > 0 && slices.Equal(s, dat), mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"only one statement is allowed within the tco form", `flat!
				proc f001(!) { RET }
				tco { f001(!); f001(!) }
			`,
			"proc call required", `flat!
				proc f001(!) { RET }
				tco { @1 }
			`,
			"the conditional call is not a tail call", `flat!
				proc f001(!) { RET }
				tco { EQ?.f001(!) }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompilePatch(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		s, u := compile(`flat!
			const d001 = <declaration>
			LD [d001] A@10
			A <- 0; *patch* d001 byte
		`)
		dat, mes := compile(`flat!
			LD [l001 + 1] A@10
			l001: A <- 0
		`)
		tt.True(t, len(s) > 0 && slices.Equal(s, dat), u, mes)
	})

	t.Run("ok: word", func(t *testing.T) {
		s, u := compile(`flat!
			const d001 = <declaration>
			LD [d001] A@10
			AB <- 0; *patch* d001 word
		`)
		dat, mes := compile(`flat!
			LD [(l001 + 1)] A@10
			l001: AB <- 0
		`)
		tt.True(t, len(s) > 0 && slices.Equal(s, dat), u, mes)
	})

	t.Run("ok: index", func(t *testing.T) {
		s, u := compile(`flat!
			const d001 = <declaration>
			LD [d001] A@10
			AB <- 0; *patch* d001 -2
		`)
		dat, mes := compile(`flat!
			LD [(l001 + 1)] A@10
			l001: AB <- 0
		`)
		tt.True(t, len(s) > 0 && slices.Equal(s, dat), u, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"declared but undefined", `flat!
				const d001 = <declaration>
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileAssert(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			beg: NOP; end:
			assert (end - beg == 1)
		`)
		tt.True(t, len(dat) == 1, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"assertion ([!= [- end beg] 1]) failed", `flat!
				beg: NOP; end:
				assert (end - beg != 1)
			`,
			"error message", `flat!
				beg: NOP; end:
				assert (end - beg != 1) "error message"
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileWith(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		s, _ := compile(`flat!
			LD A 1
			LD A 1
			LD A B
		`)
		dat, mes := compile(`flat!
			@1
			A <- 1
			A <- B
		`)
		tt.True(t, len(s) > 0 && slices.Equal(s, dat), mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"cannot use [X] as first operand for '<-'", `flat!
				[X] <- A
			`,
			"cannot use A as second operand for '-rep'", `flat!
				$(1) -rep A
			`,
			"cannot use X as operand#2 for LD", `flat!
				A <- X
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileNameType(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`
			module ModA { const c002 = 2 }
			macro m001() {}
			const c001 = 1
			proc f001(!) {
				data d001 = byte [0]
				L001:
				if (nametypeof(ModA) == "module") { db 1 }
				if (nametypeof(if) == "syntax") { db 2 }
				if (nametypeof(m001) == "macro") { db 3 }
				if (nametypeof(+) == "func") { db 4 }
				if (nametypeof(LD) == "inst") { db 5 }
				if (nametypeof(c001) == "const") { db 6 }
				if (nametypeof(d001) == "label") { db 7 }
				if (nametypeof(f001) == "label") { db 8 }
				if (nametypeof(L001) == "label") { db 9 }
				if (nametypeof(__PC__) == "special") { db 10 }
				if (nametypeof(ModA:c002) == "const") { db 11 }
				RET
			}
		`)
		tt.EqSlice(t, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, dat[:12], mes, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown name unknown", `flat!
				db nametypeof(unknown)
			`,
			"unknown name unknown:unknown", `flat!
				db nametypeof(unknown:unknown)
			`,
			"unknown name ModA:unknown", `flat!
				module ModA {}
				db nametypeof(ModA:unknown)
			`,
			"unknown name unknown:c001", `flat!
				const c001 = 1
				db nametypeof(unknown:c001)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileDebugInspect(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		g := ttarch.BuildGenerator(ttarch.BuildCompiler(), "")
		ttarch.DoCompile(g, `flat!
			debug-inspect "hello"
			debug-inspect EQ?
			debug-inspect quote(LD)
		`)
		tt.Eq(t, "[DEBUG] \"hello\"\n"+
			"[DEBUG] EQ?\n"+
			"[DEBUG] LD\n", tt.FlushString(g.ErrWriter))
	})
}

func TestCompileOppositeCondition(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			macro branch-unless(c l) {
				BCO %=l $$(opposite-condition(%&c))
			}
			L1: branch-unless EQ? L1
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error", func(t *testing.T) {
		_, mes := compile(`flat!
			macro branch-unless(c l) {
				BCO %=l $$(opposite-condition(%&c))
			}
			L1: branch-unless A L1
		`)
		tt.Eq(t, "compile error: invalid condition A", mes)
	})
}

func TestExpandBcCode(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			BIT 0 A
			BIT 1 A
			BIT 2 A
			BIT 3 A
			BIT 4 A
			BIT 5 A
			BIT 6 A
			BIT 7 A
			BMM 1
			BMM 2
			BMM 3
			L0: ds (0x80 - 2); JR L0
			JR L1; ds 0x7f; L1:
			L2: ds (0x8000 - 3); JPR L2
			JPR L3; ds 0x7fff; L3:

		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error: invalid BcImp range", func(t *testing.T) {
		lines := []string{
			`flat!; BIT -2 A`,
			`flat!; BIT -1 A`,
			`flat!; BIT 8 A`,
			`flat!; BIT 9 A`,
		}
		for _, i := range lines {
			_, mes := compile(i)
			tt.Eq(t, "compile error: the operand only accepts 0..7", mes)
		}
	})

	t.Run("error: invalid BcMap range", func(t *testing.T) {
		lines := []string{
			`flat!; BMM -1`,
			`flat!; BMM 0`,
			`flat!; BMM 4`,
			`flat!; BMM 5`,
		}
		for _, i := range lines {
			_, mes := compile(i)
			tt.Eq(t, "compile error: the operand only accepts 1..3", mes)
		}
	})

	t.Run("error: relative address out of range", func(t *testing.T) {
		lines := []string{
			`flat!; L0: ds (0x80 - 2 + 1); JR L0`,
			`flat!; JR L1; ds (0x7f + 1); L1:`,
			`flat!; L2: ds (0x8000 - 3 + 1); JPR L2`,
			`flat!; JPR L3; ds (0x7fff + 1); L3:`,
		}
		for _, i := range lines {
			_, mes := compile(i)
			tt.Eq(t, "compile error: the relative address is out of range", mes)
		}
	})
}

func TestSemanticCheck(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid operands for LD. some operand values may be out of range", `flat!
				LD A, 0xFFFF
			`,
			"cannot use X as operand#2 for LD", `flat!
				LD A, X
			`,
			"cannot determine the size of the instruction", `
				link { org 255 0 1; merge text _ }
				flat!
				L0: DNN (258 - (L1 - L0))
				L1:
			`,
			"invalid form b001(label)", `flat!
				data b001 = byte []
				b001 1
			`,
			"unknown form name unknown?", `flat!
				unknown? 1
			`,
			"<field> form not implemented yet", `flat!
				A <- L0.field
			`,
			"data type is must be *core.Constexpr", `flat!
				data d001 = struct { a: byte [0] }
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestExprCheck(t *testing.T) {
	t.Run("error", func(t *testing.T) {
		es := []string{
			"invalid form", `flat!
				macro mac(a ...) { %>*a }
				mac 1 2 3
			`,
			"invalid form", `flat!
				macro mac(a ...) { %*a }
				mac
			`,
			"flat! is not allowed in this context", `
				proc p001(!) { flat! }
			`,
			"section: 1 argument(s) required, but given 0", `
				section
			`,
			"section: 1 argument(s) required, but given 2", `
				section 1 2
			`,
			"apply: 1+ argument(s) required, but given 0", `
				apply
			`,
			"pragma is must be *core.Identifier", `
				pragma 1
			`,
			"qualified name is not allowed in this context", `
				pragma ns:invalid
			`,
			"unknown pragma: unknown", `
				pragma unknown
			`,
			"pragma: 2..3 argument(s) required, but given 4", `
				pragma list-constants 1 2 3
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestScanError(t *testing.T) {
	es := []string{
		"blank character literal is invalid", `
			db ''
		`,
		"invalid character escape", `
			db '\z'
		`,
		"invalid character escape", `
			db '\xZZ'
		`,
		"invalid character literal", `
			db 'ab'
		`,
		"invalid placeholder", `
			db %=[]
		`,
		"placeholders cannot contain namespaces", `
			db %=ns:id
		`,
		"reserved words cannot be use as placeholders", `
			db %=_END
		`,
		"leading whitespaces are required before the operator `.`", `
			A. {}
		`,
		"placeholders cannot contain namespaces", `
			%=ModA:a
		`,
		"no whitespace is allowed after the prefix operator", `
			~ 1
		`,
	}
	for x := 0; x < len(es); x += 2 {
		_, mes := compile(es[x+1])
		tt.Eq(t, "scan error: "+es[x], mes, es[x+1])
	}
}

func TestParseError(t *testing.T) {
	es := []string{
		`100`,
		`a; 100`,
		`$(1) + (1;`,
		`data byte !`,
		`data byte [A]`,
		`data byte [f001(!)]`,
		`data byte [EQ?]`,
		`data byte [1 !`,
		`const a =;`,
		`const a $`,
		`$(A)`,
		`$$(A)`,
		`[{}]`,
		`[1 !`,
		`A @1`,
		`A@@`,
		`mac {1;`,
		`mac (1 ! 1)`,
		`1`,
		`mac @`,
		`func.A(!)`,
		`func(!!)`,
		`A . { db 1 !`,
		`= 1`,
		`A <- [1;`,
		`db (1 == $$(1))`,
		`macro m;`,
		`macro m(a !`,
		`macro m(a ... !`,
		`macro m(a) !`,
		`macro m(a) [i !`,
		`proc f(!`,
		`proc f(A !)`,
		`proc f(A) !`,
	}
	for _, i := range es {
		_, mes := compile(i)
		tt.Prefix(t, "parse error: ", mes, i)
	}
}
