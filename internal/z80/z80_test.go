package z80

import (
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"testing"
)

func compile(src string) ([]byte, string) {
	return ttarch.Compile(BuildCompiler(), src)
}

func genlist(src string) (string, string) {
	return ttarch.GenList(BuildCompiler(), src)
}

func TestCompileTestFiles(t *testing.T) {
	tab := []string{
		"./testdata/opcodes",
		"./testdata/operators",
	}
	for _, i := range tab {
		a, b, mes := ttarch.CompileTestFile(BuildCompiler(), i)
		tt.EqSlice(t, a, b, mes)
	}
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list, mes := genlist(`
			section text
			proc f001(!) {
				A <- 1
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				A <- B
				RET
			}
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala

			     - 0000                                 .org 0

			     - 0000                             f001:
			000000 0000[2] 3e 01                        LD     A, 1
			000002 0002[2] 3e 04                        LD     A, 0+ (3 + 2) - 1
			000004 0004[2] 3e 01                        LD     A, lobyte(1)
			000006 0006[2] 3e 05                        LD     A, 0+ ((3 + 2) - 1) + lobyte(1)
			000008 0008[1] 78                           LD     A, B
			000009 0009[1] c9                           RET
		`)[1:]+"\n\n", list, mes)
	})
}

func TestCompileCall(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { RET }
			proc f002(!) { JP f001 }
			proc f003(-* !) { A | A; RET }
			f001(!)
			f002(!)
			f003(-* !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: sig", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(BC => DE) { RET }
			proc f002(B C => H L) { RET }
			proc f003(HL => DE !) { RET }
			f001(BC => DE)
			f002(B C => H L)
			f003(HL => DE !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: conditional call", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { RET }
			NC?.f001(!)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: fallthrough", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RET }
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"proc signature mismatch: f001.\n" +
				"  expected [B C] => [D E] ! [],\n" +
				"  given    [B C] => [H L] ! []", `flat!
				proc f001(BC => DE) { RET }
				f001(BC => HL)
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { @1 }
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { @1 }
				f001(-* !)
			`,
			"unsupported instruction in inline code", `flat!
				proc f001(-* !) { RETI }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileLDP(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			HL <- A : B
			HL -> A : B
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error: invalid", func(t *testing.T) {
		_, mes := compile(`flat!
			SP <- A : B
		`)
		tt.Eq(t, "compile error: invalid operands for LDP(#1 = SP, #2 = PQ)", mes)
	})
}

func TestCompileJump(t *testing.T) {
	dat, mes := compile(`flat!
		loop { NOP }
	`)
	tt.True(t, len(dat) > 0, mes)
}

func TestCompileOptimize(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			optimize near-jump
			L0: expand-loop 65 { JP L0 }
			expand-loop 65 { JP C? L1 }; L1:
		`)
		tt.EqSlice(t, []byte{
			0x18, 0xfe, 0x18, 0xfc, 0x18, 0xfa, 0x18, 0xf8, 0x18, 0xf6, 0x18, 0xf4, 0x18, 0xf2, 0x18, 0xf0,
			0x18, 0xee, 0x18, 0xec, 0x18, 0xea, 0x18, 0xe8, 0x18, 0xe6, 0x18, 0xe4, 0x18, 0xe2, 0x18, 0xe0,
			0x18, 0xde, 0x18, 0xdc, 0x18, 0xda, 0x18, 0xd8, 0x18, 0xd6, 0x18, 0xd4, 0x18, 0xd2, 0x18, 0xd0,
			0x18, 0xce, 0x18, 0xcc, 0x18, 0xca, 0x18, 0xc8, 0x18, 0xc6, 0x18, 0xc4, 0x18, 0xc2, 0x18, 0xc0,
			0x18, 0xbe, 0x18, 0xbc, 0x18, 0xba, 0x18, 0xb8, 0x18, 0xb6, 0x18, 0xb4, 0x18, 0xb2, 0x18, 0xb0,
			0x18, 0xae, 0x18, 0xac, 0x18, 0xaa, 0x18, 0xa8, 0x18, 0xa6, 0x18, 0xa4, 0x18, 0xa2, 0x18, 0xa0,
			0x18, 0x9e, 0x18, 0x9c, 0x18, 0x9a, 0x18, 0x98, 0x18, 0x96, 0x18, 0x94, 0x18, 0x92, 0x18, 0x90,
			0x18, 0x8e, 0x18, 0x8c, 0x18, 0x8a, 0x18, 0x88, 0x18, 0x86, 0x18, 0x84, 0x18, 0x82, 0x18, 0x80,
			0xc3, 0x00, 0x00, 0xda, 0x06, 0x01,
			0x38, 0x7e, 0x38, 0x7c, 0x38, 0x7a, 0x38, 0x78, 0x38, 0x76, 0x38, 0x74, 0x38, 0x72, 0x38, 0x70,
			0x38, 0x6e, 0x38, 0x6c, 0x38, 0x6a, 0x38, 0x68, 0x38, 0x66, 0x38, 0x64, 0x38, 0x62, 0x38, 0x60,
			0x38, 0x5e, 0x38, 0x5c, 0x38, 0x5a, 0x38, 0x58, 0x38, 0x56, 0x38, 0x54, 0x38, 0x52, 0x38, 0x50,
			0x38, 0x4e, 0x38, 0x4c, 0x38, 0x4a, 0x38, 0x48, 0x38, 0x46, 0x38, 0x44, 0x38, 0x42, 0x38, 0x40,
			0x38, 0x3e, 0x38, 0x3c, 0x38, 0x3a, 0x38, 0x38, 0x38, 0x36, 0x38, 0x34, 0x38, 0x32, 0x38, 0x30,
			0x38, 0x2e, 0x38, 0x2c, 0x38, 0x2a, 0x38, 0x28, 0x38, 0x26, 0x38, 0x24, 0x38, 0x22, 0x38, 0x20,
			0x38, 0x1e, 0x38, 0x1c, 0x38, 0x1a, 0x38, 0x18, 0x38, 0x16, 0x38, 0x14, 0x38, 0x12, 0x38, 0x10,
			0x38, 0x0e, 0x38, 0x0c, 0x38, 0x0a, 0x38, 0x08, 0x38, 0x06, 0x38, 0x04, 0x38, 0x02, 0x38, 0x00,
		}, dat, mes)
	})

	t.Run("ok: volatile", func(t *testing.T) {
		dat, mes := compile(`flat!
			optimize near-jump
			L0: <volatile> JP L0; NOP
		`)
		tt.EqSlice(t, []byte{0xc3, 0x00, 0x00, 0x00}, dat, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown optimizer: unknown", `flat!
				optimize unknown
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileError(t *testing.T) {
	es := []string{
		"cannot use invalid-operand as operand#2 for LD", `flat!
			HL <- [1 2 3]
		`,
		"cannot use invalid-operand as operand#2 for LD", `flat!
			A <- [E]
		`,
		"invalid operands", `flat!
			BC -zero?
		`,
		"invalid operands for OUT. some operand values may be out of range", `flat!
			OUT [1024] A
		`,
	}
	for x := 0; x < len(es); x += 2 {
		_, mes := compile(es[x+1])
		tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
	}
}
