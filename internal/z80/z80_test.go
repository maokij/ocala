package z80_test

import (
	"ocala/internal/core"
	"ocala/internal/tt"
	"ocala/internal/tt/ttarch"
	"os"
	"slices"
	"strings"
	"testing"
)

func compile(src string) ([]byte, string) {
	return ttarch.Compile("z80", src)
}

func genlist(src string) (string, string) {
	return ttarch.GenList("z80", src)
}

func TestCompileTestFiles(t *testing.T) {
	tab := []string{
		"z80", "./testdata/opcodes",
		"z80", "./testdata/operators",
		"z80+undocumented", "./testdata/opcodes_undocumented",
		"z80+undocumented", "./testdata/operators_undocumented",
		"z80+compat8080", "./testdata/opcodes_compat8080",
		"z80+compat8080", "./testdata/operators_compat8080",
	}
	for i := range slices.Chunk(tab, 2) {
		a, b, mes := ttarch.CompileTestFile("z80", i[1])
		tt.EqSlice(t, a, b, mes, i)
	}
}

func TestCompileUnsupportedFiles(t *testing.T) {
	tab := []string{
		"z80+compat8080", "./testdata/opcodes_compat8080",
	}
	for i := range slices.Chunk(tab, 2) {
		s, err := os.ReadFile(i[1] + ".unsupported")
		if err != nil {
			panic(err)
		}

		lines := strings.Split(string(s), "\n")
		arch := i[0]
		for x, i := range lines[:len(lines)-1] {
			g := ttarch.NewGenerator("flat!\n" + i)
			g.SetCompiler(core.NewCompiler(arch))
			_, _, mes := ttarch.DoCompile(g, "-")
			tt.Eq(t, "compile error: unsupported instruction for "+arch, mes, x, i)
		}
	}
}

func TestGenerateList(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		list, mes := genlist(`
			section text
			proc f001(!) {
				A <- 1
				A <- (3 + 2 - 1)
				A <- lobyte(1)
				A <- (3 + 2 - 1 + lobyte(1))
				A <- B
				A <- hibyte(f001)
				RET
			}
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "z80"

			     - 0000                                 .org 0

			     - 0000                             f001:
			000000 0000[2] 3e 01                        LD     A, 1
			000002 0002[2] 3e 04                        LD     A, 0+ (3 + 2) - 1
			000004 0004[2] 3e 01                        LD     A, lobyte(1)
			000006 0006[2] 3e 05                        LD     A, 0+ ((3 + 2) - 1) + lobyte(1)
			000008 0008[1] 78                           LD     A, B
			000009 0009[2] 3e 00                        LD     A, hibyte(f001)
			00000b 000b[1] c9                           RET
		`)[1:]+"\n\n", list, mes)
	})

	t.Run("ok: optimize 0", func(t *testing.T) {
		list, mes := genlist(`flat!
			optimize near-jump 0
			L0: $(L0) -jump; $(L1) -jump
			L1: $(L0) -jump-if Z?
			fn()
			proc fn() { RET }
			C?.fn()
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "z80"

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[3] c3 00 00                     JP     L0
			000003 0003[3] c3 06 00                     JP     L1
			     - 0006                             L1:
			000006 0006[3] ca 00 00                     JP     Z, L0
			000009 0009[3] cd 0c 00                     CALL   fn

			     - 000c                             fn:
			00000c 000c[1] c9                           RET

			00000d 000d[3] dc 0c 00                     CALL   C, fn
		`)[1:]+"\n", list, mes)
	})

	t.Run("ok: optimize 1", func(t *testing.T) {
		list, mes := genlist(`flat!
			optimize near-jump 1
			L0: $(L0) -jump; $(L1) -jump
			L1: $(L0) -jump-if Z?
			fn()
			proc fn() { RET }
			C?.fn()
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "z80"

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[3] c3 00 00                     JP     L0
			000003 0003[2] 18 00                        JR     L1
			     - 0005                             L1:
			000005 0005[3] ca 00 00                     JP     Z, L0
			000008 0008[3] cd 0b 00                     CALL   fn

			     - 000b                             fn:
			00000b 000b[1] c9                           RET

			00000c 000c[3] dc 0b 00                     CALL   C, fn
		`)[1:]+"\n", list, mes)
	})

	t.Run("ok: optimize 2", func(t *testing.T) {
		list, mes := genlist(`flat!
			optimize near-jump 2
			L0: $(L0) -jump; $(L1) -jump
			L1: $(L0) -jump-if Z?
			fn()
			proc fn() { RET }
			C?.fn()
		`)
		tt.EqText(t, tt.Unindent(`
			|                                            ; generated by ocala
			                                            __ARCH__ = "z80"

			     - 0000                                 .org 0
			     - 0000                             L0:
			000000 0000[2] 18 fe                        JR     L0
			000002 0002[2] 18 00                        JR     L1
			     - 0004                             L1:
			000004 0004[2] 28 fa                        JR     Z, L0
			000006 0006[3] cd 09 00                     CALL   fn

			     - 0009                             fn:
			000009 0009[1] c9                           RET

			00000a 000a[3] dc 09 00                     CALL   C, fn
		`)[1:]+"\n", list, mes)
	})
}

func TestCompileCall(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { RET }
			proc f002(!) { JP f001 }
			proc f003(-* !) { A | A; RET }
			f001(!)
			f002(!)
			f003(-* !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: sig", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(BC => DE) { RET }
			proc f002(B C => H L) { RET }
			proc f003(HL => DE !) { RET }
			f001(BC => DE)
			f002(B C => H L)
			f003(HL => DE !)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: conditional call", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { RET }
			NC?.f001(!)
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("ok: fallthrough", func(t *testing.T) {
		dat, mes := compile(`flat!
			proc f001(!) { fallthrough }
			proc f002(!) { RET }
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"proc signature mismatch: f001.\n" +
				"  expected [B C] => [D E] ! [],\n" +
				"  given    [B C] => [H L] ! []", `flat!
				proc f001(BC => DE) { RET }
				f001(BC => HL)
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) { @1 }
			`,
			"the last instruction must be a return/fallthrough within the proc", `flat!
				proc f001(!) {}
			`,
			"the fallthrough must be followed by a proc", `flat!
				proc f001(!) { fallthrough }
			`,
			"invalid inline proc tail", `flat!
				proc f001(-* !) { @1 }
				f001(-* !)
			`,
			"unsupported instruction in inline code", `flat!
				proc f001(-* !) { RETI }
				f001(-* !)
			`,
			"undefined proc f001", `flat!
				f001(!)
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileLDP(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			HL <- A : B
			HL -> A : B
		`)
		tt.True(t, len(dat) > 0, mes)
	})

	t.Run("error: invalid", func(t *testing.T) {
		_, mes := compile(`flat!
			SP <- A : B
		`)
		tt.Eq(t, "compile error: invalid operands for LDP(#1 = SP, #2 = PQ)", mes)
	})
}

func TestCompileJump(t *testing.T) {
	dat, mes := compile(`flat!
		loop { NOP }
	`)
	tt.True(t, len(dat) > 0, mes)
}

func TestCompileOptimize(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		dat, mes := compile(`flat!
			optimize near-jump 2
			L0: expand-loop 65 { $(L0) -jump }
			expand-loop 65 { $(L1) -jump-if C? }; L1:
			L2: expand-loop 32 { $(L3) -jump }
			expand-loop 32 { $(L2) -jump }; L3:
		`)
		tt.EqSlice(t, []byte{
			0x18, 0xfe, 0x18, 0xfc, 0x18, 0xfa, 0x18, 0xf8, 0x18, 0xf6, 0x18, 0xf4, 0x18, 0xf2, 0x18, 0xf0,
			0x18, 0xee, 0x18, 0xec, 0x18, 0xea, 0x18, 0xe8, 0x18, 0xe6, 0x18, 0xe4, 0x18, 0xe2, 0x18, 0xe0,
			0x18, 0xde, 0x18, 0xdc, 0x18, 0xda, 0x18, 0xd8, 0x18, 0xd6, 0x18, 0xd4, 0x18, 0xd2, 0x18, 0xd0,
			0x18, 0xce, 0x18, 0xcc, 0x18, 0xca, 0x18, 0xc8, 0x18, 0xc6, 0x18, 0xc4, 0x18, 0xc2, 0x18, 0xc0,
			0x18, 0xbe, 0x18, 0xbc, 0x18, 0xba, 0x18, 0xb8, 0x18, 0xb6, 0x18, 0xb4, 0x18, 0xb2, 0x18, 0xb0,
			0x18, 0xae, 0x18, 0xac, 0x18, 0xaa, 0x18, 0xa8, 0x18, 0xa6, 0x18, 0xa4, 0x18, 0xa2, 0x18, 0xa0,
			0x18, 0x9e, 0x18, 0x9c, 0x18, 0x9a, 0x18, 0x98, 0x18, 0x96, 0x18, 0x94, 0x18, 0x92, 0x18, 0x90,
			0x18, 0x8e, 0x18, 0x8c, 0x18, 0x8a, 0x18, 0x88, 0x18, 0x86, 0x18, 0x84, 0x18, 0x82, 0x18, 0x80,
			0xc3, 0x00, 0x00, 0xda, 0x06, 0x01,
			0x38, 0x7e, 0x38, 0x7c, 0x38, 0x7a, 0x38, 0x78, 0x38, 0x76, 0x38, 0x74, 0x38, 0x72, 0x38, 0x70,
			0x38, 0x6e, 0x38, 0x6c, 0x38, 0x6a, 0x38, 0x68, 0x38, 0x66, 0x38, 0x64, 0x38, 0x62, 0x38, 0x60,
			0x38, 0x5e, 0x38, 0x5c, 0x38, 0x5a, 0x38, 0x58, 0x38, 0x56, 0x38, 0x54, 0x38, 0x52, 0x38, 0x50,
			0x38, 0x4e, 0x38, 0x4c, 0x38, 0x4a, 0x38, 0x48, 0x38, 0x46, 0x38, 0x44, 0x38, 0x42, 0x38, 0x40,
			0x38, 0x3e, 0x38, 0x3c, 0x38, 0x3a, 0x38, 0x38, 0x38, 0x36, 0x38, 0x34, 0x38, 0x32, 0x38, 0x30,
			0x38, 0x2e, 0x38, 0x2c, 0x38, 0x2a, 0x38, 0x28, 0x38, 0x26, 0x38, 0x24, 0x38, 0x22, 0x38, 0x20,
			0x38, 0x1e, 0x38, 0x1c, 0x38, 0x1a, 0x38, 0x18, 0x38, 0x16, 0x38, 0x14, 0x38, 0x12, 0x38, 0x10,
			0x38, 0x0e, 0x38, 0x0c, 0x38, 0x0a, 0x38, 0x08, 0x38, 0x06, 0x38, 0x04, 0x38, 0x02, 0x38, 0x00,
			//
			0x18, 0x7e, 0x18, 0x7c, 0x18, 0x7a, 0x18, 0x78, 0x18, 0x76, 0x18, 0x74, 0x18, 0x72, 0x18, 0x70,
			0x18, 0x6e, 0x18, 0x6c, 0x18, 0x6a, 0x18, 0x68, 0x18, 0x66, 0x18, 0x64, 0x18, 0x62, 0x18, 0x60,
			0x18, 0x5e, 0x18, 0x5c, 0x18, 0x5a, 0x18, 0x58, 0x18, 0x56, 0x18, 0x54, 0x18, 0x52, 0x18, 0x50,
			0x18, 0x4e, 0x18, 0x4c, 0x18, 0x4a, 0x18, 0x48, 0x18, 0x46, 0x18, 0x44, 0x18, 0x42, 0x18, 0x40,
			0x18, 0xbe, 0x18, 0xbc, 0x18, 0xba, 0x18, 0xb8, 0x18, 0xb6, 0x18, 0xb4, 0x18, 0xb2, 0x18, 0xb0,
			0x18, 0xae, 0x18, 0xac, 0x18, 0xaa, 0x18, 0xa8, 0x18, 0xa6, 0x18, 0xa4, 0x18, 0xa2, 0x18, 0xa0,
			0x18, 0x9e, 0x18, 0x9c, 0x18, 0x9a, 0x18, 0x98, 0x18, 0x96, 0x18, 0x94, 0x18, 0x92, 0x18, 0x90,
			0x18, 0x8e, 0x18, 0x8c, 0x18, 0x8a, 0x18, 0x88, 0x18, 0x86, 0x18, 0x84, 0x18, 0x82, 0x18, 0x80,
		}, dat, mes)
	})

	t.Run("ok: JP", func(t *testing.T) {
		dat, mes := compile(`flat!
			optimize near-jump 2
			L0: JP L0; NOP
		`)
		tt.EqSlice(t, []byte{0xc3, 0x00, 0x00, 0x00}, dat, mes)
	})

	t.Run("ok: optimize 0", func(t *testing.T) {
		s, _ := compile(`flat!
			L0: JP L0; NOP
		`)
		dat, mes := compile(`flat!
			optimize near-jump 0
			L0: $(L0) -jump; NOP
		`)
		tt.EqSlice(t, s, dat, mes, s, dat)
	})

	t.Run("ok: optimize 1", func(t *testing.T) {
		s, _ := compile(`flat!
			L0: JP L0; JR L1; L1:
		`)
		dat, mes := compile(`flat!
			optimize near-jump 1
			L0: $(L0) -jump; $(L1) -jump; L1:
		`)
		tt.EqSlice(t, s, dat, mes, s, dat)
	})

	t.Run("error", func(t *testing.T) {
		es := []string{
			"unknown optimizer: unknown", `flat!
				optimize unknown
			`,
			"the optimizer does not support +compat8080", `
				arch z80 +compat8080; flat!
				optimize near-jump 1
			`,
		}
		for x := 0; x < len(es); x += 2 {
			_, mes := compile(es[x+1])
			tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
		}
	})
}

func TestCompileError(t *testing.T) {
	es := []string{
		"cannot use invalid-operand as operand#2 for LD", `flat!
			HL <- [1 2 3]
		`,
		"cannot use invalid-operand as operand#2 for LD", `flat!
			A <- [E]
		`,
		"invalid operands", `flat!
			BC -zero?
		`,
		"invalid operands for OUT. some operand values may be out of range", `flat!
			OUT [1024] A
		`,
	}
	for x := 0; x < len(es); x += 2 {
		_, mes := compile(es[x+1])
		tt.Eq(t, "compile error: "+es[x], mes, es[x+1])
	}
}
